
sourcing "nvim_exec2()"
line 1:     amenu     PopUp.Open\ in\ web\ browser  gx
line 2:     anoremenu PopUp.Inspect                 <Cmd>Inspect<CR>
line 3:     anoremenu PopUp.Go\ to\ definition      <Cmd>lua vim.lsp.buf.definition()<CR>
line 4:     anoremenu PopUp.Show\ Diagnostics       <Cmd>lua vim.diagnostic.open_float()<CR>
line 5:     anoremenu PopUp.Show\ All\ Diagnostics  <Cmd>lua vim.diagnostic.setqflist()<CR>
line 6:     anoremenu PopUp.Configure\ Diagnostics  <Cmd>help vim.diagnostic.config()<CR>
line 7:     anoremenu PopUp.-1-                     <Nop>
line 8:     vnoremenu PopUp.Cut                     "+x
line 9:     vnoremenu PopUp.Copy                    "+y
line 10:     anoremenu PopUp.Paste                   "+gP
line 11:     vnoremenu PopUp.Paste                   "+P
line 12:     vnoremenu PopUp.Delete                  "_x
line 13:     nnoremenu PopUp.Select\ All             ggVG
line 14:     vnoremenu PopUp.Select\ All             gg0oG$
line 15:     inoremenu PopUp.Select\ All             <C-Home><C-O>VG
line 16:     anoremenu PopUp.-2-                     <Nop>
line 17:     anoremenu PopUp.How-to\ disable\ mouse  <Cmd>help disable-mouse<CR>
line 18:   
finished sourcing nvim_exec2()
Searching for "ftplugin.vim" in runtime path
Searching for "/Users/joe/.config/nvim/ftplugin.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_load_ftplugin")
line 8:   finish
line 9: endif
line 10: let did_load_ftplugin = 1
line 11: 
line 12: augroup filetypeplugin
line 13:   au FileType * call s:LoadFTPlugin()
line 14: 
line 15:   func! s:LoadFTPlugin()
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/Users/joe/.config/nvim/indent.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   finish
line 9: endif
line 10: let did_indent_on = 1
line 11: 
line 12: augroup filetypeindent
line 13:   au FileType * call s:LoadIndent()
line 14:   func! s:LoadIndent()
line 33: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/indent.vim"
could not source "/opt/homebrew/etc/xdg/nvim/sysinit.vim"
could not source "/etc/xdg/nvim/sysinit.vim"
could not source "$VIM/sysinit.vim"
sourcing "/Users/joe/.config/nvim/init.lua"
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
line 0: sourcing "nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:0"
line 1:   augroup filetypedetect
line 2:   runtime! ftdetect/*.{vim,lua}
Searching for "ftdetect/*.{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftdetect/*.{vim,lua}"
not found in runtime path: "ftdetect/*.{vim,lua}"
line 3:   augroup END
finished sourcing nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:0
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua"
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#installed_parsers TSUninstall lua require'nvim-treesitter.install'.commands.TSUninstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallFromGrammar lua require'nvim-treesitter.install'.commands.TSInstallFromGrammar['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdateSync lua require'nvim-treesitter.install'.commands.TSUpdateSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstall lua require'nvim-treesitter.install'.commands.TSInstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdate lua require'nvim-treesitter.install'.commands.TSUpdate['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallSync lua require'nvim-treesitter.install'.commands.TSInstallSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=? -complete=custom,nvim_treesitter#available_modules TSModuleInfo lua require'nvim-treesitter.info'.commands.TSModuleInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSInstallInfo lua require'nvim-treesitter.info'.commands.TSInstallInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQuery lua require'nvim-treesitter.configs'.commands.TSEditQuery['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSConfigInfo lua require'nvim-treesitter.configs'.commands.TSConfigInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSToggle lua require'nvim-treesitter.configs'.commands.TSToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSDisable lua require'nvim-treesitter.configs'.commands.TSDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSEnable lua require'nvim-treesitter.configs'.commands.TSEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufToggle lua require'nvim-treesitter.configs'.commands.TSBufToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufDisable lua require'nvim-treesitter.configs'.commands.TSBufDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufEnable lua require'nvim-treesitter.configs'.commands.TSBufEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQueryUserAfter lua require'nvim-treesitter.configs'.commands.TSEditQueryUserAfter['run<bang>'](<f-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
Searching for "parser/bash.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/bash.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/bash.so"
Searching for "parser/c.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/c.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/c.so"
Searching for "parser/diff.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/diff.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/diff.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/diff.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/diff.so"
Searching for "parser/html.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/html.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/html.so"
Searching for "parser/lua.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/lua.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/lua.so"
Searching for "parser/luadoc.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/luadoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/luadoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/luadoc.so"
Searching for "parser/markdown.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/markdown.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/markdown.so"
Searching for "parser/markdown_inline.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/markdown_inline.so"
Searching for "parser/query.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/query.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/query.so"
Searching for "parser/vim.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/vim.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/vim.so"
Searching for "parser/vimdoc.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/vimdoc.so"
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim"
line 1: if exists('g:vimade_loaded')
line 2:   finish
line 3: endif
line 4: 
line 5: let g:vimade_loaded = 1
line 6: 
line 7: if !exists('g:vimade')
line 8:   let g:vimade = {}
line 9: endif
line 10: 
line 11: 
line 12: ""Enables Vimade
line 13: command! VimadeEnable call vimade#Enable()
line 14: 
line 15: ""Unfades all buffers, signs, and disables Vimade
line 16: command! VimadeDisable call vimade#Disable()
line 17: 
line 18: ""Disables the current window
line 19: command! VimadeWinDisable call vimade#WinDisable()
line 20: 
line 21: ""Disables the current buffer
line 22: command! VimadeBufDisable call vimade#BufDisable()
line 23: 
line 24: ""Fades the current buffer
line 25: command! VimadeFadeActive call vimade#FadeActive()
line 26: "
line 27: ""Unfades the current buffer
line 28: command! VimadeUnfadeActive call vimade#UnfadeActive()
line 29: 
line 30: ""Enables the current window
line 31: command! VimadeWinEnable call vimade#WinEnable()
line 32: 
line 33: ""Enables the current buffer
line 34: command! VimadeBufEnable call vimade#BufEnable()
line 35: 
line 36: ""Toggles Vimade between enabled and disabled states
line 37: command! VimadeToggle call vimade#Toggle()
line 38: 
line 39: ""Prints debug information that should be included in bug reports
line 40: command! VimadeInfo echo json_encode(vimade#GetInfo())
line 41: 
line 42: ""Recalculates all fades and redraws all inactive buffers and signs
line 43: command! VimadeRedraw call vimade#Redraw()
line 44: 
line 45: ""Changes vimade_fadelevel to the {value} specified.  {value} can be between
line 46: "0.0 and 1.0
line 47: command! -nargs=1 VimadeFadeLevel call vimade#FadeLevel(<q-args>)
line 48: 
line 49: ""Changes vimade_fadepriority to the {value} specified.  This can be useful
line 50: "when combining Vimade with other plugins that also highlight using matches
line 51: command! -nargs=1 VimadeFadePriority call vimade#FadePriority(<q-args>)
line 52: 
line 53: ""Overrides the Folded highlight by creating a link to the Vimade base fade.
line 54: "This should produce acceptable results for colorschemes that include Folded
line 55: "highlights that are distracting in faded windows.
line 56: command! VimadeOverrideFolded call vimade#OverrideFolded()
line 57: 
line 58: ""EXPERIMENTAL -- Overrides the SignColumn highlight by creating a link to the Vimade base fade.
line 59: "This should produce acceptable results for colorschemes that include Folded
line 60: "highlights that are distracting in faded windows.
line 61: command! VimadeOverrideSignColumn call vimade#OverrideSignColumn()
line 62: 
line 63: ""EXPERIMENTAL -- Overrides the LineNr highlight by creating a link to the Vimade base fade.
line 64: "This should produce acceptable results for colorschemes that include Folded
line 65: "highlights that are distracting in faded windows.
line 66: command! VimadeOverrideLineNr call vimade#OverrideLineNr()
line 67: 
line 68: ""EXPERIMENTAL -- Overrides the VertSplit highlight by creating a link to the Vimade base fade.
line 69: "This should produce acceptable results for colorschemes that include Folded
line 70: "highlights that are distracting in faded windows.
line 71: command! VimadeOverrideSplits call vimade#OverrideVertSplit()
line 72: 
line 73: ""EXPERIMENTAL -- Overrides the NonText highlight by creating a link to the Vimade base fade.
line 74: "This should produce acceptable results for colorschemes that include Folded
line 75: "highlights that are distracting in faded windows.
line 76: command! VimadeOverrideNonText call vimade#OverrideNonText()
line 77: 
line 78: ""EXPERIMENTAL -- Overrides the EndOfBuffer highlight by creating a link to the Vimade base fade.
line 79: "This should produce acceptable results for colorschemes that include Folded
line 80: "highlights that are distracting in faded windows.
line 81: command! VimadeOverrideEndOfBuffer call vimade#OverrideEndOfBuffer()
line 82: 
line 83: ""EXPERIMENTAL -- Overrides static highlights by creating a link to the Vimade base fade.
line 84: "This should produce acceptable results for colorschemes that include Folded
line 85: "highlights that are distracting in faded windows.
line 86: command! VimadeOverrideAll call vimade#OverrideAll()
line 87: 
line 88: "" EXPERIMENTAL - Loads the current lua-only commands for Neovim (VimadeFocus & VimadeMark)
line 89: if has('nvim')
line 90:   lua require('vimade.focus.commands')
line 91: endif
line 92: 
line 93: let g:vimade_plugin_current_directory = resolve(expand('<sfile>:p:h').'/../lib')
line 94: 
line 95: if (!exists('g:vimade.lazy') || !g:vimade.lazy) && !exists('g::vimade_loaded')
line 96:   if v:vim_did_enter
line 97:     call vimade#Load()
line 98:   else
line 99:     augroup vimade
line 100:       au!
line 101:       au VimEnter * call vimade#Load()
line 102:     augroup END
line 103:   endif
line 104: endif
finished sourcing /Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim"
line 1: " sleuth.vim - Heuristically set buffer options
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.0
line 4: " GetLatestVimScripts: 4375 1 :AutoInstall: sleuth.vim
line 5: 
line 6: if exists("#polyglot-sleuth")
line 7:   autocmd! polyglot-sleuth
line 8:   augroup! polyglot-sleuth
line 9:   unlet! g:loaded_sleuth
line 10:   let s:polyglot = 1
line 11: endif
line 12: 
line 13: if exists("g:loaded_sleuth") || v:version < 700 || &cp
line 14:   finish
line 15: endif
line 16: let g:loaded_sleuth = 1
line 17: lockvar g:loaded_sleuth
line 18: 
line 19: function! s:Warn(msg, ...) abort
line 27: 
line 28: if exists('+shellslash')
line 29:   function! s:Slash(path) abort
line 32: else
line 33:   function! s:Slash(path) abort
line 36: endif
line 37: 
line 38: function! s:Guess(source, detected, lines) abort
line 149: 
line 150: function! s:Capture(cmd) abort
line 156: 
line 157: let s:modeline_numbers = { 'shiftwidth': 'shiftwidth', 'sw': 'shiftwidth', 'tabstop': 'tabstop', 'ts': 'tabstop', 'textwidth': 'textwidth', 'tw': 'textwidth', }
line 162: let s:modeline_booleans = { 'expandtab': 'expandtab', 'et': 'expandtab', 'fixendofline': 'fixendofline', 'fixeol': 'fixendofline', }
line 166: function! s:ParseOptions(declarations, into, ...) abort
line 181: 
line 182: function! s:ModelineOptions() abort
line 203: 
line 204: let s:fnmatch_replacements = { '.': '\.', '\%': '%', '\(': '(', '\)': ')', '\{': '{', '\}': '}', '\_': '_', '?': '[^/]', '*': '[^/]*', '/**/*': '/.*', '/**/': '/\%(.*/\)\=', '**': '.*'}
line 207: function! s:FnmatchReplace(pat) abort
line 231: 
line 232: function! s:FnmatchTranslate(pat) abort
line 235: 
line 236: function! s:ReadEditorConfig(absolute_path) abort
line 268: 
line 269: let s:editorconfig_cache = {}
line 270: function! s:DetectEditorConfig(absolute_path, ...) abort
line 314: 
line 315: let s:editorconfig_bomb = { 'utf-8':     0, 'utf-8-bom': 1, 'utf-16be':  1, 'utf-16le':  1, 'latin1':    0, }
line 322: 
line 323: let s:editorconfig_fileformat = { 'cr':   'mac', 'crlf': 'dos', 'lf':   'unix', }
line 328: 
line 329: function! s:EditorConfigToOptions(pairs) abort
line 383: 
line 384: function! s:Ready(detected) abort
line 387: 
line 388: let s:booleans = {'expandtab': 1, 'fixendofline': 1, 'endofline': 1, 'bomb': 1}
line 389: let s:safe_options = ['expandtab', 'shiftwidth', 'tabstop', 'textwidth', 'fixendofline']
line 390: let s:all_options = s:safe_options + ['endofline', 'fileformat', 'fileencoding', 'bomb']
line 391: let s:short_options = { 'expandtab': 'et', 'shiftwidth': 'sw', 'tabstop': 'ts', 'textwidth': 'tw', 'fixendofline': 'fixeol', 'endofline': 'eol', 'fileformat': 'ff', 'fileencoding': 'fenc'}
line 395: 
line 396: function! s:Apply(detected, permitted_options, silent) abort
line 459: 
line 460: function! s:UserOptions(ft, name) abort
line 487: 
line 488: function! s:DetectDeclared() abort
line 512: 
line 513: function! s:DetectHeuristics(into) abort
line 592: 
line 593: function! s:Init(redetect, unsafe, do_filetype, silent) abort
line 631: 
line 632: function! s:AutoInit() abort
line 635: 
line 636: function! s:Sleuth(line1, line2, range, bang, mods, args) abort
line 640: 
line 641: if !exists('g:did_indent_on') && !get(g:, 'sleuth_no_filetype_indent_on')
line 642:   filetype indent on
line 643: elseif !exists('g:did_load_filetypes')
line 644:   filetype on
line 645: endif
line 646: 
line 647: function! SleuthIndicator() abort
line 664: 
line 665: augroup sleuth
line 666:   autocmd!
line 667:   autocmd BufNewFile,BufReadPost * nested if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
line 670:   autocmd BufFilePost * nested if (@% !~# '^!' || exists('b:sleuth')) && get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
line 673:   autocmd FileType * nested if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif
line 675:   autocmd User Flags call Hoist('buffer', 5, 'SleuthIndicator')
line 676: augroup END
line 677: 
line 678: command! -bar -bang Sleuth exe s:Sleuth(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim"
line 1: lua << EOF
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSelect lua require'nvim-treesitter.textobjects.select'.commands.TSTextobjectSelect['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoPreviousEnd lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoPreviousEnd['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoPreviousStart lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoPreviousStart['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoNextEnd lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoNextEnd['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoNextStart lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoNextStart['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMoveOpposite lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMoveOpposite['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMove lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMove['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinT lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinT['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltint lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltint['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinF lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinF['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinf lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinf['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMovePrevious lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMovePrevious['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMoveNext lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMoveNext['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSwapNext lua require'nvim-treesitter.textobjects.swap'.commands.TSTextobjectSwapNext['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSwapPrevious lua require'nvim-treesitter.textobjects.swap'.commands.TSTextobjectSwapPrevious['run<bang>'](<f-args>)
line 3: command! -bar -nargs=+ -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectPeekDefinitionCode lua require'nvim-treesitter.textobjects.lsp_interop'.commands.TSTextobjectPeekDefinitionCode['run<bang>'](<f-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim"
line 1: 
line 2: " Create command for running busted
line 3: command! -nargs=1 -complete=file PlenaryBustedFile lua require('plenary.test_harness').test_file([[<args>]])
line 5: 
line 6: command! -nargs=+ -complete=file PlenaryBustedDirectory lua require('plenary.test_harness').test_directory_command([[<args>]])
line 8: 
line 9: nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>
finished sourcing /Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim"
line 1: if exists('g:loaded_devicons') | finish | endif
line 1:  finish | endif
line 1:  endif
line 2: 
line 3: let s:save_cpo = &cpo
line 4: set cpo&vim
line 5: 
line 6: " TODO change so its easier to get
line 7: let g:nvim_web_devicons = 1
line 8: 
line 9: let &cpo = s:save_cpo
line 10: unlet s:save_cpo
line 11: 
line 12: let g:loaded_devicons = 1
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim"
line 1: call llama#init()
Searching for "autoload/llama.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/llama.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/llama.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim"
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim"
line 1: " vim: ts=4 sts=4 expandtab
line 2: " colors (adjust to your liking)
line 3: highlight llama_hl_hint guifg=#ff772f ctermfg=202
line 4: highlight llama_hl_info guifg=#77ff2f ctermfg=119
line 5: 
line 6: " general parameters:
line 7: "
line 8: "   endpoint:         llama.cpp server endpoint
line 9: "   api_key:          llama.cpp server api key (optional)
line 10: "   n_prefix:         number of lines before the cursor location to include in the local prefix
line 11: "   n_suffix:         number of lines after  the cursor location to include in the local suffix
line 12: "   n_predict:        max number of tokens to predict
line 13: "   t_max_prompt_ms:  max alloted time for the prompt processing (TODO: not yet supported)
line 14: "   t_max_predict_ms: max alloted time for the prediction
line 15: "   show_info:        show extra info about the inference (0 - disabled, 1 - statusline, 2 - inline)
line 16: "   auto_fim:         trigger FIM completion automatically on cursor movement
line 17: "   max_line_suffix:  do not auto-trigger FIM completion if there are more than this number of characters to the right of the cursor
line 18: "   max_cache_keys:   max number of cached completions to keep in result_cache
line 19: "
line 20: " ring buffer of chunks, accumulated with time upon:
line 21: "
line 22: "  - completion request
line 23: "  - yank
line 24: "  - entering a buffer
line 25: "  - leaving a buffer
line 26: "  - writing a file
line 27: "
line 28: " parameters for the ring-buffer with extra context:
line 29: "
line 30: "   ring_n_chunks:    max number of chunks to pass as extra context to the server (0 to disable)
line 31: "   ring_chunk_size:  max size of the chunks (in number of lines)
line 32: "                     note: adjust these numbers so that you don't overrun your context
line 33: "                           at ring_n_chunks = 64 and ring_chunk_size = 64 you need ~32k context
line 34: "   ring_scope:       the range around the cursor position (in number of lines) for gathering chunks after FIM
line 35: "   ring_update_ms:   how often to process queued chunks in normal mode
line 36: "
line 37: let s:default_config = { 'endpoint':         'http://127.0.0.1:8012/infill', 'api_key':          '', 'n_prefix':         256, 'n_suffix':         64, 'n_predict':        128, 't_max_prompt_ms':  500, 't_max_predict_ms': 500, 'show_info':        2, 'auto_fim':         v:true, 'max_line_suffix':  8, 'max_cache_keys':   250, 'ring_n_chunks':    16, 'ring_chunk_size':  64, 'ring_scope':       1024, 'ring_update_ms':   1000, }
line 54: 
line 55: let llama_config = get(g:, 'llama_config', s:default_config)
line 56: let g:llama_config = extendnew(s:default_config, llama_config, 'force')
line 57: 
line 58: let g:result_cache = {}
line 59: 
line 60: function! s:get_indent(str)
line 71: 
line 72: function! s:rand(i0, i1) abort
line 75: 
line 76: let s:llama_enabled = v:true
line 77: 
line 78: function! llama#disable()
line 83: 
line 84: function! llama#toggle()
line 92: 
line 93: function llama#setup_commands()
line 98: 
line 99: function! llama#init()
line 183: 
line 184: " compute how similar two chunks of text are
line 185: " 0 - no similarity, 1 - high similarity
line 186: " TODO: figure out something better
line 187: function! s:chunk_sim(c0, c1)
line 204: 
line 205: " pick a random chunk of size g:llama_config.ring_chunk_size from the provided text and queue it for processing
line 206: "
line 207: " no_mod   - do not pick chunks from buffers with pending changes
line 208: " do_evict - evict chunks that are very similar to the new one
line 209: "
line 210: function! s:pick_chunk(text, no_mod, do_evict)
line 291: 
line 292: " picks a queued chunk, sends it for processing and adds it to s:ring_chunks
line 293: " called every g:llama_config.ring_update_ms
line 294: function! s:ring_update()
line 365: 
line 366: " necessary for 'inoremap <expr>'
line 367: function! llama#fim_inline(is_auto, cache) abort
line 371: 
line 372: " the main FIM call
line 373: " takes local context around the cursor and sends it together with the extra context to the server for completion
line 374: function! llama#fim(is_auto, cache) abort
line 568: 
line 569: " if accept_type == 'full', accept entire response
line 570: " if accept_type == 'line', accept only the first line of the response
line 571: " if accept_type == 'word', accept only the first word of the response
line 572: function! llama#fim_accept(accept_type)
line 607: 
line 608: function! llama#fim_cancel()
line 627: 
line 628: function! s:on_move()
line 633: 
line 634: " TODO: Currently the cache uses a random eviction policy. A more clever policy could be implemented (eg. LRU).
line 635: function! s:insert_cache(key, value)
line 646: 
line 647: " callback that processes the FIM result from the server and displays the suggestion
line 648: function! s:fim_on_stdout(hash, cache, pos_x, pos_y, is_auto, job_id, data, event = v:null)
line 894: 
line 895: function! s:fim_on_exit(job_id, exit_code, event = v:null)
finished sourcing /Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim
continuing in /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
calling llama#init()

line 1:     if !executable('curl')
line 2:         echohl WarningMsg
line 3:         echo 'llama.vim requires the "curl" command to be available'
line 4:         echohl None
line 5:         return
line 6:     endif
line 7: 
line 8:     call llama#setup_commands()
calling llama#setup_commands()

line 1:     command! LlamaEnable call llama#init()
line 2:     command! LlamaDisable call llama#disable()
line 3:     command! LlamaToggle call llama#toggle()
llama#setup_commands returning #0

continuing in llama#init

line 9: 
line 10:     let s:pos_x = 0 " cursor position upon start of completion
line 11:     let s:pos_y = 0
line 12: 
line 13:     let s:line_cur = ''
line 14: 
line 15:     let s:line_cur_prefix = ''
line 16:     let s:line_cur_suffix = ''
line 17: 
line 18:     let s:ring_chunks = [] " current set of chunks used as extra context
line 19:     let s:ring_queued = [] " chunks that are queued to be sent for processing
line 20:     let s:ring_n_evict = 0
line 21: 
line 22:     let s:hint_shown = v:false
line 23:     let s:pos_y_pick = -9999 " last y where we picked a chunk
line 24:     let s:pos_dx = 0
line 25:     let s:content = []
line 26:     let s:can_accept = v:false
line 27: 
line 28:     let s:timer_fim = -1
line 29:     let s:t_fim_start = reltime() " used to measure total FIM time
line 30:     let s:t_last_move = reltime() " last time the cursor moved
line 31: 
line 32:     let s:current_job = v:null
line 33:     let s:job_error = 0
line 34: 
line 35:     let s:ghost_text_nvim = exists('*nvim_buf_get_mark')
line 36:     let s:ghost_text_vim = has('textprop')
line 37: 
line 38:     if s:ghost_text_vim
line 39:         if version < 901
line 40:             echom 'Warning: llama.vim requires version 901 or greater. Current version: ' . version
line 41:         endif
line 42:         let s:hlgroup_hint = 'llama_hl_hint'
line 43:         let s:hlgroup_info = 'llama_hl_info'
line 44: 
line 45:         if empty(prop_type_get(s:hlgroup_hint))
line 46:             call prop_type_add(s:hlgroup_hint, {'highlight': s:hlgroup_hint})
line 47:         endif
line 48:         if empty(prop_type_get(s:hlgroup_info))
line 49:             call prop_type_add(s:hlgroup_info, {'highlight': s:hlgroup_info})
line 50:         endif
line 51:     endif
line 52: 
line 53:     augroup llama
line 54:         autocmd!
line 55:         autocmd InsertEnter     * inoremap <expr> <silent> <C-F> llama#fim_inline(v:false, v:false)
line 56:         autocmd InsertLeavePre  * call llama#fim_cancel()
line 57: 
line 58:         autocmd CursorMoved     * call s:on_move()
line 59:         autocmd CursorMovedI    * call s:on_move()
line 60:         autocmd CompleteChanged * call llama#fim_cancel()
line 61: 
line 62:         if g:llama_config.auto_fim
line 63:             autocmd CursorMovedI * call llama#fim(v:true, v:true)
line 64:         endif
line 65: 
line 66:         " gather chunks upon yanking
line 67:         autocmd TextYankPost    * if v:event.operator ==# 'y' | call s:pick_chunk(v:event.regcontents, v:false, v:true) | endif
line 68: 
line 69:         " gather chunks upon entering/leaving a buffer
line 70:         autocmd BufEnter        * call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
line 71:         autocmd BufLeave        * call                      s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)
line 72: 
line 73:         " gather chunk upon saving the file
line 74:         autocmd BufWritePost    * call s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)
line 75:     augroup END
line 76: 
line 77:     silent! call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in llama#init

line 78: 
line 79:     " init background update of the ring buffer
line 80:     if g:llama_config.ring_n_chunks > 0
line 81:         call s:ring_update()
calling <SNR>44_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>44_ring_update returning #0

continuing in llama#init

line 82:     endif
llama#init returning #0

continuing in /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim

finished sourcing /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2025 Feb 28
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.bz3,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo,*.lz4 setlocal bin
line 24: 
line 25:   " Use "gzip -d" and similar commands, gunzip isn't always available.
line 26:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 27:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.bz3 call gzip#read("bzip3 -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.lz4 call gzip#read("lz4 -d -q --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 35:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 36:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 37: 
line 38:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 39:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 40:   autocmd BufWritePost,FileWritePost^I*.bz3 call gzip#write("bzip3")
line 41:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 42:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 43:   autocmd BufWritePost,FileWritePost^I*.lz4  call gzip#write("lz4 -q --rm")
line 44:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 45:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 46:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 47:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 48:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 49: 
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 52:   autocmd FileAppendPre^I^I^I*.bz3 call gzip#appre("bzip3 -d")
line 53:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 54:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 55:   autocmd FileAppendPre^I^I^I*.lz4 call gzip#appre("lz4 -d -q --rm")
line 56:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 57:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 58:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 59:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 60:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 61: 
line 62:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 63:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 64:   autocmd FileAppendPost^I^I*.bz3 call gzip#write("bzip3")
line 65:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 66:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 67:   autocmd FileAppendPost^I^I*.lz4 call gzip#write("lz4 --rm")
line 68:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 69:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 70:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 71:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 72:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 73: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim"
line 1: " Nvim: load the matchit plugin by default.
line 2: if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
line 3:   packadd matchit
Searching for "pack/*/start/matchit" in "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/*/start/matchit"
not found in 'packpath': "pack/*/start/matchit"
Searching for "pack/*/opt/matchit" in "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/*/opt/matchit"
line 3: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim"
line 1: "  matchit.vim: (global plugin) Extended "%" matching
line 2: "  Maintainer:  Christian Brabandt
line 3: "  Version:     1.20
line 4: "  Last Change: 2024 May 20
line 5: "  Repository:  https://github.com/chrisbra/matchit
line 6: "  Previous URL:http://www.vim.org/script.php?script_id=39
line 7: "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
line 8: 
line 9: " Documentation:
line 10: "  The documentation is in a separate file: ../doc/matchit.txt
line 11: 
line 12: " Credits:
line 13: "  Vim editor by Bram Moolenaar (Thanks, Bram!)
line 14: "  Original script and design by Raul Segura Acevedo
line 15: "  Support for comments by Douglas Potts
line 16: "  Support for back references and other improvements by Benji Fisher
line 17: "  Support for many languages by Johannes Zellner
line 18: "  Suggestions for improvement, bug reports, and support for additional
line 19: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
line 20: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
line 21: 
line 22: " Debugging:
line 23: "  If you'd like to try the built-in debugging commands...
line 24: "   :MatchDebug      to activate debugging for the current buffer
line 25: "  This saves the values of several key script variables as buffer-local
line 26: "  variables.  See the MatchDebug() function, below, for details.
line 27: 
line 28: " TODO:  I should think about multi-line patterns for b:match_words.
line 29: "   This would require an option:  how many lines to scan (default 1).
line 30: "   This would be useful for Python, maybe also for *ML.
line 31: " TODO:  Maybe I should add a menu so that people will actually use some of
line 32: "   the features that I have implemented.
line 33: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
line 34: "   Match_wrapper() instead.
line 35: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
line 36: " TODO:  Make backrefs safer by using '\V' (very no-magic).
line 37: " TODO:  Add a level of indirection, so that custom % scripts can use my
line 38: "   work but extend it.
line 39: 
line 40: " Allow user to prevent loading and prevent duplicate loading.
line 41: if exists("g:loaded_matchit") || &cp
line 42:   finish
line 43: endif
line 44: let g:loaded_matchit = 1
line 45: 
line 46: let s:save_cpo = &cpo
line 47: set cpo&vim
line 48: 
line 49: fun MatchEnable()
line 89: 
line 90: fun MatchDisable()
line 108: 
line 109: " Call this function to turn on debugging information.  Every time the main
line 110: " script is run, buffer variables will be saved.  These can be used directly
line 111: " or viewed using the menu items below.
line 112: if !exists(":MatchDebug")
line 113:   command! -nargs=0 MatchDebug call matchit#Match_debug()
line 114: endif
line 115: if !exists(":MatchDisable")
line 116:   command! -nargs=0 MatchDisable :call MatchDisable()
line 117: endif
line 118: if !exists(":MatchEnable")
line 119:   command! -nargs=0 MatchEnable :call MatchEnable()
line 120: endif
line 121: 
line 122: call MatchEnable()
calling MatchEnable()

line 1:   nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
line 2:   nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
line 3:   xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
line 5:   xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
line 6:   onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
line 7:   onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
line 8: 
line 9:   " Analogues of [{ and ]} using matching patterns:
line 10:   nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
line 11:   nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
line 12:   xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
line 13:   xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
line 14:   onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
line 15:   onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
line 16: 
line 17:   " text object:
line 18:   xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
line 19: 
line 20:   if !exists("g:no_plugin_maps")
line 21:     nmap <silent> %  <Plug>(MatchitNormalForward)
line 22:     nmap <silent> g% <Plug>(MatchitNormalBackward)
line 23:     xmap <silent> %  <Plug>(MatchitVisualForward)
line 24:     xmap <silent> g% <Plug>(MatchitVisualBackward)
line 25:     omap <silent> %  <Plug>(MatchitOperationForward)
line 26:     omap <silent> g% <Plug>(MatchitOperationBackward)
line 27: 
line 28:     " Analogues of [{ and ]} using matching patterns:
line 29:     nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
line 30:     nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
line 31:     xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
line 32:     xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
line 33:     omap <silent> [% <Plug>(MatchitOperationMultiBackward)
line 34:     omap <silent> ]% <Plug>(MatchitOperationMultiForward)
line 35: 
line 36:     " Text object
line 37:     xmap a% <Plug>(MatchitVisualTextObject)
line 38:   endif
MatchEnable returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim

line 123: 
line 124: let &cpo = s:save_cpo
line 125: unlet s:save_cpo
line 126: 
line 127: " vim:sts=2:sw=2:et:
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
line 3: augroup filetypedetect
line 3: augroup END
line 4: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2025 Mar 14
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: " - Vim has no support for :defer
line 10: if exists("g:loaded_matchparen") || &cp || exists(":defer") != 2
line 12:   finish
line 13: endif
line 14: let g:loaded_matchparen = 1
line 15: 
line 16: if !exists("g:matchparen_timeout")
line 17:   let g:matchparen_timeout = 300
line 18: endif
line 19: if !exists("g:matchparen_insert_timeout")
line 20:   let g:matchparen_insert_timeout = 60
line 21: endif
line 22: if !exists("g:matchparen_disable_cursor_hl")
line 23:   let g:matchparen_disable_cursor_hl = 0
line 24: endif
line 25: 
line 26: augroup matchparen
line 27:   " Replace all matchparen autocommands
line 28:   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 29:   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
line 30:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 31:   autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 32:   autocmd! TextChangedP * call s:Remove_Matches()
line 33: augroup END
line 34: 
line 35: " Skip the rest if it was already done.
line 36: if exists("*s:Highlight_Matching_Pair")
line 37:   finish
line 38: endif
line 39: 
line 40: let s:cpo_save = &cpo
line 41: set cpo-=C
line 42: 
line 43: " The function that is invoked (very often) to define a ":match" highlighting
line 44: " for any matching paren.
line 45: func s:Highlight_Matching_Pair()
line 202: 
line 203: func s:Remove_Matches()
line 211: 
line 212: " Define commands that will disable and enable the plugin.
line 213: command DoMatchParen call s:DoMatchParen()
line 214: command NoMatchParen call s:NoMatchParen()
line 215: 
line 216: func s:NoMatchParen()
line 223: 
line 224: func s:DoMatchParen()
line 230: 
line 231: let &cpo = s:cpo_save
line 232: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim"
line 1: " Load the netrw package.
line 2: 
line 3: if &cp || exists("g:loaded_netrw") || exists("g:loaded_netrwPlugin")
line 4:   finish
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim"
line 1: if exists('g:loaded_remote_plugins')
line 2:   finish
line 3: endif
line 4: let g:loaded_remote_plugins = '/path/to/manifest'
line 5: 
line 6: " Get the path to the rplugin manifest file.
line 7: function! s:GetManifestPath() abort
line 26: 
line 27: " Old manifest file based on known script locations.
line 28: function! s:GetOldManifestPaths() abort
line 43: 
line 44: function! s:GetManifest() abort
line 57: 
line 58: function! s:LoadRemotePlugins() abort
line 64: 
line 65: command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
line 66: 
line 67: if index(v:argv, "--clean") < 0
line 68:   call s:LoadRemotePlugins()
calling <SNR>74_LoadRemotePlugins()

line 1:   let g:loaded_remote_plugins = s:GetManifest()
calling <SNR>74_GetManifest()

line 1:   let manifest = s:GetManifestPath()
calling <SNR>74_GetManifestPath()

line 1:   let manifest_base = ''
line 2: 
line 3:   if exists('$NVIM_RPLUGIN_MANIFEST')
line 4:     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
line 5:   endif
line 6: 
line 7:   let dest = stdpath('data')
line 8:   if !empty(dest)
line 9:     if !isdirectory(dest)
line 10:       if getftype(dest) != "link"
line 11:         call mkdir(dest, 'p', 0700)
line 12:       endif
line 13:     endif
line 14:     let manifest_base = dest
line 15:   endif
line 16: 
line 17:   return manifest_base.'/rplugin.vim'
<SNR>74_GetManifestPath returning '/Users/joe/.local/share/nvim/rplugin.vim'

continuing in <SNR>74_GetManifest

line 2:   if !filereadable(manifest)
line 3:     " Check if an old manifest file exists and move it to the new location.
line 4:     for old_manifest in s:GetOldManifestPaths()
calling <SNR>74_GetOldManifestPaths()

line 1:   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
line 4:   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
line 6:   if !has('win32')
line 7:     return [origpath]
<SNR>74_GetOldManifestPaths returning ['/Users/joe/.config/nvim/.init.lua-rplugin~']

continuing in <SNR>74_GetManifest

line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 4:     for old_manifest in s:GetOldManifestPaths()
line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 10:   endif
line 11:   return manifest
<SNR>74_GetManifest returning '/Users/joe/.local/share/nvim/rplugin.vim'

continuing in <SNR>74_LoadRemotePlugins

line 2:   if filereadable(g:loaded_remote_plugins)
line 3:     execute 'source' fnameescape(g:loaded_remote_plugins)
line 4:   endif
<SNR>74_LoadRemotePlugins returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim

line 69: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim"
line 1: if exists('g:loaded_shada_plugin')
line 2:   finish
line 3: endif
line 4: let g:loaded_shada_plugin = 1
line 5: 
line 6: augroup ShaDaCommands
line 7:   autocmd!
line 8:   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b'))) |setlocal filetype=shada
line 12:   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
line 15:   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |if writefile(shada#get_binstrings(getline(1, '$')),expand('<afile>'), 'b') == 0 |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))? 0: stridx(&cpoptions, '+') != -1) |endif
line 23:   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'b')
line 30:   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'ab')
line 37:   autocmd SourceCmd *.shada,*.shada.tmp.[a-z] :execute 'rshada' fnameescape(expand('<afile>'))
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: 
line 3: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 4:   finish
line 5: endif
line 6: let loaded_spellfile_plugin = 1
line 7: 
line 8: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: "
line 3: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 4: " Modified by Charles E. Campbell
line 5: " Distributed under the GNU General Public License.
line 6: "
line 7: " Updates are available from <http://michael.toren.net/code/>.  If you
line 8: " find this script useful, or have suggestions for improvements, please
line 9: " let me know.
line 10: " Also look there for further comments and documentation.
line 11: "
line 12: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 13: " ---------------------------------------------------------------------
line 14: "  Load Once: {{{1
line 15: if &cp || exists("g:loaded_tarPlugin")
line 16:  finish
line 17: endif
line 18: let g:loaded_tarPlugin = "v32"
line 19: let s:keepcpo          = &cpo
line 20: set cpo&vim
line 21: 
line 22: " ---------------------------------------------------------------------
line 23: "  Public Interface: {{{1
line 24: augroup tar
line 25:   au!
line 26:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 27:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 28:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 30: 
line 31:   if has("unix")
line 32:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 33:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 34:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 36:   endif
line 37: 
line 38:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.bz3^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tar.lz4^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^I^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 49:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 50:   au BufReadCmd   *.tlz4^I^Icall tar#Browse(expand("<amatch>"))
line 51:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 52:   au BufReadCmd   *.tzst^I^Icall tar#Browse(expand("<amatch>"))
line 53: augroup END
line 54: 
line 55: " ---------------------------------------------------------------------
line 56: " Restoration And Modelines: {{{1
line 57: " vim: fdm=marker
line 58: let &cpo= s:keepcpo
line 59: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim"
line 1: if exists('g:loaded_tutor_mode_plugin') || &compatible
line 2:     finish
line 3: endif
line 4: let g:loaded_tutor_mode_plugin = 1
line 5: 
line 6: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 5: " Former Maintainer:^ICharles E Campbell
line 6: " License:^I^IVim License  (see vim's :help license)
line 7: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 8: "               Permission is hereby granted to use and distribute this code,
line 9: "               with or without modifications, provided that this copyright
line 10: "               notice is copied with it. Like anything else that's free,
line 11: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 12: "               of any kind, either expressed or implied. By using this
line 13: "               plugin, you agree that in no event will the copyright
line 14: "               holder be liable for any damages resulting from the use
line 15: "               of this software.
line 16: "
line 17: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 18: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 19: " ---------------------------------------------------------------------
line 20: " Load Once: {{{1
line 21: if &cp || exists("g:loaded_zipPlugin")
line 22:  finish
line 23: endif
line 24: let g:loaded_zipPlugin = "v33"
line 25: let s:keepcpo          = &cpo
line 26: set cpo&vim
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Options: {{{1
line 30: if !exists("g:zipPlugin_ext")
line 31:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 32: endif
line 33: 
line 34: " ---------------------------------------------------------------------
line 35: " Public Interface: {{{1
line 36: augroup zip
line 37:  au!
line 38:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 39:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 40:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 42: 
line 43:  if has("unix")
line 44:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 45:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 46:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 48:  endif
line 49: 
line 50:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 50: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 51: augroup END
line 52: 
line 53: " ---------------------------------------------------------------------
line 54: "  Restoration And Modelines: {{{1
line 55: "  vim: fdm=marker
line 56: let &cpo= s:keepcpo
line 57: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
Executing User Autocommands for "LazyDone"
autocommand <Lua 76: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:183>

Executing: 
finished sourcing /Users/joe/.config/nvim/init.lua
Searching for "filetype.lua filetype.vim" in runtime path
Searching for "/Users/joe/.config/nvim/filetype.lua"
Searching for "/Users/joe/.config/nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/filetype.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/filetype.lua"
Searching for "/Users/joe/git/joe-p/fetch.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/filetype.vim"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/filetype.lua"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/filetype.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in runtime path
Searching for "/Users/joe/.config/nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/syntax/synload.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/syntax/synload.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim"
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Line continuation is used here, remove 'C' from 'cpoptions'
line 19: let s:cpo_save = &cpo
line 20: set cpo&vim
line 21: 
line 22: " First remove all old syntax autocommands.
line 23: au! Syntax
line 24: 
line 25: au Syntax *^I^Icall s:SynSet()
line 26: 
line 27: fun! s:SynSet()
line 58: 
line 59: 
line 60: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 61: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 66: 
line 67: 
line 68: " Source the user-specified syntax highlighting file
line 69: if exists("mysyntaxfile")
line 70:   let s:fname = expand(mysyntaxfile)
line 71:   if filereadable(s:fname)
line 72:     execute "source " . fnameescape(s:fname)
line 73:   endif
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected
line 32: " unless treesitter highlighting is enabled.
line 33: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 34: augroup syntaxset
line 35:   au! FileType *^Iif !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
line 36: augroup END
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim
Reading ShaDa file "/Users/joe/.local/state/nvim/shada/main.shada" info marks oldfiles
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 239: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1308>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 305: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufWinEnter Autocommands for "*"
autocommand silent! normal! g`"zv

Executing: silent! normal! g`"zv
Executing BufEnter Autocommands for "*"
autocommand <Lua 201: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 238: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1278>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 80: ~/.local/share/nvim/lazy/stickybuf.nvim/lua/stickybuf.lua:237>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 304: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 291: ~/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua:37>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})

Executing: call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
Executing BufEnter Autocommands for "*"
autocommand <Lua 335: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 503: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 69: vim/_defaults.lua:0>

Executing: 
autocommand <Lua 70: vim/_defaults.lua:0>

Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 82: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: source /Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim"
line 1: command! -nargs=* TodoQuickFix lua require("todo-comments.search").setqflist(<q-args>)
line 2: command! -nargs=* TodoLocList lua require("todo-comments.search").setloclist(<q-args>)
line 3: command! -nargs=* TodoTelescope Telescope todo-comments todo <args>
line 4: command! -nargs=* TodoFzfLua lua require("todo-comments.fzf").todo() <args>
line 5: command! -nargs=* TodoTrouble Trouble todo <args>
finished sourcing /Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
continuing in nvim_exec2() called at VimEnter Autocommands for "*":0
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup END
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgTODO guibg=#8cf8f7 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgTODO guibg=NONE guifg=#8cf8f7 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignTODO guibg=NONE guifg=#8cf8f7 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgWARN guibg=#fce094 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgWARN guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignWARN guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgTEST guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgTEST guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignTEST guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgHACK guibg=#fce094 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgHACK guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignHACK guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgPERF guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgPERF guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignPERF guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgNOTE guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgNOTE guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignNOTE guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgFIX guibg=#ffc0b9 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgFIX guibg=NONE guifg=#ffc0b9 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignFIX guibg=NONE guifg=#ffc0b9 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup Todo
line 2:         autocmd!
line 3:         autocmd BufWinEnter,WinNew * lua require("todo-comments.highlight").attach()
line 4:         autocmd WinScrolled * lua require("todo-comments.highlight").highlight_win()
line 5:         autocmd ColorScheme * lua vim.defer_fn(require("todo-comments.config").colors, 10)
line 6:       augroup end
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
Executing: 
Executing VimEnter Autocommands for "*"
autocommand call vimade#Load()

Executing: call vimade#Load()
Searching for "autoload/vimade.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/autoload/vimade.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim"
line 0: sourcing "/Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim"
line 1: let g:vimade_loaded = 1
line 2: function! vimade#Load()
line 5: 
line 6: function! vimade#Empty()
line 8: 
line 9: function! vimade#CreateGlobals()
line 29: 
line 30: function! vimade#SetupRenderer()
line 58: 
line 59: function! vimade#SetupPython()
line 78: 
line 79: function! vimade#SetupPythonFeatures()
line 84: 
line 85: function! vimade#GetFeatures()
line 138: 
line 139: function! vimade#GetDefaults()
line 359: 
line 360: function! vimade#Enable()
line 369: 
line 370: function! vimade#WinEnable()
line 376: 
line 377: function! vimade#WinDisable()
line 381: 
line 382: function! vimade#BufEnable()
line 388: 
line 389: function! vimade#BufDisable()
line 393: 
line 394: function! vimade#Disable()
line 403: 
line 404: function! vimade#UnhighlightAll()
line 410: 
line 411: function! vimade#Toggle()
line 419: 
line 420: function! vimade#Override(name)
line 423: 
line 424: function! vimade#OverrideFolded()
line 427: 
line 428: function! vimade#OverrideSignColumn()
line 431: 
line 432: function! vimade#OverrideLineNr()
line 435: 
line 436: function! vimade#OverrideVertSplit()
line 439: 
line 440: function! vimade#OverrideEndOfBuffer()
line 443: 
line 444: function! vimade#OverrideNonText()
line 447: 
line 448: function! vimade#OverrideAll()
line 456: 
line 457: function! vimade#Pause()
line 460: 
line 461: function! vimade#Unpause()
line 464: 
line 465: function! vimade#FocusGained()
line 474: 
line 475: function! vimade#FocusLost()
line 482: 
line 483: function! vimade#InvalidateSigns()
line 493: 
line 494: function! vimade#Recalculate()
line 499: 
line 500: function! vimade#Redraw()
line 509: 
line 510: function! vimade#GetSigns (bufnr, rows)
line 521: 
line 522: function! vimade#GetInfo()
line 546: 
line 547: function! vimade#FadeLevel(level)
line 551: 
line 552: function! vimade#FadePriority(priority)
line 556: 
line 557: function! vimade#DeferredCheckWindows()
line 569: 
line 570: function! vimade#DeferredTick(num)
line 574: 
line 575: function! vimade#CheckWindows()
line 587: 
line 588: function! vimade#StartAnimationTimer()
line 598: 
line 599: function! vimade#DoAnimations(val)
line 606: 
line 607: function! vimade#softInvalidateBuffer(bufnr)
line 618: 
line 619: function! vimade#UpdateEvents()
line 639: 
line 640: function! vimade#ExtendState()
line 647: 
line 648: function! vimade#GetMaybeFromOverlay(field)
line 655: 
line 656: function! vimade#UpdateState()
line 692: 
line 693: function! vimade#Tick(num)
line 709: 
line 710: function! vimade#FadeActive()
line 716: 
line 717: function! vimade#UnfadeActive()
line 723: 
line 724: function! vimade#GetNvimHi(id)
line 733: 
line 734: function! vimade#GetHi(id)
line 739: 
line 740: function! vimade#GetVisibleRows(startRow, endRow)
line 757: 
line 758: function! vimade#StartTimer()
line 766: function! vimade#StopTimer()
line 772: 
line 773: function! vimade#Init()
line 806: 
line 807: " Variables
line 808: let g:vimade_eval_ret = []
line 809: let g:vimade_active_renderer = 0
line 810: let g:vimade_python_setup = 0
line 811: 
line 812: "Empty Renderer START
line 813: let s:empty_renderer = { 'name': 'empty', 'getInfo': function('vimade#Empty'), 'recalculate': function('vimade#Empty'), 'redraw': function('vimade#Empty'), 'disable': function('vimade#Empty'), 'unhighlightAll': function('vimade#Empty'), 'update': function('vimade#Empty'), 'softInvalidateBuffer': function('vimade#Empty'), 'softInvalidateSigns': function('vimade#Empty'), }
line 824: "Empty Renderer END
line 825: "
line 826: let g:vimade_active_renderer = s:empty_renderer 
line 827: 
line 828: 
line 829: function! s:Recalculate_Lua()
line 832: function! s:Redraw_Lua()
line 835: function! s:Disable_Lua()
line 838: function! s:UnhighlightAll_Lua()
line 841: function! s:Update_Lua()
line 844: function! s:Animate_Lua()
line 847: function! s:SoftInvalidateBuffer_Lua()
line 850: function! s:SoftInvalidateSigns_Lua()
line 853: function! s:GetInfo_Lua()
line 856: let s:lua_renderer = { 'name': 'lua', 'animate': function('s:Animate_Lua'), 'getInfo': function('s:GetInfo_Lua'), 'recalculate': function('s:Recalculate_Lua'), 'redraw': function('s:Redraw_Lua'), 'disable': function('s:Disable_Lua'), 'unhighlightAll': function('s:UnhighlightAll_Lua'), 'update': function('s:Update_Lua'), 'softInvalidateBuffer': function('s:SoftInvalidateBuffer_Lua'), 'softInvalidateSigns': function('s:SoftInvalidateSigns_Lua'), }
line 868: " Lua Renderer END
line 869: 
line 870: " Python Renderer START
line 871: function! s:GetInfo_Python()
line 874: function! s:Recalculate_Python()
line 877: function! s:Redraw_Python()
line 881: function! s:Disable_Python()
line 884: function! s:UnhighlightAll_Python()
line 887: function! s:Update_Python()
line 890: function! s:Animate_Python()
line 893: function! s:SoftInvalidateBuffer_Python()
line 896: function! s:SoftInvalidateSigns_Python()
line 899: let s:python_renderer = { 'name': 'python', 'animate': function('s:Animate_Python'), 'getInfo': function('s:GetInfo_Python'), 'recalculate': function('s:Recalculate_Python'), 'redraw': function('s:Redraw_Python'), 'disable': function('s:Disable_Python'), 'unhighlightAll': function('s:UnhighlightAll_Python'), 'update': function('s:Update_Python'), 'softInvalidateBuffer': function('s:SoftInvalidateBuffer_Python'), 'softInvalidateSigns': function('s:SoftInvalidateSigns_Python'), }
line 911: " Python Renderer END
line 912: 
line 913: call vimade#Init()
calling vimade#Init()

line 1:   let l:already_running = 0
line 2:   if exists('g:vimade_init')
line 3:     let l:already_running = 1
line 4:   endif
line 5:   let g:vimade_init = 1
line 6:   call vimade#CreateGlobals()
calling vimade#CreateGlobals()

line 1:   "let g:vimade_lua_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'lua'
line 2:   "let g:vimade_py_v2_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'python-v2'
line 3: 
line 4:   if !exists('g:vimade_running')
line 5:     ""@setting vimade_running
line 6:     "This flag is used to control whether or not vimade should be running.  This can be useful to toggle vimade during startup.  Alternatively, you may as also use VimadeDisable, VimadeEnable, call vimade#Disable, call vimade#Enable respectively
line 7: 
line 8:     let g:vimade_running = 1
line 9:   endif
line 10:   let g:vimade_paused = 0
line 11:   let g:vimade_error_count = 0
line 12:   let g:vimade_fade_active = 0
line 13:   if !exists('g:vimade')
line 14:     let g:vimade = {}
line 15:   endif
line 16:   if !exists('g:vimade_overlay')
line 17:     let g:vimade_overlay = {}
line 18:   endif
vimade#CreateGlobals returning #0

continuing in vimade#Init

line 7:   call vimade#GetFeatures()
calling vimade#GetFeatures()

line 1:   if !exists('g:vimade_features')
line 2:     let g:vimade_features = {}
line 3:     let g:vimade_features.has_gui_running = has('gui_running')
line 4:     let g:vimade_features.has_gui = has('gui')
line 5:     let g:vimade_features.has_nvim = has('nvim')
line 6:     let g:vimade_features.has_vimr = has('gui_vimr')
line 7:     let g:vimade_features.has_timer_start = exists('*timer_start')
line 8:     let g:vimade_features.has_sign_getplaced = exists('*sign_getplaced')
line 9: 
line 10:     if g:vimade_features.has_nvim
line 11:       " Below are for lua renderer
line 12: 
line 13:       " Required:
line 14:       " Required: nvim_win_set_hl_ns
line 15:       let g:vimade_features.has_nvim_win_set_hl_ns = exists('*nvim_win_set_hl_ns')
line 16:       " Required:
line 17:       " Either (preferred) nvim_get_hl
line 18:       let g:vimade_features.has_nvim_get_hl = exists('*nvim_get_hl')
line 19:       " Or (fallback) nvim__get_hl_defs + nvim_get_hl_by_name (assume supported)
line 20:       let g:vimade_features.has__nvim_get_hl_defs = exists('*nvim__get_hl_defs')
line 21:       
line 22:       "Optional:
line 23:       " preferred but not required nvim_get_hl_ns
line 24:       " fallback is try and manually track (probably will have conflicts with some plugins)
line 25:       let g:vimade_features.has_nvim_get_hl_ns = exists('*nvim_get_hl_ns')
line 26: 
line 27:       let g:vimade_features.supports_lua_renderer = (g:vimade_features.has_nvim_get_hl || g:vimade_features.has__nvim_get_hl_defs) && g:vimade_features.has_nvim_win_set_hl_ns
line 28:       let g:vimade_features.has_wincolor = 0
line 29:       let g:vimade_features.has_gui_version = 0
line 30:     else
line 31:       let g:vimade_features.has_nvim_win_set_hl_ns = 0
line 32:       let g:vimade_features.has_nvim_get_hl = 0
line 33:       let g:vimade_features.has__nvim_get_hl_defs = 0
line 34:       let g:vimade_features.has_nvim_get_hl_ns = 0
line 35:       let g:vimade_features.supports_lua_renderer = 0
line 36:       let g:vimade_features.has_wincolor = exists('&wincolor')
line 37:       let g:vimade_features.has_gui_version = execute('version')=~"GUI version"
line 38:     endif
line 39: 
line 40:     try
line 41:       sign define Vimade_Test text=1
line 42:       sign place 1 group=vimade line=1 name=Vimade_Test priority=100
line 43:       sign unplace 1 group=vimade
line 44:       let g:vimade_features.has_sign_group = 1
line 45:       let g:vimade_features.has_sign_priority = 1
line 46:     catch
line 47:       let g:vimade_features.has_sign_group = 0
line 48:       let g:vimade_features.has_sign_priority = 0
line 49:     endtry
line 50:   endif
line 51:   return g:vimade_features
vimade#GetFeatures returning {'has_sign_getplaced': 1, 'has_gui_run..._set_hl_ns': 1, 'has_sign_priority': 1}

continuing in vimade#Init

line 8:   call vimade#GetDefaults()
calling vimade#GetDefaults()

line 1:   if !exists('g:vimade_defaults')
line 2: 
line 3:     ""The vimade configuration object
line 4:     "@setting vimade
line 5:     
line 6:     let g:vimade_defaults = {'$extended': 1}
line 7: 
line 8:     ""@setting vimade.renderer
line 9:     "Select the renderer to use for vimade window/buffer highlights.
line 10:     "If not specificed, defaults to 'auto'. It is recommended to leave this
line 11:     "option set to 'auto', 'lua', or 'python'.
line 12:     "Current options are:
line 13:     "  - 'auto' - Uses lua renderer if supported on your Neovim version. Otherwise, this option will automatically fallback to 'python'.
line 14:     "  - 'python' - Uses a new high performance renderer compatible with Vim and Neovim
line 15: 
line 16:     let g:vimade_defaults.renderer = 'auto'
line 17: 
line 18:     ""@setting vimade.fadelevel
line 19:     "Supported:     lua, python
line 20:     "Amount of fading applied between text and basebg.  0 will make the text the same color as the background and 1 applies no fading.  The default value is 0.4.  If you are using terminal, you may need to tweak this value to get better results.
line 21: 
line 22:     let g:vimade_defaults.fadelevel = 0.4
line 23:     
line 24:     ""@setting vimade.tint
line 25:     "Supported:     lua, python
line 26:     "Amount and type of tinting to apply. Unset by default.  This param is currently under maintainence. This function can currently be either a config object such as:
line 27:     "{'fg':{'rgb':[255,0,0], 'intensity': 0.5, 'type': 'MIX'}, 'bg':{'rgb':[255,0,0], 'type': 'REPLACE'}, 'sp': {'rgb':[255,0,0], 'type': 'MIX'}}
line 28:     "The fields in the object are completely optional (you can peform a bg-only or fg-only tint)
line 29:     "You can also set g:vimade.tint to a lua or python function that returns the tint object.
line 30:     "Lua
line 31:     "require('vimade').setup({
line 32:     " tint = function (win)
line 33:     "   return {
line 34:     "    fg = {
line 35:     "      rgb={255,0,0},
line 36:     "      intensity = 0.75,
line 37:     "    },
line 38:     "  }
line 39:     " end
line 40:     "})
line 41:     "Python
line 42:     "from vimade.v2 import vimade
line 43:     "vimade.setup({
line 44:     " 'tint': lambda a,test : {'fg':{'rgb':[255,0,0], 'intensity': 0.5}}
line 45:     "})
line 46: 
line 47:     ""@setting vimade.basebg
line 48:     "Supported:     lua, python
line 49:     "basebg can be either be six digit hexidecimal color, rgb array [0-255,0-255,0-255], or cterm code (in terminal).  basebg is used as the color that text is faded against.  You can override this config with another hexidecimal color.  A cool feature of basebg is to use it to change the tint of faded text even if its not your background!
line 50: 
line 51:     let g:vimade_defaults.basebg = ''
line 52: 
line 53:     ""@setting vimade.ncmode
line 54:     "Supported:     lua, python
line 55:     "Whether to fade active windows or buffers.  Options are 'windows' or 'buffers'.  Defaults to 'buffers'.
line 56: 
line 57:     let g:vimade_defaults.ncmode = 'buffers'
line 58: 
line 59:     ""@setting vimade.fadecondition
line 60:     "Supported:     lua, python
line 61:     "TODO docs
line 62: 
line 63:     "Can be set via vim object
line 64:     ""@setting vimade.blocklist
line 65:     "Supported:     lua, python
line 66:     "TODO docs
line 67: 
line 68:     ""@setting vimade.link
line 69:     "Supported:     lua, python
line 70:     "Controls whether or not diffs will fade/unfade together.
line 71:     "TODO docs
line 72: 
line 73: 
line 74:     ""@setting vimade.groupdiff
line 75:     "Supported:     lua, python
line 76:     "Controls whether or not diffs will fade/unfade together.  If you want diffs
line 77:     "to be treated separately, set this value to 0. Default is 1
line 78: 
line 79:     let g:vimade_defaults.groupdiff = 1
line 80: 
line 81:     ""@setting vimade.groupscrollbind
line 82:     "Supported:     lua, python
line 83:     "Controls whether or not scrollbound windows will fade/unfade together.  If
line 84:     "you want scrollbound windows to unfade together, set this to 1.  Default is
line 85:     "0.
line 86:     
line 87:     let g:vimade_defaults.groupscrollbind = 0
line 88: 
line 89:     ""@setting vimade.enablefocusfading
line 90:     "Supported:     lua, python
line 91:     "Fades the current active window on focus blur and unfades when focus gained.
line 92:     "This can be desirable when switching applications or TMUX splits.
line 93:     "* Install 'tmux-plugins/vim-tmux-focus-events' using your preferred plugin manager
line 94:     "* Add `set -g focus-events on` to your tmux.conf
line 95:     "* Neovim should work at this point, If you are using Vim you may also need the following snippet to the very end of your vimrc
line 96:     ">
line 97:     "  if has('gui_running') == 0 && has('nvim') == 0
line 98:     "     call feedkeys(":silent execute '!' | redraw!\<CR>")
line 99:     "  endif
line 100:     "<
line 101: 
line 102:     let g:vimade_defaults.enablefocusfading = 0
line 103:    
line 104:     ""@setting vimade.normalid
line 105:     "Supported:     lua, python
line 106:     "If not specified, the normalid is determined when vimade is first loaded.  normalid provides the id of the "Normal" highlight which is used to calculate fading.  You can override this config with another highlight group.
line 107:     "You shouldn't really ever need to modify this.
line 108: 
line 109:     let g:vimade_defaults.normalid = ''
line 110: 
line 111:     ""@setting vimade.normalncid
line 112:     "Supported:     lua, python
line 113:     "If not specified, the normalncid is determined when vimade is first loaded.  normalncid provides the id of the "NormalNC" highlight which is used to calculate fading for inactive buffers in NVIM.  You can override this config with another highlight group.
line 114:     "You shouldn't really ever need to modify this.
line 115: 
line 116:     let g:vimade_defaults.normalncid = ''
line 117: 
line 118:     ""@setting vimade.checkinterval
line 119:     "Supported:     lua, python
line 120:     "The amount of time in milliseconds that vimade should check the screen for changes.  This config is mainly used to detect resize and scroll changes that occur on inactive windows. Checkinterval does nothing on gvim, if you want to control the refresh time, see 'h updatetime'. Default is 1000.  
line 121: 
line 122:     let g:vimade_defaults.checkinterval = 1000
line 123: 
line 124:     ""@setting vimade.usecursorhold
line 125:     "Supported:     lua, python
line 126:     "Disables the timer running in the background and instead relies `OnCursorHold` and `updatetime` (see h:updatetime).  The default value is `0` except on older Windows GVIM, which defaults to `1` due to the timer breaking movements.  If you find that the timer is causing performance problems or other issues you can disable it by setting this option to `1`. 
line 127: 
line 128:     let g:vimade_defaults.usecursorhold = g:vimade_features.has_gui_running && !g:vimade_features.has_nvim && g:vimade_features.has_gui_version
line 129: 
line 130:     ""@setting vimade.basegroups
line 131:     "Supported:     python
line 132:     "lua uses namespaces and doesn't require this setting.
line 133:     "Neovim only setting that specifies the basegroups/built-in highlight groups that will be faded using winhl when switching windows
line 134: 
line 135:     let g:vimade_defaults.basegroups = ['Folded', 'Search', 'SignColumn', 'CursorLine', 'CursorLineNr', 'DiffAdd', 'DiffChange', 'DiffDelete', 'DiffText', 'FoldColumn', 'Whitespace', 'NonText', 'SpecialKey', 'Conceal', 'EndOfBuffer', 'WinSeparator', 'LineNr', 'LineNrAbove', 'LineNrBelow']
line 136: 
line 137:     ""@setting vimade.enablebasegroups
line 138:     "Supported:     python
line 139:     "lua uses namespaces and doesn't require this setting.
line 140:     "Neovim only setting.  Enabled by default and allows basegroups/built-in highlight fading using winhl.  This allows fading of built-in highlights such as Folded, Search, etc.
line 141: 
line 142:     let g:vimade_defaults.enablebasegroups = 1
line 143: 
line 144: 
line 145:     ""@setting vimade.enabletreesitter
line 146:     "Supported:     python
line 147:     "lua uses namespaces and doesn't require this setting.
line 148:     "Neovim only setting.  Disabled by default and hooks vimade into the internals of treesitter.
line 149: 
line 150:     let g:vimade_defaults.enabletreesitter = 0
line 151: 
line 152:     ""@setting vimade.enablesigns
line 153:     "Supported:     python
line 154:     "lua renderer doesn't require additional logic to fade signs.
line 155:     "Enabled by default for vim/nvim versions that support sign priority and causes signs to be faded when switching buffers.
line 156:     "Only visible signs are faded. This feature can cause performance issues
line 157:     "on older nvim/vim versions that don't support sign priority. 
line 158:     "Use signsretentionperiod to control the duration that vimade checks for sign updates after switching buffers.
line 159: 
line 160:     let g:vimade_defaults.enablesigns = g:vimade_features.has_sign_priority
line 161: 
line 162:     ""@setting vimade.signsid
line 163:     "Supported:     python
line 164:     "lua renderer doesn't require additional logic to fade signs.
line 165:     "The starting id that Vimade should use when creating new signs. By
line 166:     "default Vim requires numeric values to create signs and its possible that
line 167:     "collisions may occur between plugins.  If you need to override this value for
line 168:     "compatibility, please open an issue as well.  Default is 13100.
line 169: 
line 170:     let g:vimade_defaults.signsid = 13100
line 171: 
line 172:     ""@setting vimade.signsretentionperiod
line 173:     "Supported:     python
line 174:     "lua renderer doesn't require additional logic to fade signs.
line 175:     " *python*: Serves no purpose on lua renderer.
line 176:     "Amount of time in milliseconds that faded buffers should be tracked for sign changes.  Default value is 4000.
line 177: 
line 178:     let g:vimade_defaults.signsretentionperiod = 4000
line 179: 
line 180:     ""@setting vimade.signspriority
line 181:     "Supported:     python
line 182:     "lua renderer doesn't require additional logic to fade signs.
line 183:     "Controls the signs fade priority.
line 184:     "You may need to change this value if you find that not all signs are fading properly.
line 185:     "Please also open a defect if you need to tweak this value as Vimade strives to minimize manual configuration where possible.
line 186:     "Default is 31.
line 187: 
line 188:     let g:vimade_defaults.signspriority = 31
line 189: 
line 190:     ""@setting vimade.fademinimap
line 191:     "Supported:     lua, python
line 192:     "Enables fading for `severin-lemaignan/vim-minimap`. Setting vimade.fademinimap to
line 193:     "0 disables the special fade.  Default is 1.
line 194: 
line 195:     let g:vimade_defaults.fademinimap = 1
line 196: 
line 197:     ""@setting vimade.fadepriority
line 198:     "Supported:     python
line 199:     "lua uses namespaces and doesn't require priority settings
line 200:     "Controls the highlighting priority.
line 201:     "You may want to tweak this value to make Vimade play nicely with other highlighting plugins and behaviors.
line 202:     "For example, if you want hlsearch to show results on all buffers, you may want to lower this value to 0.
line 203:     "Default is 10.
line 204: 
line 205:     let g:vimade_defaults.fadepriority = 10
line 206: 
line 207:     ""@setting vimade.disablebatch
line 208:     "Supported:     python
line 209:     "Disables interprocess batching. Useful if you are seeing issues and need to debug an error.
line 210: 
line 211:     let g:vimade_defaults.disablebatch = 0
line 212: 
line 213:     let g:vimade_defaults_keys = keys(g:vimade_defaults)
line 214:     if exists('g:vimade_usecursorhold')
line 215:       let g:vimade.usecursorhold = g:vimade_usecursorhold
line 216:     endif
line 217:   endif
line 218:   return g:vimade_defaults
vimade#GetDefaults returning {'ncmode': 'buffers', 'enablesigns': 1...focusfading': 0, 'checkinterval': 1000}

continuing in vimade#Init

line 9:   call vimade#ExtendState()
calling vimade#ExtendState()

line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
vimade#ExtendState returning #0

continuing in vimade#Init

line 10:   call vimade#UpdateEvents()
calling vimade#UpdateEvents()

line 1:   augroup vimade
line 2:       au!
line 3:       au VimLeave * call vimade#Disable()
line 4:       au FocusGained * call vimade#FocusGained()
line 5:       au FocusLost * call vimade#FocusLost()
line 6:       " TODO neovim is broken in many scenarios in v0.10. Python logic is not
line 7:       " executed properly when called directly off and autoevent. This is
line 8:       " easily reproduceable when using netrw...
line 9:       au WinEnter,BufEnter * call vimade#DeferredCheckWindows()
line 10:       au OptionSet diff call vimade#DeferredCheckWindows()
line 11:       au ColorScheme * call vimade#Redraw()
line 12:       au FileChangedShellPost * call vimade#softInvalidateBuffer(expand("<abuf>"))
line 13:       let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateEvents

line 14:       if usecursorhold
line 15:         au CursorHold,CursorHoldI * call vimade#DeferredCheckWindows()
line 16:         au VimResized * call vimade#DeferredCheckWindows()
line 17:       endif
line 18:   augroup END
vimade#UpdateEvents returning #0

continuing in vimade#Init

line 11: 
line 12:   let g:vimade_last = extend({}, g:vimade)
line 13: 
line 14:   "check immediately
line 15:   if l:already_running == 0
line 16:     call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
line 6:     endif
line 7:     let g:vimade_deferred_timer = timer_start(1, 'vimade#DeferredTick')
line 8:   else
line 9:     return vimade#CheckWindows()
line 10:   endif
vimade#DeferredCheckWindows returning #0

continuing in vimade#Init

line 17:   else
line 18:     call vimade#Redraw()
line 19:   endif
line 20:   call vimade#StartTimer()
calling vimade#StartTimer()

line 1:   "timer is disabled when usecursorhold=1
line 2:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#StartTimer

line 3:   if !usecursorhold && !exists('g:vimade_timer') && g:vimade_running
line 4:     let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#StartTimer

line 5:     let g:vimade_timer = timer_start(checkinterval, 'vimade#Tick', {'repeat': -1})
line 6:   endif
vimade#StartTimer returning #0

continuing in vimade#Init

line 21: 
line 22:   "run the timer once during startup
line 23:   "we use try here to possibly support vim 7
line 24:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#Init

line 25:   if usecursorhold
line 26:     let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
line 27:     try
line 28:       call timer_start(checkinterval, 'vimade#Tick')
line 29:     catch
line 30:     endtry
line 31:   endif
vimade#Init returning #0

continuing in /Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim

finished sourcing /Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim
continuing in VimEnter Autocommands for "*"
calling vimade#Load()

line 1:   " empty hook to initiate loading
vimade#Load returning #0

continuing in VimEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand <Lua 265: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:381>

Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: silent %bw!
Executing BufDelete Autocommands for "*"
autocommand <Lua 511: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:226>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 244: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1373>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 303: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 238: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1278>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 80: ~/.local/share/nvim/lazy/stickybuf.nvim/lua/stickybuf.lua:237>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 304: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 291: ~/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua:37>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})

Executing: call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
Executing BufEnter Autocommands for "*"
autocommand <Lua 335: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 503: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call vimade#DeferredCheckWindows()

Executing: call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
vimade#DeferredCheckWindows returning #0

continuing in BufEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand <Lua 239: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1308>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 305: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufWinEnter Autocommands for "*"
autocommand silent! normal! g`"zv

Executing: silent! normal! g`"zv
Executing BufWinEnter Autocommands for "*"
autocommand lua require("todo-comments.highlight").attach()

Executing: lua require("todo-comments.highlight").attach()
line 1: unlet! b:keymap_name
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: silent clearjumps
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: silent source /Users/joe/.local/share/nvim/sessions/\%2FUsers\%2Fjoe\%2Fgit\%2Fjoe-p\%2Ffetch\%2Envim.vim
line 1: sourcing "/Users/joe/.local/share/nvim/sessions/%2FUsers%2Fjoe%2Fgit%2Fjoe-p%2Ffetch%2Envim.vim"
line 1: let SessionLoad = 1
line 2: let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
line 2:  let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
line 2:  setg so=0 siso=0 | setl so=-1 siso=-1
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 2:  setl so=-1 siso=-1
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 3: let v:this_session=expand("<sfile>:p")
line 4: silent only
line 5: silent tabonly
Already only one tab page
line 6: cd ~/git/joe-p/fetch.nvim
[global] /Users/joe/git/joe-p/fetch.nvim
line 7: if expand('%') == '' && !&modified && line('$') <= 1 && getline(1) == ''
line 8:   let s:wipebuf = bufnr('%')
line 9: endif
line 10: let s:shortmess_save = &shortmess
line 11: if &shortmess =~ 'A'
line 12:   set shortmess=aoOA
line 13: else
line 14:   set shortmess=aoO
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 15: endif
line 16: badd +1 out.log
Executing BufAdd Autocommands for "*"
autocommand <Lua 244: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1373>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 303: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
line 17: argglobal
line 18: %argdel
line 19: edit out.log
Executing BufLeave Autocommands for "*"
autocommand <Lua 237: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1264>

Executing: 
Executing BufLeave Autocommands for "*"
autocommand call                      s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)

Executing: call                      s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)
calling <SNR>44_pick_chunk([''], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
<SNR>44_pick_chunk returning #0

continuing in BufLeave Autocommands for "*"

Executing BufLeave Autocommands for "*"
autocommand <Lua 512: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing BufLeave Autocommands for "*"
autocommand call s:Remove_Matches()

Executing: call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in BufLeave Autocommands for "*"

Executing BufReadPre Autocommands for "*"
autocommand <Lua 95: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at BufReadPre Autocommands for "*":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at BufReadPre Autocommands for "*":0
continuing in BufReadPre Autocommands for "*"
line 0: sourcing "nvim_exec2() called at BufReadPre Autocommands for "*":0"
line 1: augroup END
finished sourcing nvim_exec2() called at BufReadPre Autocommands for "*":0
continuing in BufReadPre Autocommands for "*"
Executing: 
Executing BufReadPre Autocommands for "*"
autocommand <Lua 198: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
"out.log" [noeol] 2986L, 159744B
Reading ShaDa file "/Users/joe/.local/state/nvim/shada/main.shada" marks
Reading undo file: /Users/joe/.local/state/nvim/undo/%Users%joe%git%joe-p%fetch.nvim%out.log
Executing BufReadPost Autocommands for "*"
autocommand <Lua 188: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:10>

Executing: 
autocommand if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif

Executing: if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif
Executing:  runtime! scripts.vim | endif
Searching for "scripts.vim" in runtime path
Searching for "/Users/joe/.config/nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/scripts.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/scripts.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/scripts.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/scripts.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/scripts.vim"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/scripts.vim"
not found in runtime path: "scripts.vim"
Executing:  endif
Executing BufReadPost Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif

Executing: if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
Executing:  exe s:AutoInit() | endif
calling <SNR>27_AutoInit()

line 1:   return s:Init(1, 1, 1, 1)
calling <SNR>27_Init(1, 1, 1, 1)

line 1:   if !a:redetect && exists('b:sleuth.defaults')
line 2:     let detected = b:sleuth
line 3:   endif
line 4:   unlet! b:sleuth
line 5:   if &l:buftype !~# '^\%(nowrite\|nofile\|acwrite\)\=$'
line 6:     return s:Warn(':Sleuth disabled for buftype=' . &l:buftype, a:silent)
line 7:   endif
line 8:   if &l:filetype ==# 'netrw'
line 9:     return s:Warn(':Sleuth disabled for filetype=' . &l:filetype, a:silent)
line 10:   endif
line 11:   if &l:binary
line 12:     return s:Warn(':Sleuth disabled for binary files', a:silent)
line 13:   endif
line 14:   if !exists('detected')
line 15:     let detected = s:DetectDeclared()
calling <SNR>27_DetectDeclared()

line 1:   let detected = {'bufname': s:Slash(@%), 'declared': {}}
calling <SNR>27_Slash('out.log')

line 1:     return a:path
<SNR>27_Slash returning 'out.log'

continuing in <SNR>27_DetectDeclared

line 2:   let absolute_or_empty = detected.bufname =~# '^$\|^\a\+:\|^/'
line 3:   if &l:buftype =~# '^\%(nowrite\)\=$' && !absolute_or_empty
line 4:     let detected.bufname = substitute(s:Slash(getcwd()), '/\=$', '/', '') . detected.bufname
calling <SNR>27_Slash('/Users/joe/git/joe-p/fetch.nvim')

line 1:     return a:path
<SNR>27_Slash returning '/Users/joe/git/joe-p/fetch.nvim'

continuing in <SNR>27_DetectDeclared

line 5:     let absolute_or_empty = 1
line 6:   endif
line 7:   let detected.path = absolute_or_empty ? detected.bufname : ''
line 8:   let pre = substitute(matchstr(detected.path, '^\a\a\+\ze:'), '^\a', '\u&', 'g')
line 9:   if len(pre) && exists('*' . pre . 'Real')
line 10:     let detected.path = s:Slash(call(pre . 'Real', [detected.path]))
line 11:   endif
line 12: 
line 13:   try
line 14:     if len(detected.path) && exists('*ExcludeBufferFromDiscovery') && !empty(ExcludeBufferFromDiscovery(detected.path, 'sleuth'))
line 15:       let detected.path = ''
line 16:     endif
line 17:   catch
line 18:   endtry
line 19:   let [detected.editorconfig, detected.root] = s:DetectEditorConfig(detected.path)
calling <SNR>27_DetectEditorConfig('/Users/joe/git/joe-p/fetch.nvim/out.log')

line 1:   if empty(a:absolute_path)
line 2:     return [{}, '']
line 3:   endif
line 4:   let root = ''
line 5:   let tail = a:0 ? a:1 : '.editorconfig'
line 6:   let dir = fnamemodify(a:absolute_path, ':h')
line 7:   let previous_dir = ''
line 8:   let sections = []
line 9:   let overrides = get(g:, 'sleuth_editorconfig_overrides', {})
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 34: 
line 35:   let config = {}
line 36:   for [pattern, pairs] in sections
line 37:     if a:absolute_path =~# pattern
line 38:       call extend(config, pairs)
line 39:     endif
line 40:   endfor
line 41: 
line 42:   return [config, root]
<SNR>27_DetectEditorConfig returning [{}, '']

continuing in <SNR>27_DetectDeclared

line 20:   call extend(detected.declared, s:EditorConfigToOptions(detected.editorconfig))
calling <SNR>27_EditorConfigToOptions({})

line 1:   let options = {}
line 2:   let pairs = map(copy(a:pairs), 'v:val[0]')
line 3:   let sources = map(copy(a:pairs), 'v:val[1:-1]')
line 4:   call filter(pairs, 'v:val !=? "unset"')
line 5: 
line 6:   if get(pairs, 'indent_style', '') ==? 'tab'
line 7:     let options.expandtab = [0] + sources.indent_style
line 8:   elseif get(pairs, 'indent_style', '') ==? 'space'
line 9:     let options.expandtab = [1] + sources.indent_style
line 10:   endif
line 11: 
line 12:   if get(pairs, 'indent_size', '') =~? '^[1-9]\d*$\|^tab$'
line 13:     let options.shiftwidth = [str2nr(pairs.indent_size)] + sources.indent_size
line 14:     if &g:shiftwidth == 0 && !has_key(pairs, 'tab_width') && pairs.indent_size !=? 'tab'
line 15:       let options.tabstop = options.shiftwidth
line 16:       let options.shiftwidth = [0] + sources.indent_size
line 17:     endif
line 18:   endif
line 19: 
line 20:   if get(pairs, 'tab_width', '') =~? '^[1-9]\d*$'
line 21:     let options.tabstop = [str2nr(pairs.tab_width)] + sources.tab_width
line 22:     if !has_key(pairs, 'indent_size') && get(pairs, 'indent_style', '') ==? 'tab'
line 23:       let options.shiftwidth = [0] + options.tabstop[1:-1]
line 24:     endif
line 25:   endif
line 26: 
line 27:   if get(pairs, 'max_line_length', '') =~? '^[1-9]\d*$\|^off$'
line 28:     let options.textwidth = [str2nr(pairs.max_line_length)] + sources.max_line_length
line 29:   endif
line 30: 
line 31:   if get(pairs, 'insert_final_newline', '') =~? '^true$\|^false$'
line 32:     let options.endofline = [pairs.insert_final_newline ==? 'true'] + sources.insert_final_newline
line 33:     let options.fixendofline = copy(options.endofline)
line 34:   endif
line 35: 
line 36:   let eol = tolower(get(pairs, 'end_of_line', ''))
line 37:   if has_key(s:editorconfig_fileformat, eol)
line 38:     let options.fileformat = [s:editorconfig_fileformat[eol]] + sources.end_of_line
line 39:   endif
line 40: 
line 41:   let charset = tolower(get(pairs, 'charset', ''))
line 42:   if has_key(s:editorconfig_bomb, charset)
line 43:     let options.bomb = [s:editorconfig_bomb[charset]] + sources.charset
line 44:     let options.fileencoding = [substitute(charset, '\C-bom$', '', '')] + sources.charset
line 45:   endif
line 46: 
line 47:   let filetype = tolower(get(pairs, 'vim_filetype', 'unset'))
line 48:   if filetype !=# 'unset' && filetype =~# '^[.a-z0-9_-]*$'
line 49:     let options.filetype = [substitute(filetype, '^\.\+\|\.\+$', '', 'g')] + sources.vim_filetype
line 50:   endif
line 51: 
line 52:   return options
<SNR>27_EditorConfigToOptions returning {}

continuing in <SNR>27_DetectDeclared

line 21:   call extend(detected.declared, s:ModelineOptions())
calling <SNR>27_ModelineOptions()

line 1:   let options = {}
line 2:   if !&l:modeline && (&g:modeline || s:Capture('setlocal') =~# '\\\@<![[:space:]]nomodeline\>' && s:Capture('verbose setglobal modeline?') !=# s:Capture('verbose setlocal modeline?'))
line 4:     return options
line 5:   endif
line 6:   let modelines = get(b:, 'sleuth_modelines', get(g:, 'sleuth_modelines', 5))
line 7:   if line('$') > 2 * modelines
line 8:     let lnums = range(1, modelines) + range(line('$') - modelines + 1, line('$'))
line 9:   else
line 10:     let lnums = range(1, line('$'))
line 11:   endif
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 1)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 2)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 3)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 4)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 5)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 2982)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 2983)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 2984)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 2985)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>27_ParseOptions([], {}, 'modeline', 2986)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>27_ParseOptions returning #0

continuing in <SNR>27_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
line 16:       break
line 17:     endif
line 18:   endfor
line 19:   return options
<SNR>27_ModelineOptions returning {}

continuing in <SNR>27_DetectDeclared

line 22:   return detected
<SNR>27_DetectDeclared returning {'root': '', 'path': '/Users/joe/git/j...g', 'declared': {}, 'editorconfig': {}}

continuing in <SNR>27_Init

line 16:   endif
line 17:   let setfiletype = ''
line 18:   if a:do_filetype && has_key(detected.declared, 'filetype')
line 19:     let filetype = detected.declared.filetype[0]
line 20:     if filetype !=# &l:filetype || empty(filetype)
line 21:       let setfiletype = 'setlocal filetype=' . filetype
line 22:     else
line 23:       let setfiletype = 'setfiletype ' . filetype
line 24:     endif
line 25:   endif
line 26:   exe setfiletype
line 26: 
line 27:   call s:DetectHeuristics(detected)
calling <SNR>27_DetectHeuristics({'root': '', 'path': '/Users/joe/git/j...g', 'declared': {}, 'editorconfig': {}})

line 1:   let detected = a:into
line 2:   let filetype = split(&l:filetype, '\.', 1)[0]
line 3:   if get(detected, 'filetype', '*') ==# filetype
line 4:     return detected
line 5:   endif
line 6:   let detected.filetype = filetype
line 7:   let options = copy(detected.declared)
line 8:   let detected.options = options
line 9:   let detected.heuristics = {}
line 10:   if has_key(detected, 'patterns')
line 11:     call remove(detected, 'patterns')
line 12:   endif
line 13:   let detected.defaults = s:UserOptions(filetype, 'defaults')
calling <SNR>27_UserOptions('', 'defaults')

line 1:   if exists('b:sleuth_' . a:name)
line 2:     let source = 'b:sleuth_' . a:name
line 3:   elseif exists('g:sleuth_' . a:ft . '_' . a:name)
line 4:     let source = 'g:sleuth_' . a:ft . '_' . a:name
line 5:   endif
line 6:   if !exists('l:source') || type(eval(source)) == type(function('tr'))
line 7:     return {}
<SNR>27_UserOptions returning {}

continuing in <SNR>27_DetectHeuristics

line 14:   if empty(filetype) || !get(b:, 'sleuth_automatic', 1) || empty(get(b:, 'sleuth_heuristics', get(g:, 'sleuth_' . filetype . '_heuristics', get(g:, 'sleuth_heuristics', 1))))
line 15:     return detected
<SNR>27_DetectHeuristics returning {'root': '', 'options': {}, 'defaults'...{}, 'editorconfig': {}, 'filetype': ''}

continuing in <SNR>27_Init

line 28:   let cmd = s:Apply(detected, (a:do_filetype ? ['filetype'] : []) + (a:unsafe ? s:all_options : s:safe_options), a:silent)
calling <SNR>27_Apply({'root': '', 'options': {}, 'defaults'...{}, 'editorconfig': {}, 'filetype': ''}, ['filetype', 'expandtab', 'shiftwidth'..., 'fileformat', 'fileencoding', 'bomb'], 1)

line 1:   let options = extend(copy(a:detected.defaults), a:detected.options)
line 2:   if get(a:detected.defaults, 'shiftwidth', [1])[0] == 0 && get(options, 'shiftwidth', [0])[0] != 0 && !has_key(a:detected.declared, 'tabstop')
line 3:     let options.tabstop = options.shiftwidth
line 4:     let options.shiftwidth = a:detected.defaults.shiftwidth
line 5:   endif
line 6:   if has_key(options, 'shiftwidth') && !has_key(options, 'expandtab')
line 7:     let options.expandtab = [stridx(join(getline(1, 256), "\n"), "\t") == -1, a:detected.bufname]
line 8:   endif
line 9:   if !exists('*shiftwidth') && !get(options, 'shiftwidth', [1])[0]
line 10:     let options.shiftwidth = [get(options, 'tabstop', [&tabstop])[0]] + options.shiftwidth[1:-1]
line 11:   endif
line 12:   let msg = ''
line 13:   let cmd = 'setlocal'
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 18:     endif
line 19:     let value = options[option]
line 20:     if has_key(s:booleans, option)
line 21:       let setting = (value[0] ? '' : 'no') . option
line 22:     else
line 23:       let setting = option . '=' . value[0]
line 24:     endif
line 25:     if getbufvar('', '&' . option) !=# value[0] || index(s:safe_options, option) >= 0
line 26:       let cmd .= ' ' . setting
line 27:     endif
line 28:     if !&verbose || a:silent
line 29:       if has_key(s:booleans, option)
line 30:         let msg .= ' ' . (value[0] ? '' : 'no') . get(s:short_options, option, option)
line 31:       else
line 32:         let msg .= ' ' . get(s:short_options, option, option) . '=' . value[0]
line 33:       endif
line 34:       continue
line 35:     endif
line 36:     if len(value) > 1
line 37:       if value[1] ==# a:detected.bufname
line 38:         let file = '%'
line 39:       else
line 40:         let file = value[1] =~# '/' ? fnamemodify(value[1], ':~:.') : value[1]
line 41:         if file !=# value[1] && file[0:0] !=# '~'
line 42:           let file = './' . file
line 43:         endif
line 44:       endif
line 45:       if len(value) > 2
line 46:         let file .= ' line ' . value[2]
line 47:       endif
line 48:       echo printf(':setlocal %-21s " from %s', setting, file)
line 49:     else
line 50:       echo ':setlocal ' . setting
line 51:     endif
line 52:   endfor
line 53:   if !&verbose && !empty(msg) && !a:silent
line 54:     echo ':setlocal' . msg
line 55:   endif
line 56:   if has_key(options, 'shiftwidth')
line 57:     let cmd .= ' softtabstop=' . (exists('*shiftwidth') ? -1 : options.shiftwidth[0])
line 58:   else
line 59:     call s:Warn(':Sleuth failed to detect indent settings', a:silent)
calling <SNR>27_Warn(':Sleuth failed to detect indent settings', 1)

line 1:   if !get(a:000, 0, 0)
line 2:     echohl WarningMsg
line 3:     echo a:msg
line 4:     echohl NONE
line 5:   endif
line 6:   return ''
<SNR>27_Warn returning ''

continuing in <SNR>27_Apply

line 60:   endif
line 61:   return cmd ==# 'setlocal' ? '' : cmd
<SNR>27_Apply returning ''

continuing in <SNR>27_Init

line 29:   let b:sleuth = detected
line 30:   if exists('s:polyglot') && !a:silent
line 31:     call s:Warn('Charlatan :Sleuth implementation in vim-polyglot has been found and disabled.')
line 32:     call s:Warn('To get rid of this message, uninstall vim-polyglot, or disable the')
line 33:     call s:Warn('corresponding feature in your vimrc:')
line 34:     call s:Warn('        let g:polyglot_disabled = ["autoindent"]')
line 35:   endif
line 36:   return cmd
<SNR>27_Init returning ''

continuing in <SNR>27_AutoInit

<SNR>27_AutoInit returning ''

continuing in BufReadPost Autocommands for "*"

Executing: 
Executing:  endif
Executing BufReadPost Autocommands for "*"
autocommand <Lua 334: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:136>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 352: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns.lua:143>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 510: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:222>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 529: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua:4>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 238: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1278>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 80: ~/.local/share/nvim/lazy/stickybuf.nvim/lua/stickybuf.lua:237>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 304: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 291: ~/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua:37>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})

Executing: call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
Executing BufEnter Autocommands for "*"
autocommand <Lua 335: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 503: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call vimade#DeferredCheckWindows()

Executing: call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
vimade#DeferredCheckWindows returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand <Lua 288: ~/.config/nvim/lua/kickstart/plugins/lint.lua:52>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 500: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 239: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1308>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 305: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufWinEnter Autocommands for "*"
autocommand silent! normal! g`"zv

Executing: silent! normal! g`"zv
Executing BufWinEnter Autocommands for "*"
autocommand lua require("todo-comments.highlight").attach()

Executing: lua require("todo-comments.highlight").attach()
line 19: unlet! b:keymap_name
line 20: wincmd t
line 21: let s:save_winminheight = &winminheight
line 22: let s:save_winminwidth = &winminwidth
line 23: set winminheight=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 24: set winheight=1
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 25: set winminwidth=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 26: set winwidth=1
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 27: argglobal
line 28: setlocal keymap=
line 28: unlet! b:keymap_name
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 29: setlocal noarabic
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 30: setlocal autoindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 31: setlocal nobinary
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 32: setlocal breakindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 33: setlocal breakindentopt=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 34: setlocal bufhidden=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 35: setlocal buflisted
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 36: setlocal buftype=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 37: setlocal nocindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 38: setlocal cinkeys=0{,0},0),0],:,0#,!^F,o,O,e
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 39: setlocal cinoptions=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 40: setlocal cinscopedecls=public,protected,private
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 41: setlocal cinwords=if,else,while,do,for,switch
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 42: setlocal colorcolumn=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 43: setlocal comments=s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-,fb:^V<e2>^V<80>^V<a2>
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 44: setlocal commentstring=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 45: setlocal complete=.,w,b,u,t
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 46: setlocal completefunc=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 47: setlocal completeslash=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 48: setlocal concealcursor=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 49: setlocal conceallevel=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 50: setlocal nocopyindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 51: setlocal nocursorbind
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 52: setlocal nocursorcolumn
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 53: setlocal cursorline
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 54: setlocal cursorlineopt=both
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 55: setlocal nodiff
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "diff"
autocommand call vimade#DeferredCheckWindows()

Executing: call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
vimade#DeferredCheckWindows returning #0

continuing in OptionSet Autocommands for "diff"

line 56: setlocal eventignorewin=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 57: setlocal noexpandtab
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 58: if &filetype != ''
line 59: setlocal filetype=
line 60: endif
line 61: setlocal fixendofline
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 62: setlocal foldcolumn=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 63: setlocal foldenable
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 64: setlocal foldexpr=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 65: setlocal foldignore=#
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 66: setlocal foldlevel=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 67: setlocal foldmarker={{{,}}}
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 68: setlocal foldmethod=manual
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 69: setlocal foldminlines=1
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 70: setlocal foldnestmax=20
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 71: setlocal foldtext=foldtext()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 72: setlocal formatexpr=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 73: setlocal formatlistpat=^\\s*\\d\\+[\\]:.)}\\t\ ]\\s*
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 74: setlocal formatoptions=tcqj
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 75: setlocal iminsert=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 76: setlocal imsearch=-1
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 77: setlocal includeexpr=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 78: setlocal indentexpr=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 79: setlocal indentkeys=0{,0},0),0],:,0#,!^F,o,O,e
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 80: setlocal noinfercase
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 81: setlocal iskeyword=@,48-57,_,192-255
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 82: setlocal nolinebreak
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 83: setlocal nolisp
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 84: setlocal lispoptions=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 85: setlocal list
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 86: setlocal matchpairs=(:),{:},[:]
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 87: setlocal modeline
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 88: setlocal modifiable
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 89: setlocal nrformats=bin,hex
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 90: setlocal number
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 91: setlocal numberwidth=4
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 92: setlocal omnifunc=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 93: setlocal nopreserveindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 94: setlocal nopreviewwindow
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 95: setlocal quoteescape=\\
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 96: setlocal noreadonly
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 97: setlocal norelativenumber
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 98: setlocal norightleft
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 99: setlocal rightleftcmd=search
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 100: setlocal scrollback=-1
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 101: setlocal noscrollbind
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 102: setlocal shiftwidth=8
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 103: setlocal signcolumn=yes
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 104: setlocal nosmartindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 105: setlocal nosmoothscroll
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 106: setlocal softtabstop=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 107: setlocal nospell
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 108: setlocal spellcapcheck=[.?!]\\_[\\])'\"\\t\ ]\\+
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 109: setlocal spellfile=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 110: setlocal spelllang=en
Searching for "spell/en.*" in runtime path
Searching for "/Users/joe/.config/nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/spell/en.*"
Searching for "/Users/joe/git/joe-p/fetch.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/spell/en.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/spell/en.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/spell/en.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/spell/en.*"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/spell/en.*"
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 111: setlocal spelloptions=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 112: setlocal statuscolumn=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 113: setlocal suffixesadd=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 114: setlocal swapfile
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 115: setlocal synmaxcol=3000
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 116: if &syntax != ''
line 117: setlocal syntax=
line 118: endif
line 119: setlocal tabstop=8
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 120: setlocal tagfunc=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 121: setlocal textwidth=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 122: setlocal undofile
Reading undo file: /Users/joe/.local/state/nvim/undo/%Users%joe%git%joe-p%fetch.nvim%out.log
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 123: setlocal varsofttabstop=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 124: setlocal vartabstop=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 125: setlocal winblend=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 126: setlocal nowinfixbuf
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 127: setlocal nowinfixheight
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 128: setlocal nowinfixwidth
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 129: setlocal winhighlight=
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 130: setlocal wrap
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 131: setlocal wrapmargin=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 132: silent! normal! zE
line 133: let &fdl = &fdl
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 134: let s:l = 1 - ((0 * winheight(0) + 32) / 64)
line 135: if s:l < 1 | let s:l = 1 | endif
line 135:  let s:l = 1 | endif
line 135:  endif
line 136: keepjumps exe s:l
line 136: 1
line 137: normal! zt
line 138: keepjumps 1
line 139: normal! 0
line 140: tabnext 1
line 141: if exists('s:wipebuf') && len(win_findbuf(s:wipebuf)) == 0 && getbufvar(s:wipebuf, '&buftype') isnot# 'terminal'
line 142:   silent exe 'bwipe ' . s:wipebuf
line 142: bwipe 1
Executing BufDelete Autocommands for "*"
autocommand <Lua 511: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:226>

Executing: 
Executing BufDelete Autocommands for "*"
autocommand <Lua 374: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufDelete Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 376: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
line 143: endif
line 144: unlet! s:wipebuf
line 145: set winheight=1 winwidth=20
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 146: let &shortmess = s:shortmess_save
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 147: let &winminheight = s:save_winminheight
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 148: let &winminwidth = s:save_winminwidth
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 149: let s:sx = expand("<sfile>:p:r")."x.vim"
line 150: if filereadable(s:sx)
line 151:   exe "source " . fnameescape(s:sx)
line 152: endif
line 153: let &g:so = s:so_save | let &g:siso = s:siso_save
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 153:  let &g:siso = s:siso_save
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 154: set hlsearch
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
line 155: nohlsearch
line 156: doautoall SessionLoadPost
Executing SessionLoadPost Autocommands for "*"
autocommand <Lua 245: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1383>

Executing: 
Executing SessionLoadPost Autocommands for "*"
autocommand <Lua 216: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline/groups.lua:244>

Executing: 
Executing SessionLoadPost Autocommands for "*"
autocommand <Lua 333: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:121>

Executing: 
line 157: unlet SessionLoad
line 158: " vim: set ft=vim :
finished sourcing /Users/joe/.local/share/nvim/sessions/%2FUsers%2Fjoe%2Fgit%2Fjoe-p%2Ffetch%2Envim.vim
continuing in nvim_exec2() called at VimEnter Autocommands for "*":0
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 342: vim/_editor.lua:0>

Executing: 
autocommand <Lua 378: ~/.local/share/nvim/lazy/mason-tool-installer.nvim/lua/mason-tool-installer/init.lua:267>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 74: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:327>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 197: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 534: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua:8>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 294: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:189>

Executing: 
Executing SafeState Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

sourcing "nvim_exec2()"
line 1: autocmd User CocDiagnosticChange lua require('bufferline.diagnostics').refresh_coc_diagnostics()
finished sourcing nvim_exec2()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 68: vim/_defaults.lua:0>

Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 564: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 562: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/termcap.lua:36>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 564: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
Executing ColorSchemePre Autocommands for "*"
autocommand <Lua 77: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/loader.lua:31>

Executing: 
Searching for "colors/catppuccin.*" in runtime path
Searching for "/Users/joe/.config/nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/colors/catppuccin.*"
Searching for "/Users/joe/git/joe-p/fetch.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.*"
sourcing "/Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim"
line 1: lua require("catppuccin").load()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 564: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
finished sourcing /Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim
Executing ColorScheme Autocommands for "*"
autocommand <Lua 202: ~/.local/share/nvim/lazy/mini.icons/lua/mini/icons.lua:1998>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 228: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:947>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 316: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:587>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 332: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:111>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 350: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/highlight.lua:275>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 492: ~/.local/share/nvim/lazy/mini.nvim/lua/mini/surround.lua:1229>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 496: ~/.local/share/nvim/lazy/mini.nvim/lua/mini/statusline.lua:538>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand lua vim.defer_fn(require("todo-comments.config").colors, 10)

Executing: lua vim.defer_fn(require("todo-comments.config").colors, 10)
Executing ColorScheme Autocommands for "*"
autocommand call vimade#Redraw()

Executing: call vimade#Redraw()
calling vimade#Redraw()

line 1:   "prevent if inside popup window
line 2:   if winnr() == 0
line 3:     return
line 4:   endif
line 5:   if g:vimade_running && g:vimade_paused == 0
line 6:     call g:vimade_active_renderer.redraw()
calling vimade#Empty()

vimade#Empty returning #0

continuing in vimade#Redraw

line 7:   endif
vimade#Redraw returning #0

continuing in ColorScheme Autocommands for "*"

Executing ColorScheme Autocommands for "*"
autocommand <Lua 330: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/util/init.lua:19>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 392: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:510>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 565: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:152>

Executing: 
calling vimade#DeferredTick(3)

line 1:   unlet g:vimade_deferred_timer
line 2:   call vimade#Tick(0)
calling vimade#Tick(0)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning ''

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning ''

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
calling vimade#UnhighlightAll()

line 1:   if winnr() == 0
line 2:     return
line 3:   endif
line 4:   call g:vimade_active_renderer.unhighlightAll()
calling vimade#Empty()

vimade#Empty returning #0

continuing in vimade#UnhighlightAll

vimade#UnhighlightAll returning #0

continuing in vimade#SetupRenderer

line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

continuing in vimade#DeferredTick

vimade#DeferredTick returning #0

Executing User Autocommands for "VeryLazy"
autocommand <Lua 75: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:338>

Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 94: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at User Autocommands for "VeryLazy":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at User Autocommands for "VeryLazy":0
continuing in User Autocommands for "VeryLazy"
line 0: sourcing "nvim_exec2() called at User Autocommands for "VeryLazy":0"
line 1: augroup END
finished sourcing nvim_exec2() called at User Autocommands for "VeryLazy":0
continuing in User Autocommands for "VeryLazy"
Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 191: ~/.config/nvim/lua/joe-p/plugins/snacks.lua:307>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 68: vim/_defaults.lua:0>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 562: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/termcap.lua:36>

Executing: 


--- Terminal info --- {{{
&term: xterm-256color
Description: xterm with 256 colors
Aliases: xterm-256color
Boolean capabilities:
  auto_left_margin          bw         = false
  auto_right_margin         am         = true
  no_esc_ctlc               xsb        = false
  ceol_standout_glitch      xhp        = false
  eat_newline_glitch        xenl       = true
  erase_overstrike          eo         = false
  generic_type              gn         = false
  hard_copy                 hc         = false
  has_meta_key              km         = true
  has_status_line           hs         = false
  insert_null_glitch        in         = false
  memory_above              da         = false
  memory_below              db         = false
  move_insert_mode          mir        = true
  move_standout_mode        msgr       = true
  over_strike               os         = false
  status_line_esc_ok        eslok      = false
  dest_tabs_magic_smso      xt         = false
  tilde_glitch              hz         = false
  transparent_underline     ul         = false
  xon_xoff                  xon        = false
  needs_xon_xoff            nxon       = false
  prtr_silent               mc5i       = true
  hard_cursor               chts       = false
  non_rev_rmcup             nrrmc      = false
  no_pad_char               npc        = true
  non_dest_scroll_region    ndscr      = false
  can_change                ccc        = true
  back_color_erase          bce        = true
  hue_lightness_saturation  hls        = false
  col_addr_glitch           xhpa       = false
  cr_cancels_micro_mode     crxm       = false
  has_print_wheel           daisy      = false
  row_addr_glitch           xvpa       = false
  semi_auto_right_margin    sam        = false
  cpi_changes_res           cpix       = false
  lpi_changes_res           lpix       = false
  backspaces_with_bs        OTbs       = true
  crt_no_scrolling          OTns       = false
  no_correctly_working_cr   OTnc       = false
  gnu_has_meta_key          OTMT       = false
  linefeed_is_newline       OTNL       = false
  has_hardware_tabs         OTpt       = false
  return_does_clr_eol       OTxr       = false
Numeric capabilities:
  columns                   cols       = 80
  init_tabs                 it         = 8
  lines                     lines      = 24
  lines_of_memory           lm         = -1
  magic_cookie_glitch       xmc        = -1
  padding_baud_rate         pb         = -1
  virtual_terminal          vt         = -1
  width_status_line         wsl        = -1
  num_labels                nlab       = -1
  label_height              lh         = -1
  label_width               lw         = -1
  max_attributes            ma         = -1
  maximum_windows           wnum       = -1
  max_colors                colors     = 256
  max_pairs                 pairs      = 65536
  no_color_video            ncv        = -1
  buffer_capacity           bufsz      = -1
  dot_vert_spacing          spinv      = -1
  dot_horz_spacing          spinh      = -1
  max_micro_address         maddr      = -1
  max_micro_jump            mjump      = -1
  micro_col_size            mcs        = -1
  micro_line_size           mls        = -1
  number_of_pins            npins      = -1
  output_res_char           orc        = -1
  output_res_line           orl        = -1
  output_res_horz_inch      orhi       = -1
  output_res_vert_inch      orvi       = -1
  print_rate                cps        = -1
  wide_char_size            widcs      = -1
  buttons                   btns       = -1
  bit_image_entwining       bitwin     = -1
  bit_image_type            bitype     = -1
  magic_cookie_glitch_ul    OTug       = -1
  carriage_return_delay     OTdC       = -1
  new_line_delay            OTdN       = -1
  backspace_delay           OTdB       = -1
  horizontal_tab_delay      OTdT       = -1
  number_of_function_keys   OTkn       = -1
String capabilities:
  back_tab                  cbt        = ^[[Z
  bell                      bel        = ^G
  carriage_return           cr         = ^M
  change_scroll_region      csr        = ^[[%i%p1%d;%p2%dr
  clear_all_tabs            tbc        = ^[[3g
  clear_screen              clear      = ^[[H^[[2J
  clr_eol                   el         = ^[[K
  clr_eos                   ed         = ^[[J
  column_address            hpa        = ^[[%i%p1%dG
  cursor_address            cup        = ^[[%i%p1%d;%p2%dH
  cursor_down               cud1       = ^@
  cursor_home               home       = ^[[H
  cursor_invisible          civis      = ^[[?25l
  cursor_left               cub1       = ^H
  cursor_normal             cnorm      = ^[[?25h
  cursor_right              cuf1       = ^[[C
  cursor_up                 cuu1       = ^[[A
  cursor_visible            cvvis      = ^[[?12;25h
  delete_character          dch1       = ^[[P
  delete_line               dl1        = ^[[M
  enter_alt_charset_mode    smacs      = ^[(0
  enter_blink_mode          blink      = ^[[5m
  enter_bold_mode           bold       = ^[[1m
  enter_ca_mode             smcup      = ^[[?1049h^[[22;0;0t
  enter_dim_mode            dim        = ^[[2m
  enter_insert_mode         smir       = ^[[4h
  enter_secure_mode         invis      = ^[[8m
  enter_reverse_mode        rev        = ^[[7m
  enter_standout_mode       smso       = ^[[7m
  enter_underline_mode      smul       = ^[[4m
  erase_chars               ech        = ^[[%p1%dX
  exit_alt_charset_mode     rmacs      = ^[(B
  exit_attribute_mode       sgr0       = ^[(B^[[m
  exit_ca_mode              rmcup      = ^[[?1049l^[[23;0;0t
  exit_insert_mode          rmir       = ^[[4l
  exit_standout_mode        rmso       = ^[[27m
  exit_underline_mode       rmul       = ^[[24m
  flash_screen              flash      = ^[[?5h$<100/>^[[?5l
  from_status_line          fsl        = ^G
  init_2string              is2        = ^[[!p^[[?3;4l^[[4l^[>
  insert_line               il1        = ^[[L
  key_backspace             kbs        = ^H
  key_dc                    kdch1      = ^[[3~
  key_down                  kcud1      = ^[OB
  key_f1                    kf1        = ^[OP
  key_f10                   kf10       = ^[[21~
  key_f2                    kf2        = ^[OQ
  key_f3                    kf3        = ^[OR
  key_f4                    kf4        = ^[OS
  key_f5                    kf5        = ^[[15~
  key_f6                    kf6        = ^[[17~
  key_f7                    kf7        = ^[[18~
  key_f8                    kf8        = ^[[19~
  key_f9                    kf9        = ^[[20~
  key_home                  khome      = ^[OH
  key_ic                    kich1      = ^[[2~
  key_left                  kcub1      = ^[OD
  key_npage                 knp        = ^[[6~
  key_ppage                 kpp        = ^[[5~
  key_right                 kcuf1      = ^[OC
  key_sf                    kind       = ^[[1;2B
  key_sr                    kri        = ^[[1;2A
  key_up                    kcuu1      = ^[OA
  keypad_local              rmkx       = ^[[?1l^[>
  keypad_xmit               smkx       = ^[[?1h^[=
  meta_off                  rmm        = ^[[?1034l
  meta_on                   smm        = ^[[?1034h
  newline                   nel        = ^[E
  parm_dch                  dch        = ^[[%p1%dP
  parm_delete_line          dl         = ^[[%p1%dM
  parm_down_cursor          cud        = ^[[%p1%dB
  parm_ich                  ich        = ^[[%p1%d@
  parm_index                indn       = ^[[%p1%dS
  parm_insert_line          il         = ^[[%p1%dL
  parm_left_cursor          cub        = ^[[%p1%dD
  parm_right_cursor         cuf        = ^[[%p1%dC
  parm_rindex               rin        = ^[[%p1%dT
  parm_up_cursor            cuu        = ^[[%p1%dA
  print_screen              mc0        = ^[[i
  prtr_off                  mc4        = ^[[4i
  prtr_on                   mc5        = ^[[5i
  repeat_char               rep        = %p1%c^[[%p2%{1}%-%db
  reset_1string             rs1        = ^[c^[]104^G
  reset_2string             rs2        = ^[[!p^[[?3;4l^[[4l^[>
  restore_cursor            rc         = ^[8
  row_address               vpa        = ^[[%i%p1%dd
  save_cursor               sc         = ^[7
  scroll_forward            ind        = ^@
  scroll_reverse            ri         = ^[M
  set_attributes            sgr        = %?%p9%t^[(0%e^[(B%;^[[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m
  set_tab                   hts        = ^[H
  tab                       ht         = 	
  to_status_line            tsl        = ^[]0;
  key_a1                    ka1        = ^[Ow
  key_a3                    ka3        = ^[Oy
  key_b2                    kb2        = ^[Ou
  key_c1                    kc1        = ^[Oq
  key_c3                    kc3        = ^[Os
  acs_chars                 acsc       = ``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~
  key_btab                  kcbt       = ^[[Z
  enter_am_mode             smam       = ^[[?7h
  exit_am_mode              rmam       = ^[[?7l
  key_beg                   kbeg       = ^[OE
  key_end                   kend       = ^[OF
  key_enter                 kent       = ^[OM
  key_sdc                   kDC        = ^[[3;2~
  key_send                  kEND       = ^[[1;2F
  key_shome                 kHOM       = ^[[1;2H
  key_sic                   kIC        = ^[[2;2~
  key_sleft                 kLFT       = ^[[1;2D
  key_snext                 kNXT       = ^[[6;2~
  key_sprevious             kPRV       = ^[[5;2~
  key_sright                kRIT       = ^[[1;2C
  key_f11                   kf11       = ^[[23~
  key_f12                   kf12       = ^[[24~
  key_f13                   kf13       = ^[[1;2P
  key_f14                   kf14       = ^[[1;2Q
  key_f15                   kf15       = ^[[1;2R
  key_f16                   kf16       = ^[[1;2S
  key_f17                   kf17       = ^[[15;2~
  key_f18                   kf18       = ^[[17;2~
  key_f19                   kf19       = ^[[18;2~
  key_f20                   kf20       = ^[[19;2~
  key_f21                   kf21       = ^[[20;2~
  key_f22                   kf22       = ^[[21;2~
  key_f23                   kf23       = ^[[23;2~
  key_f24                   kf24       = ^[[24;2~
  key_f25                   kf25       = ^[[1;5P
  key_f26                   kf26       = ^[[1;5Q
  key_f27                   kf27       = ^[[1;5R
  key_f28                   kf28       = ^[[1;5S
  key_f29                   kf29       = ^[[15;5~
  key_f30                   kf30       = ^[[17;5~
  key_f31                   kf31       = ^[[18;5~
  key_f32                   kf32       = ^[[19;5~
  key_f33                   kf33       = ^[[20;5~
  key_f34                   kf34       = ^[[21;5~
  key_f35                   kf35       = ^[[23;5~
  key_f36                   kf36       = ^[[24;5~
  key_f37                   kf37       = ^[[1;6P
  key_f38                   kf38       = ^[[1;6Q
  key_f39                   kf39       = ^[[1;6R
  key_f40                   kf40       = ^[[1;6S
  key_f41                   kf41       = ^[[15;6~
  key_f42                   kf42       = ^[[17;6~
  key_f43                   kf43       = ^[[18;6~
  key_f44                   kf44       = ^[[19;6~
  key_f45                   kf45       = ^[[20;6~
  key_f46                   kf46       = ^[[21;6~
  key_f47                   kf47       = ^[[23;6~
  key_f48                   kf48       = ^[[24;6~
  key_f49                   kf49       = ^[[1;3P
  key_f50                   kf50       = ^[[1;3Q
  key_f51                   kf51       = ^[[1;3R
  key_f52                   kf52       = ^[[1;3S
  key_f53                   kf53       = ^[[15;3~
  key_f54                   kf54       = ^[[17;3~
  key_f55                   kf55       = ^[[18;3~
  key_f56                   kf56       = ^[[19;3~
  key_f57                   kf57       = ^[[20;3~
  key_f58                   kf58       = ^[[21;3~
  key_f59                   kf59       = ^[[23;3~
  key_f60                   kf60       = ^[[24;3~
  key_f61                   kf61       = ^[[1;4P
  key_f62                   kf62       = ^[[1;4Q
  key_f63                   kf63       = ^[[1;4R
  clr_bol                   el1        = ^[[1K
  clear_margins             mgc        = ^[[?69l
  user6                     u6         = ^[[%i%d;%dR
  user7                     u7         = ^[[6n
  user8                     u8         = ^[[?%[;0123456789]c
  user9                     u9         = ^[[c
  orig_pair                 op         = ^[[39;49m
  orig_colors               oc         = ^[]104^G
  initialize_color          initc      = ^[]4;%p1%d;rgb:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X^[\
  enter_italics_mode        sitm       = ^[[3m
  exit_italics_mode         ritm       = ^[[23m
  key_mouse                 kmous      = ^[[<
  set_a_foreground          setaf      = ^[[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m
  set_a_background          setab      = ^[[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m
  set_tb_margin             smgtb      = ^[[%i%p1%d;%p2%dr
  memory_lock               meml       = ^[l
  memory_unlock             memu       = ^[m
Extended boolean capabilities:
  AX                        = true
  XF                        = true
  XT                        = true
Extended string capabilities:
  BD                        = ^[[?2004l
  BE                        = ^[[?2004h
  Cr                        = ^[]112^G
  Cs                        = ^[]12;%p1%s^G
  E3                        = ^[[3J
  Ms                        = ^[]52;%p1%s;%p2%s^G
  PE                        = ^[[201~
  PS                        = ^[[200~
  RV                        = ^[[>c
  Se                        = ^[[2 q
  Ss                        = ^[[%p1%d q
  XM                        = ^[[?1006;1000%?%p1%{1}%=%th%el%;
  XR                        = ^[[>0q
  fd                        = ^[[?1004l
  fe                        = ^[[?1004h
  kDC3                      = ^[[3;3~
  kDC4                      = ^[[3;4~
  kDC5                      = ^[[3;5~
  kDC6                      = ^[[3;6~
  kDC7                      = ^[[3;7~
  kDN                       = ^[[1;2B
  kDN3                      = ^[[1;3B
  kDN4                      = ^[[1;4B
  kDN5                      = ^[[1;5B
  kDN6                      = ^[[1;6B
  kDN7                      = ^[[1;7B
  kEND3                     = ^[[1;3F
  kEND4                     = ^[[1;4F
  kEND5                     = ^[[1;5F
  kEND6                     = ^[[1;6F
  kEND7                     = ^[[1;7F
  kHOM3                     = ^[[1;3H
  kHOM4                     = ^[[1;4H
  kHOM5                     = ^[[1;5H
  kHOM6                     = ^[[1;6H
  kHOM7                     = ^[[1;7H
  kIC3                      = ^[[2;3~
  kIC4                      = ^[[2;4~
  kIC5                      = ^[[2;5~
  kIC6                      = ^[[2;6~
  kIC7                      = ^[[2;7~
  kLFT3                     = ^[[1;3D
  kLFT4                     = ^[[1;4D
  kLFT5                     = ^[[1;5D
  kLFT6                     = ^[[1;6D
  kLFT7                     = ^[[1;7D
  kNXT3                     = ^[[6;3~
  kNXT4                     = ^[[6;4~
  kNXT5                     = ^[[6;5~
  kNXT6                     = ^[[6;6~
  kNXT7                     = ^[[6;7~
  kPRV3                     = ^[[5;3~
  kPRV4                     = ^[[5;4~
  kPRV5                     = ^[[5;5~
  kPRV6                     = ^[[5;6~
  kPRV7                     = ^[[5;7~
  kRIT3                     = ^[[1;3C
  kRIT4                     = ^[[1;4C
  kRIT5                     = ^[[1;5C
  kRIT6                     = ^[[1;6C
  kRIT7                     = ^[[1;7C
  kUP                       = ^[[1;2A
  kUP3                      = ^[[1;3A
  kUP4                      = ^[[1;4A
  kUP5                      = ^[[1;5A
  kUP6                      = ^[[1;6A
  kUP7                      = ^[[1;7A
  ka2                       = ^[Ox
  kb1                       = ^[Ot
  kb3                       = ^[Ov
  kc2                       = ^[Or
  kp5                       = ^[OE
  kpADD                     = ^[Ok
  kpCMA                     = ^[Ol
  kpDIV                     = ^[Oo
  kpDOT                     = ^[On
  kpMUL                     = ^[Oj
  kpSUB                     = ^[Om
  kpZRO                     = ^[Op
  kxIN                      = ^[[I
  kxOUT                     = ^[[O
  rmxx                      = ^[[29m
  rv                        = ^[\[41;[1-6][0-9][0-9];0c
  smxx                      = ^[[9m
  xm                        = ^[[<%i%p3%d;%p1%d;%p2%d;%?%p4%tM%em%;
  xr                        = ^[P>\|XTerm\([1-9][0-9]+\)^[\\
  ext.resize_screen         = ^[[8;%p1%d;%p2%dt
  ext.reset_scroll_region   = ^[[r
  ext.enter_altfont_mode    = ^[[11m
  setrgbf                   = ^[[38;2;%p1%d;%p2%d;%p3%dm
  setrgbb                   = ^[[48;2;%p1%d;%p2%d;%p3%dm
  ext.save_title            = ^[[22;0t
  ext.restore_title         = ^[[23;0t
  ext.set_title             = ^[]0;%p2%s^G
  ext.enable_lr_margin      = ^[[?69h
  ext.disable_lr_margin     = ^[[?69l
  ext.enable_bpaste         = ^[[?2004h
  ext.disable_bpaste        = ^[[?2004l
  ext.enable_focus          = ^[[?1004h
  ext.disable_focus         = ^[[?1004l
  ext.enable_mouse          = ^[[?1002h^[[?1006h
  ext.disable_mouse         = ^[[?1002l^[[?1006l
  ext.enable_mouse_move     = ^[[?1003h
  ext.disable_mouse_move    = ^[[?1003l
  ext.set_underline_style   = ^[[4:%p1%dm
  ext.set_underline_color   = ^[[58:2::%p1%d:%p2%d:%p3%dm
  Sync                      = ^[[?2026%?%p1%{1}%-%tl%eh%;
}}}

sourcing "nvim_exec2()"
line 1: hi def TodoBgTODO guibg=#91d7e3 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgTODO guibg=NONE guifg=#91d7e3 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignTODO guibg=NONE guifg=#91d7e3 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgWARN guibg=#eed49f guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgWARN guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignWARN guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgTEST guibg=#f0c6c6 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgTEST guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignTEST guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgHACK guibg=#eed49f guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgHACK guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignHACK guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgPERF guibg=#f0c6c6 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgPERF guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignPERF guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgNOTE guibg=#8bd5ca guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgNOTE guibg=NONE guifg=#8bd5ca gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignNOTE guibg=NONE guifg=#8bd5ca gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgFIX guibg=#ed8796 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgFIX guibg=NONE guifg=#ed8796 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignFIX guibg=NONE guifg=#ed8796 gui=NONE
finished sourcing nvim_exec2()
calling <lambda>2(2)

calling <SNR>44_pick_chunk(['', 'sourcing "nvim_exec2()"', 'line ...d_load_ftplugin")', 'line 8:   finish'], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
line 4:     endif
line 5: 
line 6:     " if the extra context option is disabled - do nothing
line 7:     if g:llama_config.ring_n_chunks <= 0
line 8:         return
line 9:     endif
line 10: 
line 11:     " don't pick very small chunks
line 12:     if len(a:text) < 3
line 13:         return
line 14:     endif
line 15: 
line 16:     if len(a:text) + 1 < g:llama_config.ring_chunk_size
line 17:         let l:chunk = a:text
line 18:     else
line 19:         let l:l0 = s:rand(0, max([0, len(a:text) - g:llama_config.ring_chunk_size/2]))
line 20:         let l:l1 = min([l:l0 + g:llama_config.ring_chunk_size/2, len(a:text)])
line 21: 
line 22:         let l:chunk = a:text[l:l0:l:l1]
line 23:     endif
line 24: 
line 25:     let l:chunk_str = join(l:chunk, "\n") . "\n"
line 26: 
line 27:     " check if this chunk is already added
line 28:     let l:exist = v:false
line 29: 
line 30:     for i in range(len(s:ring_chunks))
line 31:         if s:ring_chunks[i].data == l:chunk
line 32:             let l:exist = v:true
line 33:             break
line 34:         endif
line 35:     endfor
line 36: 
line 37:     for i in range(len(s:ring_queued))
line 38:         if s:ring_queued[i].data == l:chunk
line 39:             let l:exist = v:true
line 40:             break
line 41:         endif
line 42:     endfor
line 43: 
line 44:     if l:exist
line 45:         return
line 46:     endif
line 47: 
line 48:     " evict queued chunks that are very similar to the new one
line 49:     for i in range(len(s:ring_queued) - 1, 0, -1)
line 50:         if s:chunk_sim(s:ring_queued[i].data, l:chunk) > 0.9
line 51:             if a:do_evict
line 52:                 call remove(s:ring_queued, i)
line 53:                 let s:ring_n_evict += 1
line 54:             else
line 55:                 return
line 56:             endif
line 57:         endif
line 58:     endfor
line 59: 
line 60:     " also from s:ring_chunks
line 61:     for i in range(len(s:ring_chunks) - 1, 0, -1)
line 62:         if s:chunk_sim(s:ring_chunks[i].data, l:chunk) > 0.9
line 63:             if a:do_evict
line 64:                 call remove(s:ring_chunks, i)
line 65:                 let s:ring_n_evict += 1
line 66:             else
line 67:                 return
line 68:             endif
line 69:         endif
line 70:     endfor
line 71: 
line 72:     " TODO: become parameter ?
line 73:     if len(s:ring_queued) == 16
line 74:         call remove(s:ring_queued, 0)
line 75:     endif
line 76: 
line 77:     call add(s:ring_queued, {'data': l:chunk, 'str': l:chunk_str, 'time': reltime(), 'filename': expand('%')})
line 78: 
line 79:     "let &statusline = 'extra context: ' . len(s:ring_chunks) . ' / ' . len(s:ring_queued)
<SNR>44_pick_chunk returning #0

continuing in <lambda>2

<lambda>2 returning #0

calling <lambda>3(5)

calling <SNR>44_pick_chunk(['', 'sourcing "nvim_exec2()"', 'line ...d_load_ftplugin")', 'line 8:   finish'], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
line 4:     endif
line 5: 
line 6:     " if the extra context option is disabled - do nothing
line 7:     if g:llama_config.ring_n_chunks <= 0
line 8:         return
line 9:     endif
line 10: 
line 11:     " don't pick very small chunks
line 12:     if len(a:text) < 3
line 13:         return
line 14:     endif
line 15: 
line 16:     if len(a:text) + 1 < g:llama_config.ring_chunk_size
line 17:         let l:chunk = a:text
line 18:     else
line 19:         let l:l0 = s:rand(0, max([0, len(a:text) - g:llama_config.ring_chunk_size/2]))
line 20:         let l:l1 = min([l:l0 + g:llama_config.ring_chunk_size/2, len(a:text)])
line 21: 
line 22:         let l:chunk = a:text[l:l0:l:l1]
line 23:     endif
line 24: 
line 25:     let l:chunk_str = join(l:chunk, "\n") . "\n"
line 26: 
line 27:     " check if this chunk is already added
line 28:     let l:exist = v:false
line 29: 
line 30:     for i in range(len(s:ring_chunks))
line 31:         if s:ring_chunks[i].data == l:chunk
line 32:             let l:exist = v:true
line 33:             break
line 34:         endif
line 35:     endfor
line 36: 
line 37:     for i in range(len(s:ring_queued))
line 38:         if s:ring_queued[i].data == l:chunk
line 39:             let l:exist = v:true
line 40:             break
line 41:         endif
line 42:     endfor
line 43: 
line 44:     if l:exist
line 45:         return
<SNR>44_pick_chunk returning #0

continuing in <lambda>3

<lambda>3 returning #0

calling <lambda>4(6)

calling <SNR>44_pick_chunk(['', 'sourcing "nvim_exec2()"', 'line ...d_load_ftplugin")', 'line 8:   finish'], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
line 4:     endif
line 5: 
line 6:     " if the extra context option is disabled - do nothing
line 7:     if g:llama_config.ring_n_chunks <= 0
line 8:         return
line 9:     endif
line 10: 
line 11:     " don't pick very small chunks
line 12:     if len(a:text) < 3
line 13:         return
line 14:     endif
line 15: 
line 16:     if len(a:text) + 1 < g:llama_config.ring_chunk_size
line 17:         let l:chunk = a:text
line 18:     else
line 19:         let l:l0 = s:rand(0, max([0, len(a:text) - g:llama_config.ring_chunk_size/2]))
line 20:         let l:l1 = min([l:l0 + g:llama_config.ring_chunk_size/2, len(a:text)])
line 21: 
line 22:         let l:chunk = a:text[l:l0:l:l1]
line 23:     endif
line 24: 
line 25:     let l:chunk_str = join(l:chunk, "\n") . "\n"
line 26: 
line 27:     " check if this chunk is already added
line 28:     let l:exist = v:false
line 29: 
line 30:     for i in range(len(s:ring_chunks))
line 31:         if s:ring_chunks[i].data == l:chunk
line 32:             let l:exist = v:true
line 33:             break
line 34:         endif
line 35:     endfor
line 36: 
line 37:     for i in range(len(s:ring_queued))
line 38:         if s:ring_queued[i].data == l:chunk
line 39:             let l:exist = v:true
line 40:             break
line 41:         endif
line 42:     endfor
line 43: 
line 44:     if l:exist
line 45:         return
<SNR>44_pick_chunk returning #0

continuing in <lambda>4

<lambda>4 returning #0

calling <lambda>1(1)

calling <SNR>44_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
line 10:     endif
line 11: 
line 12:     " move the first queued chunk to the ring buffer
line 13:     if len(s:ring_chunks) == g:llama_config.ring_n_chunks
line 14:         call remove(s:ring_chunks, 0)
line 15:     endif
line 16: 
line 17:     call add(s:ring_chunks, remove(s:ring_queued, 0))
line 18: 
line 19:     "let &statusline = 'updated context: ' . len(s:ring_chunks) . ' / ' . len(s:ring_queued)
line 20: 
line 21:     " send asynchronous job with the new extra context so that it is ready for the next FIM
line 22:     let l:extra_context = []
line 23:     for l:chunk in s:ring_chunks
line 24:         call add(l:extra_context, { 'text':     l:chunk.str, 'time':     l:chunk.time, 'filename': l:chunk.filename })
line 29:     endfor
line 23:     for l:chunk in s:ring_chunks
line 24:         call add(l:extra_context, { 'text':     l:chunk.str, 'time':     l:chunk.time, 'filename': l:chunk.filename })
line 29:     endfor
line 30: 
line 31:     " no samplers needed here
line 32:     let l:request = json_encode({ 'input_prefix':     "", 'input_suffix':     "", 'input_extra':      l:extra_context, 'prompt':           "", 'n_predict':        0, 'temperature':      0.0, 'stream':           v:false, 'samplers':         [], 'cache_prompt':     v:true, 't_max_prompt_ms':  1, 't_max_predict_ms': 1, 'response_fields':  [""] })
line 46:     let l:curl_command = [ "curl", "--silent", "--no-buffer", "--request", "POST", "--url", g:llama_config.endpoint, "--header", "Content-Type: application/json", "--data", "@-", ]
line 55:     if exists ("g:llama_config.api_key") && len("g:llama_config.api_key") > 0
line 56:         call extend(l:curl_command, ['--header', 'Authorization: Bearer ' .. g:llama_config.api_key])
line 57:     endif
line 58: 
line 59:     " no callbacks because we don't need to process the response
line 60:     if s:ghost_text_nvim
line 61:         let jobid = jobstart(l:curl_command, {})
line 62:         call chansend(jobid, l:request)
line 63:         call chanclose(jobid, 'stdin')
line 64:     elseif s:ghost_text_vim
line 65:         let jobid = job_start(l:curl_command, {})
line 66:         let channel = job_getchannel(jobid)
line 67:         call ch_sendraw(channel, l:request)
line 68:         call ch_close_in(channel)
line 69:     endif
<SNR>44_ring_update returning #0

continuing in <lambda>1

<lambda>1 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

Searching for "autoload/provider/clipboard.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/flash.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/autoload/provider/clipboard.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/autoload/provider/clipboard.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim"
line 1: " The clipboard provider uses shell commands to communicate with the clipboard.
line 2: " The provider function will only be registered if a supported command is
line 3: " available.
line 4: 
line 5: if exists('g:loaded_clipboard_provider')
line 6:   finish
line 7: endif
line 8: " Default to 0.  provider#clipboard#Executable() may set 2.
line 9: " To force a reload:
line 10: "   :unlet g:loaded_clipboard_provider
line 11: "   :runtime autoload/provider/clipboard.vim
line 12: let g:loaded_clipboard_provider = 0
line 13: 
line 14: let s:copy = {}
line 15: let s:paste = {}
line 16: let s:clipboard = {}
line 17: 
line 18: " When caching is enabled, store the jobid of the xclip/xsel process keeping
line 19: " ownership of the selection, so we know how long the cache is valid.
line 20: let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
line 21: 
line 22: function! s:selection.on_exit(jobid, data, event) abort
line 35: 
line 36: let s:selections = { '*': s:selection, '+': copy(s:selection) }
line 37: 
line 38: function! s:try_cmd(cmd, ...) abort
line 51: 
line 52: " Returns TRUE if `cmd` exits with success, else FALSE.
line 53: function! s:cmd_ok(cmd) abort
line 57: 
line 58: function! s:split_cmd(cmd) abort
line 61: 
line 62: function! s:set_osc52() abort
line 69: 
line 70: function! s:set_pbcopy() abort
line 78: 
line 79: function! s:set_wayland() abort
line 86: 
line 87: function! s:set_wayclip() abort
line 94: 
line 95: function! s:set_xsel() abort
line 102: 
line 103: function! s:set_xclip() abort
line 110: 
line 111: function! s:set_lemonade() abort
line 118: 
line 119: function! s:set_doitclient() abort
line 126: 
line 127: function! s:set_win32yank() abort
line 139: 
line 140: function! s:set_putclip() abort
line 147: 
line 148: function! s:set_clip() abort
line 155: 
line 156: function! s:set_termux() abort
line 163: 
line 164: function! s:set_tmux() abort
line 176: 
line 177: let s:cache_enabled = 1
line 178: let s:err = ''
line 179: 
line 180: function! provider#clipboard#Error() abort
line 183: 
line 184: function! provider#clipboard#Executable() abort
line 269: 
line 270: function! s:clipboard.get(reg) abort
line 287: 
line 288: function! s:clipboard.set(lines, regtype, reg) abort
line 346: 
line 347: function! provider#clipboard#Call(method, args) abort
line 358: 
line 359: " eval_has_provider() decides based on this variable.
line 360: let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 0 : 2
calling provider#clipboard#Executable()

line 1:   " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
line 2:   if exists('g:clipboard') && g:clipboard isnot# v:false
line 3:     if v:t_string ==# type(g:clipboard)
line 4:       " Handle string form of g:clipboard for all builtin providers
line 5:       if 'osc52' == g:clipboard
line 6:         " User opted-in to OSC 52 by manually setting g:clipboard.
line 7:         return s:set_osc52()
line 8:       elseif 'pbcopy' == g:clipboard
line 9:         return s:set_pbcopy()
line 10:       elseif 'wl-copy' == g:clipboard
line 11:         return s:set_wayland()
line 12:       elseif 'wayclip' == g:clipboard
line 13:         return s:set_wayclip()
line 14:       elseif 'xsel' == g:clipboard
line 15:         return s:set_xsel()
line 16:       elseif 'xclip' == g:clipboard
line 17:         return s:set_xclip()
line 18:       elseif 'lemonade' == g:clipboard
line 19:         return s:set_lemonade()
line 20:       elseif 'doitclient' == g:clipboard
line 21:         return s:set_doitclient()
line 22:       elseif 'win32yank' == g:clipboard
line 23:         return s:set_win32yank()
line 24:       elseif 'putclip' == g:clipboard
line 25:         return s:set_putclip()
line 26:       elseif 'clip' == g:clipboard
line 27:         return s:set_clip()
line 28:       elseif 'termux' == g:clipboard
line 29:         return s:set_termux()
line 30:       elseif 'tmux' == g:clipboard
line 31:         return s:set_tmux()
line 32:       endif
line 33:     endif
line 34: 
line 35:     if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
line 38:       let s:err = 'clipboard: invalid g:clipboard'
line 39:       return ''
line 40:     endif
line 41: 
line 42:     let s:copy = {}
line 43:     let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
line 44:     let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
line 45: 
line 46:     let s:paste = {}
line 47:     let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
line 48:     let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
line 49: 
line 50:     let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
line 51:     return get(g:clipboard, 'name', 'g:clipboard')
line 52:   elseif has('mac')
line 53:     return s:set_pbcopy()
calling <SNR>119_set_pbcopy()

line 1:   let s:copy['+'] = ['pbcopy']
line 2:   let s:paste['+'] = ['pbpaste']
line 3:   let s:copy['*'] = s:copy['+']
line 4:   let s:paste['*'] = s:paste['+']
line 5:   let s:cache_enabled = 0
line 6:   return 'pbcopy'
<SNR>119_set_pbcopy returning 'pbcopy'

continuing in provider#clipboard#Executable

provider#clipboard#Executable returning 'pbcopy'

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim

finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim
Executing CursorMoved Autocommands for "*"
autocommand <Lua 312: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>44_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>44_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>44_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>44_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>44_on_move

<SNR>44_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 269: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 361: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 518: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 558: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 606: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
calling <lambda>5(7)

calling <SNR>44_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>44_ring_update returning #0

continuing in <lambda>5

<lambda>5 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

calling <lambda>6(8)

calling <SNR>44_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>44_ring_update returning #0

continuing in <lambda>6

<lambda>6 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

calling <lambda>7(9)

calling <SNR>44_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>44_ring_update returning #0

continuing in <lambda>7

<lambda>7 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
calling <lambda>8(10)

calling <SNR>44_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>44_ring_update returning #0

continuing in <lambda>8

<lambda>8 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 267: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:432>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 514: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 373: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 398: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 376: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 267: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:432>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 514: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 373: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 398: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 376: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 312: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>44_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>44_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>44_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>44_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>44_on_move

<SNR>44_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 269: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 361: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 518: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 558: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 606: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing OptionSet Autocommands for "runtimepath"
autocommand <Lua 213: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/treesitter/query.lua:338>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 507: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
sourcing "nvim_exec2()"
line 1:     amenu     PopUp.Open\ in\ web\ browser  gx
line 2:     anoremenu PopUp.Inspect                 <Cmd>Inspect<CR>
line 3:     anoremenu PopUp.Go\ to\ definition      <Cmd>lua vim.lsp.buf.definition()<CR>
line 4:     anoremenu PopUp.Show\ Diagnostics       <Cmd>lua vim.diagnostic.open_float()<CR>
line 5:     anoremenu PopUp.Show\ All\ Diagnostics  <Cmd>lua vim.diagnostic.setqflist()<CR>
line 6:     anoremenu PopUp.Configure\ Diagnostics  <Cmd>help vim.diagnostic.config()<CR>
line 7:     anoremenu PopUp.-1-                     <Nop>
line 8:     vnoremenu PopUp.Cut                     "+x
line 9:     vnoremenu PopUp.Copy                    "+y
line 10:     anoremenu PopUp.Paste                   "+gP
line 11:     vnoremenu PopUp.Paste                   "+P
line 12:     vnoremenu PopUp.Delete                  "_x
line 13:     nnoremenu PopUp.Select\ All             ggVG
line 14:     vnoremenu PopUp.Select\ All             gg0oG$
line 15:     inoremenu PopUp.Select\ All             <C-Home><C-O>VG
line 16:     anoremenu PopUp.-2-                     <Nop>
line 17:     anoremenu PopUp.How-to\ disable\ mouse  <Cmd>help disable-mouse<CR>
line 18:   
finished sourcing nvim_exec2()
Searching for "ftplugin.vim" in runtime path
Searching for "/Users/joe/.config/nvim/ftplugin.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_load_ftplugin")
line 8:   finish
line 9: endif
line 10: let did_load_ftplugin = 1
line 11: 
line 12: augroup filetypeplugin
line 13:   au FileType * call s:LoadFTPlugin()
line 14: 
line 15:   func! s:LoadFTPlugin()
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/Users/joe/.config/nvim/indent.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   finish
line 9: endif
line 10: let did_indent_on = 1
line 11: 
line 12: augroup filetypeindent
line 13:   au FileType * call s:LoadIndent()
line 14:   func! s:LoadIndent()
line 33: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/indent.vim"
could not source "/opt/homebrew/etc/xdg/nvim/sysinit.vim"
could not source "/etc/xdg/nvim/sysinit.vim"
could not source "$VIM/sysinit.vim"
sourcing "/Users/joe/.config/nvim/init.lua"
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
line 0: sourcing "nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:0"
line 1:   augroup filetypedetect
line 2:   runtime! ftdetect/*.{vim,lua}
Searching for "ftdetect/*.{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftdetect/*.{vim,lua}"
not found in runtime path: "ftdetect/*.{vim,lua}"
line 3:   augroup END
finished sourcing nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:0
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim"
line 1: " sleuth.vim - Heuristically set buffer options
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.0
line 4: " GetLatestVimScripts: 4375 1 :AutoInstall: sleuth.vim
line 5: 
line 6: if exists("#polyglot-sleuth")
line 7:   autocmd! polyglot-sleuth
line 8:   augroup! polyglot-sleuth
line 9:   unlet! g:loaded_sleuth
line 10:   let s:polyglot = 1
line 11: endif
line 12: 
line 13: if exists("g:loaded_sleuth") || v:version < 700 || &cp
line 14:   finish
line 15: endif
line 16: let g:loaded_sleuth = 1
line 17: lockvar g:loaded_sleuth
line 18: 
line 19: function! s:Warn(msg, ...) abort
line 27: 
line 28: if exists('+shellslash')
line 29:   function! s:Slash(path) abort
line 32: else
line 33:   function! s:Slash(path) abort
line 36: endif
line 37: 
line 38: function! s:Guess(source, detected, lines) abort
line 149: 
line 150: function! s:Capture(cmd) abort
line 156: 
line 157: let s:modeline_numbers = { 'shiftwidth': 'shiftwidth', 'sw': 'shiftwidth', 'tabstop': 'tabstop', 'ts': 'tabstop', 'textwidth': 'textwidth', 'tw': 'textwidth', }
line 162: let s:modeline_booleans = { 'expandtab': 'expandtab', 'et': 'expandtab', 'fixendofline': 'fixendofline', 'fixeol': 'fixendofline', }
line 166: function! s:ParseOptions(declarations, into, ...) abort
line 181: 
line 182: function! s:ModelineOptions() abort
line 203: 
line 204: let s:fnmatch_replacements = { '.': '\.', '\%': '%', '\(': '(', '\)': ')', '\{': '{', '\}': '}', '\_': '_', '?': '[^/]', '*': '[^/]*', '/**/*': '/.*', '/**/': '/\%(.*/\)\=', '**': '.*'}
line 207: function! s:FnmatchReplace(pat) abort
line 231: 
line 232: function! s:FnmatchTranslate(pat) abort
line 235: 
line 236: function! s:ReadEditorConfig(absolute_path) abort
line 268: 
line 269: let s:editorconfig_cache = {}
line 270: function! s:DetectEditorConfig(absolute_path, ...) abort
line 314: 
line 315: let s:editorconfig_bomb = { 'utf-8':     0, 'utf-8-bom': 1, 'utf-16be':  1, 'utf-16le':  1, 'latin1':    0, }
line 322: 
line 323: let s:editorconfig_fileformat = { 'cr':   'mac', 'crlf': 'dos', 'lf':   'unix', }
line 328: 
line 329: function! s:EditorConfigToOptions(pairs) abort
line 383: 
line 384: function! s:Ready(detected) abort
line 387: 
line 388: let s:booleans = {'expandtab': 1, 'fixendofline': 1, 'endofline': 1, 'bomb': 1}
line 389: let s:safe_options = ['expandtab', 'shiftwidth', 'tabstop', 'textwidth', 'fixendofline']
line 390: let s:all_options = s:safe_options + ['endofline', 'fileformat', 'fileencoding', 'bomb']
line 391: let s:short_options = { 'expandtab': 'et', 'shiftwidth': 'sw', 'tabstop': 'ts', 'textwidth': 'tw', 'fixendofline': 'fixeol', 'endofline': 'eol', 'fileformat': 'ff', 'fileencoding': 'fenc'}
line 395: 
line 396: function! s:Apply(detected, permitted_options, silent) abort
line 459: 
line 460: function! s:UserOptions(ft, name) abort
line 487: 
line 488: function! s:DetectDeclared() abort
line 512: 
line 513: function! s:DetectHeuristics(into) abort
line 592: 
line 593: function! s:Init(redetect, unsafe, do_filetype, silent) abort
line 631: 
line 632: function! s:AutoInit() abort
line 635: 
line 636: function! s:Sleuth(line1, line2, range, bang, mods, args) abort
line 640: 
line 641: if !exists('g:did_indent_on') && !get(g:, 'sleuth_no_filetype_indent_on')
line 642:   filetype indent on
line 643: elseif !exists('g:did_load_filetypes')
line 644:   filetype on
line 645: endif
line 646: 
line 647: function! SleuthIndicator() abort
line 664: 
line 665: augroup sleuth
line 666:   autocmd!
line 667:   autocmd BufNewFile,BufReadPost * nested if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
line 670:   autocmd BufFilePost * nested if (@% !~# '^!' || exists('b:sleuth')) && get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
line 673:   autocmd FileType * nested if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif
line 675:   autocmd User Flags call Hoist('buffer', 5, 'SleuthIndicator')
line 676: augroup END
line 677: 
line 678: command! -bar -bang Sleuth exe s:Sleuth(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim"
line 1: 
line 2: " Create command for running busted
line 3: command! -nargs=1 -complete=file PlenaryBustedFile lua require('plenary.test_harness').test_file([[<args>]])
line 5: 
line 6: command! -nargs=+ -complete=file PlenaryBustedDirectory lua require('plenary.test_harness').test_directory_command([[<args>]])
line 8: 
line 9: nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>
finished sourcing /Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim"
line 1: if exists('g:loaded_devicons') | finish | endif
line 1:  finish | endif
line 1:  endif
line 2: 
line 3: let s:save_cpo = &cpo
line 4: set cpo&vim
line 5: 
line 6: " TODO change so its easier to get
line 7: let g:nvim_web_devicons = 1
line 8: 
line 9: let &cpo = s:save_cpo
line 10: unlet s:save_cpo
line 11: 
line 12: let g:loaded_devicons = 1
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim"
line 1: if exists('g:vimade_loaded')
line 2:   finish
line 3: endif
line 4: 
line 5: let g:vimade_loaded = 1
line 6: 
line 7: if !exists('g:vimade')
line 8:   let g:vimade = {}
line 9: endif
line 10: 
line 11: 
line 12: ""Enables Vimade
line 13: command! VimadeEnable call vimade#Enable()
line 14: 
line 15: ""Unfades all buffers, signs, and disables Vimade
line 16: command! VimadeDisable call vimade#Disable()
line 17: 
line 18: ""Disables the current window
line 19: command! VimadeWinDisable call vimade#WinDisable()
line 20: 
line 21: ""Disables the current buffer
line 22: command! VimadeBufDisable call vimade#BufDisable()
line 23: 
line 24: ""Fades the current buffer
line 25: command! VimadeFadeActive call vimade#FadeActive()
line 26: "
line 27: ""Unfades the current buffer
line 28: command! VimadeUnfadeActive call vimade#UnfadeActive()
line 29: 
line 30: ""Enables the current window
line 31: command! VimadeWinEnable call vimade#WinEnable()
line 32: 
line 33: ""Enables the current buffer
line 34: command! VimadeBufEnable call vimade#BufEnable()
line 35: 
line 36: ""Toggles Vimade between enabled and disabled states
line 37: command! VimadeToggle call vimade#Toggle()
line 38: 
line 39: ""Prints debug information that should be included in bug reports
line 40: command! VimadeInfo echo json_encode(vimade#GetInfo())
line 41: 
line 42: ""Recalculates all fades and redraws all inactive buffers and signs
line 43: command! VimadeRedraw call vimade#Redraw()
line 44: 
line 45: ""Changes vimade_fadelevel to the {value} specified.  {value} can be between
line 46: "0.0 and 1.0
line 47: command! -nargs=1 VimadeFadeLevel call vimade#FadeLevel(<q-args>)
line 48: 
line 49: ""Changes vimade_fadepriority to the {value} specified.  This can be useful
line 50: "when combining Vimade with other plugins that also highlight using matches
line 51: command! -nargs=1 VimadeFadePriority call vimade#FadePriority(<q-args>)
line 52: 
line 53: ""Overrides the Folded highlight by creating a link to the Vimade base fade.
line 54: "This should produce acceptable results for colorschemes that include Folded
line 55: "highlights that are distracting in faded windows.
line 56: command! VimadeOverrideFolded call vimade#OverrideFolded()
line 57: 
line 58: ""EXPERIMENTAL -- Overrides the SignColumn highlight by creating a link to the Vimade base fade.
line 59: "This should produce acceptable results for colorschemes that include Folded
line 60: "highlights that are distracting in faded windows.
line 61: command! VimadeOverrideSignColumn call vimade#OverrideSignColumn()
line 62: 
line 63: ""EXPERIMENTAL -- Overrides the LineNr highlight by creating a link to the Vimade base fade.
line 64: "This should produce acceptable results for colorschemes that include Folded
line 65: "highlights that are distracting in faded windows.
line 66: command! VimadeOverrideLineNr call vimade#OverrideLineNr()
line 67: 
line 68: ""EXPERIMENTAL -- Overrides the VertSplit highlight by creating a link to the Vimade base fade.
line 69: "This should produce acceptable results for colorschemes that include Folded
line 70: "highlights that are distracting in faded windows.
line 71: command! VimadeOverrideSplits call vimade#OverrideVertSplit()
line 72: 
line 73: ""EXPERIMENTAL -- Overrides the NonText highlight by creating a link to the Vimade base fade.
line 74: "This should produce acceptable results for colorschemes that include Folded
line 75: "highlights that are distracting in faded windows.
line 76: command! VimadeOverrideNonText call vimade#OverrideNonText()
line 77: 
line 78: ""EXPERIMENTAL -- Overrides the EndOfBuffer highlight by creating a link to the Vimade base fade.
line 79: "This should produce acceptable results for colorschemes that include Folded
line 80: "highlights that are distracting in faded windows.
line 81: command! VimadeOverrideEndOfBuffer call vimade#OverrideEndOfBuffer()
line 82: 
line 83: ""EXPERIMENTAL -- Overrides static highlights by creating a link to the Vimade base fade.
line 84: "This should produce acceptable results for colorschemes that include Folded
line 85: "highlights that are distracting in faded windows.
line 86: command! VimadeOverrideAll call vimade#OverrideAll()
line 87: 
line 88: "" EXPERIMENTAL - Loads the current lua-only commands for Neovim (VimadeFocus & VimadeMark)
line 89: if has('nvim')
line 90:   lua require('vimade.focus.commands')
line 91: endif
line 92: 
line 93: let g:vimade_plugin_current_directory = resolve(expand('<sfile>:p:h').'/../lib')
line 94: 
line 95: if (!exists('g:vimade.lazy') || !g:vimade.lazy) && !exists('g::vimade_loaded')
line 96:   if v:vim_did_enter
line 97:     call vimade#Load()
line 98:   else
line 99:     augroup vimade
line 100:       au!
line 101:       au VimEnter * call vimade#Load()
line 102:     augroup END
line 103:   endif
line 104: endif
finished sourcing /Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim"
line 1: lua << EOF
line 3: sourcing "nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua"
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallFromGrammar lua require'nvim-treesitter.install'.commands.TSInstallFromGrammar['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdateSync lua require'nvim-treesitter.install'.commands.TSUpdateSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdate lua require'nvim-treesitter.install'.commands.TSUpdate['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallSync lua require'nvim-treesitter.install'.commands.TSInstallSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstall lua require'nvim-treesitter.install'.commands.TSInstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#installed_parsers TSUninstall lua require'nvim-treesitter.install'.commands.TSUninstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSInstallInfo lua require'nvim-treesitter.info'.commands.TSInstallInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=? -complete=custom,nvim_treesitter#available_modules TSModuleInfo lua require'nvim-treesitter.info'.commands.TSModuleInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufDisable lua require'nvim-treesitter.configs'.commands.TSBufDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufEnable lua require'nvim-treesitter.configs'.commands.TSBufEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQueryUserAfter lua require'nvim-treesitter.configs'.commands.TSEditQueryUserAfter['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQuery lua require'nvim-treesitter.configs'.commands.TSEditQuery['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSConfigInfo lua require'nvim-treesitter.configs'.commands.TSConfigInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSToggle lua require'nvim-treesitter.configs'.commands.TSToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSDisable lua require'nvim-treesitter.configs'.commands.TSDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSEnable lua require'nvim-treesitter.configs'.commands.TSEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufToggle lua require'nvim-treesitter.configs'.commands.TSBufToggle['run<bang>'](<f-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
continuing in nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3
finished sourcing nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3
continuing in /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
line 3: sourcing "nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3
continuing in /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
line 3: sourcing "nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3
continuing in /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
Searching for "parser/bash.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/bash.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/bash.so"
Searching for "parser/c.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/c.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/c.so"
Searching for "parser/diff.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/diff.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/diff.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/diff.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/diff.so"
Searching for "parser/html.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/html.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/html.so"
Searching for "parser/lua.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/lua.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/lua.so"
Searching for "parser/luadoc.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/luadoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/luadoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/luadoc.so"
Searching for "parser/markdown.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/markdown.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/markdown.so"
Searching for "parser/markdown_inline.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/markdown_inline.so"
Searching for "parser/query.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/query.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/query.so"
Searching for "parser/vim.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/vim.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/vim.so"
Searching for "parser/vimdoc.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/vimdoc.so"
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSelect lua require'nvim-treesitter.textobjects.select'.commands.TSTextobjectSelect['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoPreviousEnd lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoPreviousEnd['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoPreviousStart lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoPreviousStart['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoNextEnd lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoNextEnd['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoNextStart lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoNextStart['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinT lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinT['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltint lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltint['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinF lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinF['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinf lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinf['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMovePrevious lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMovePrevious['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMoveNext lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMoveNext['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMoveOpposite lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMoveOpposite['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMove lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMove['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSwapNext lua require'nvim-treesitter.textobjects.swap'.commands.TSTextobjectSwapNext['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSwapPrevious lua require'nvim-treesitter.textobjects.swap'.commands.TSTextobjectSwapPrevious['run<bang>'](<f-args>)
line 3: command! -bar -nargs=+ -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectPeekDefinitionCode lua require'nvim-treesitter.textobjects.lsp_interop'.commands.TSTextobjectPeekDefinitionCode['run<bang>'](<f-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim"
line 1: call llama#init()
Searching for "autoload/llama.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/llama.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/llama.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim"
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim"
line 1: " vim: ts=4 sts=4 expandtab
line 2: " colors (adjust to your liking)
line 3: highlight llama_hl_hint guifg=#ff772f ctermfg=202
line 4: highlight llama_hl_info guifg=#77ff2f ctermfg=119
line 5: 
line 6: " general parameters:
line 7: "
line 8: "   endpoint:         llama.cpp server endpoint
line 9: "   api_key:          llama.cpp server api key (optional)
line 10: "   n_prefix:         number of lines before the cursor location to include in the local prefix
line 11: "   n_suffix:         number of lines after  the cursor location to include in the local suffix
line 12: "   n_predict:        max number of tokens to predict
line 13: "   t_max_prompt_ms:  max alloted time for the prompt processing (TODO: not yet supported)
line 14: "   t_max_predict_ms: max alloted time for the prediction
line 15: "   show_info:        show extra info about the inference (0 - disabled, 1 - statusline, 2 - inline)
line 16: "   auto_fim:         trigger FIM completion automatically on cursor movement
line 17: "   max_line_suffix:  do not auto-trigger FIM completion if there are more than this number of characters to the right of the cursor
line 18: "   max_cache_keys:   max number of cached completions to keep in result_cache
line 19: "
line 20: " ring buffer of chunks, accumulated with time upon:
line 21: "
line 22: "  - completion request
line 23: "  - yank
line 24: "  - entering a buffer
line 25: "  - leaving a buffer
line 26: "  - writing a file
line 27: "
line 28: " parameters for the ring-buffer with extra context:
line 29: "
line 30: "   ring_n_chunks:    max number of chunks to pass as extra context to the server (0 to disable)
line 31: "   ring_chunk_size:  max size of the chunks (in number of lines)
line 32: "                     note: adjust these numbers so that you don't overrun your context
line 33: "                           at ring_n_chunks = 64 and ring_chunk_size = 64 you need ~32k context
line 34: "   ring_scope:       the range around the cursor position (in number of lines) for gathering chunks after FIM
line 35: "   ring_update_ms:   how often to process queued chunks in normal mode
line 36: "
line 37: let s:default_config = { 'endpoint':         'http://127.0.0.1:8012/infill', 'api_key':          '', 'n_prefix':         256, 'n_suffix':         64, 'n_predict':        128, 't_max_prompt_ms':  500, 't_max_predict_ms': 500, 'show_info':        2, 'auto_fim':         v:true, 'max_line_suffix':  8, 'max_cache_keys':   250, 'ring_n_chunks':    16, 'ring_chunk_size':  64, 'ring_scope':       1024, 'ring_update_ms':   1000, }
line 54: 
line 55: let llama_config = get(g:, 'llama_config', s:default_config)
line 56: let g:llama_config = extendnew(s:default_config, llama_config, 'force')
line 57: 
line 58: let g:result_cache = {}
line 59: 
line 60: function! s:get_indent(str)
line 71: 
line 72: function! s:rand(i0, i1) abort
line 75: 
line 76: let s:llama_enabled = v:true
line 77: 
line 78: function! llama#disable()
line 83: 
line 84: function! llama#toggle()
line 92: 
line 93: function llama#setup_commands()
line 98: 
line 99: function! llama#init()
line 183: 
line 184: " compute how similar two chunks of text are
line 185: " 0 - no similarity, 1 - high similarity
line 186: " TODO: figure out something better
line 187: function! s:chunk_sim(c0, c1)
line 204: 
line 205: " pick a random chunk of size g:llama_config.ring_chunk_size from the provided text and queue it for processing
line 206: "
line 207: " no_mod   - do not pick chunks from buffers with pending changes
line 208: " do_evict - evict chunks that are very similar to the new one
line 209: "
line 210: function! s:pick_chunk(text, no_mod, do_evict)
line 291: 
line 292: " picks a queued chunk, sends it for processing and adds it to s:ring_chunks
line 293: " called every g:llama_config.ring_update_ms
line 294: function! s:ring_update()
line 365: 
line 366: " necessary for 'inoremap <expr>'
line 367: function! llama#fim_inline(is_auto, cache) abort
line 371: 
line 372: " the main FIM call
line 373: " takes local context around the cursor and sends it together with the extra context to the server for completion
line 374: function! llama#fim(is_auto, cache) abort
line 568: 
line 569: " if accept_type == 'full', accept entire response
line 570: " if accept_type == 'line', accept only the first line of the response
line 571: " if accept_type == 'word', accept only the first word of the response
line 572: function! llama#fim_accept(accept_type)
line 607: 
line 608: function! llama#fim_cancel()
line 627: 
line 628: function! s:on_move()
line 633: 
line 634: " TODO: Currently the cache uses a random eviction policy. A more clever policy could be implemented (eg. LRU).
line 635: function! s:insert_cache(key, value)
line 646: 
line 647: " callback that processes the FIM result from the server and displays the suggestion
line 648: function! s:fim_on_stdout(hash, cache, pos_x, pos_y, is_auto, job_id, data, event = v:null)
line 894: 
line 895: function! s:fim_on_exit(job_id, exit_code, event = v:null)
finished sourcing /Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim
continuing in /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
calling llama#init()

line 1:     if !executable('curl')
line 2:         echohl WarningMsg
line 3:         echo 'llama.vim requires the "curl" command to be available'
line 4:         echohl None
line 5:         return
line 6:     endif
line 7: 
line 8:     call llama#setup_commands()
calling llama#setup_commands()

line 1:     command! LlamaEnable call llama#init()
line 2:     command! LlamaDisable call llama#disable()
line 3:     command! LlamaToggle call llama#toggle()
llama#setup_commands returning #0

continuing in llama#init

line 9: 
line 10:     let s:pos_x = 0 " cursor position upon start of completion
line 11:     let s:pos_y = 0
line 12: 
line 13:     let s:line_cur = ''
line 14: 
line 15:     let s:line_cur_prefix = ''
line 16:     let s:line_cur_suffix = ''
line 17: 
line 18:     let s:ring_chunks = [] " current set of chunks used as extra context
line 19:     let s:ring_queued = [] " chunks that are queued to be sent for processing
line 20:     let s:ring_n_evict = 0
line 21: 
line 22:     let s:hint_shown = v:false
line 23:     let s:pos_y_pick = -9999 " last y where we picked a chunk
line 24:     let s:pos_dx = 0
line 25:     let s:content = []
line 26:     let s:can_accept = v:false
line 27: 
line 28:     let s:timer_fim = -1
line 29:     let s:t_fim_start = reltime() " used to measure total FIM time
line 30:     let s:t_last_move = reltime() " last time the cursor moved
line 31: 
line 32:     let s:current_job = v:null
line 33:     let s:job_error = 0
line 34: 
line 35:     let s:ghost_text_nvim = exists('*nvim_buf_get_mark')
line 36:     let s:ghost_text_vim = has('textprop')
line 37: 
line 38:     if s:ghost_text_vim
line 39:         if version < 901
line 40:             echom 'Warning: llama.vim requires version 901 or greater. Current version: ' . version
line 41:         endif
line 42:         let s:hlgroup_hint = 'llama_hl_hint'
line 43:         let s:hlgroup_info = 'llama_hl_info'
line 44: 
line 45:         if empty(prop_type_get(s:hlgroup_hint))
line 46:             call prop_type_add(s:hlgroup_hint, {'highlight': s:hlgroup_hint})
line 47:         endif
line 48:         if empty(prop_type_get(s:hlgroup_info))
line 49:             call prop_type_add(s:hlgroup_info, {'highlight': s:hlgroup_info})
line 50:         endif
line 51:     endif
line 52: 
line 53:     augroup llama
line 54:         autocmd!
line 55:         autocmd InsertEnter     * inoremap <expr> <silent> <C-F> llama#fim_inline(v:false, v:false)
line 56:         autocmd InsertLeavePre  * call llama#fim_cancel()
line 57: 
line 58:         autocmd CursorMoved     * call s:on_move()
line 59:         autocmd CursorMovedI    * call s:on_move()
line 60:         autocmd CompleteChanged * call llama#fim_cancel()
line 61: 
line 62:         if g:llama_config.auto_fim
line 63:             autocmd CursorMovedI * call llama#fim(v:true, v:true)
line 64:         endif
line 65: 
line 66:         " gather chunks upon yanking
line 67:         autocmd TextYankPost    * if v:event.operator ==# 'y' | call s:pick_chunk(v:event.regcontents, v:false, v:true) | endif
line 68: 
line 69:         " gather chunks upon entering/leaving a buffer
line 70:         autocmd BufEnter        * call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
line 71:         autocmd BufLeave        * call                      s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)
line 72: 
line 73:         " gather chunk upon saving the file
line 74:         autocmd BufWritePost    * call s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)
line 75:     augroup END
line 76: 
line 77:     silent! call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in llama#init

line 78: 
line 79:     " init background update of the ring buffer
line 80:     if g:llama_config.ring_n_chunks > 0
line 81:         call s:ring_update()
calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in llama#init

line 82:     endif
llama#init returning #0

continuing in /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim

finished sourcing /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2025 Feb 28
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.bz3,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo,*.lz4 setlocal bin
line 24: 
line 25:   " Use "gzip -d" and similar commands, gunzip isn't always available.
line 26:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 27:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.bz3 call gzip#read("bzip3 -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.lz4 call gzip#read("lz4 -d -q --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 35:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 36:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 37: 
line 38:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 39:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 40:   autocmd BufWritePost,FileWritePost^I*.bz3 call gzip#write("bzip3")
line 41:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 42:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 43:   autocmd BufWritePost,FileWritePost^I*.lz4  call gzip#write("lz4 -q --rm")
line 44:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 45:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 46:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 47:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 48:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 49: 
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 52:   autocmd FileAppendPre^I^I^I*.bz3 call gzip#appre("bzip3 -d")
line 53:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 54:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 55:   autocmd FileAppendPre^I^I^I*.lz4 call gzip#appre("lz4 -d -q --rm")
line 56:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 57:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 58:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 59:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 60:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 61: 
line 62:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 63:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 64:   autocmd FileAppendPost^I^I*.bz3 call gzip#write("bzip3")
line 65:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 66:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 67:   autocmd FileAppendPost^I^I*.lz4 call gzip#write("lz4 --rm")
line 68:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 69:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 70:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 71:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 72:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 73: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim"
line 1: " Nvim: load the matchit plugin by default.
line 2: if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
line 3:   packadd matchit
Searching for "pack/*/start/matchit" in "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/*/start/matchit"
not found in 'packpath': "pack/*/start/matchit"
Searching for "pack/*/opt/matchit" in "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/*/opt/matchit"
line 3: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim"
line 1: "  matchit.vim: (global plugin) Extended "%" matching
line 2: "  Maintainer:  Christian Brabandt
line 3: "  Version:     1.20
line 4: "  Last Change: 2024 May 20
line 5: "  Repository:  https://github.com/chrisbra/matchit
line 6: "  Previous URL:http://www.vim.org/script.php?script_id=39
line 7: "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
line 8: 
line 9: " Documentation:
line 10: "  The documentation is in a separate file: ../doc/matchit.txt
line 11: 
line 12: " Credits:
line 13: "  Vim editor by Bram Moolenaar (Thanks, Bram!)
line 14: "  Original script and design by Raul Segura Acevedo
line 15: "  Support for comments by Douglas Potts
line 16: "  Support for back references and other improvements by Benji Fisher
line 17: "  Support for many languages by Johannes Zellner
line 18: "  Suggestions for improvement, bug reports, and support for additional
line 19: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
line 20: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
line 21: 
line 22: " Debugging:
line 23: "  If you'd like to try the built-in debugging commands...
line 24: "   :MatchDebug      to activate debugging for the current buffer
line 25: "  This saves the values of several key script variables as buffer-local
line 26: "  variables.  See the MatchDebug() function, below, for details.
line 27: 
line 28: " TODO:  I should think about multi-line patterns for b:match_words.
line 29: "   This would require an option:  how many lines to scan (default 1).
line 30: "   This would be useful for Python, maybe also for *ML.
line 31: " TODO:  Maybe I should add a menu so that people will actually use some of
line 32: "   the features that I have implemented.
line 33: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
line 34: "   Match_wrapper() instead.
line 35: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
line 36: " TODO:  Make backrefs safer by using '\V' (very no-magic).
line 37: " TODO:  Add a level of indirection, so that custom % scripts can use my
line 38: "   work but extend it.
line 39: 
line 40: " Allow user to prevent loading and prevent duplicate loading.
line 41: if exists("g:loaded_matchit") || &cp
line 42:   finish
line 43: endif
line 44: let g:loaded_matchit = 1
line 45: 
line 46: let s:save_cpo = &cpo
line 47: set cpo&vim
line 48: 
line 49: fun MatchEnable()
line 89: 
line 90: fun MatchDisable()
line 108: 
line 109: " Call this function to turn on debugging information.  Every time the main
line 110: " script is run, buffer variables will be saved.  These can be used directly
line 111: " or viewed using the menu items below.
line 112: if !exists(":MatchDebug")
line 113:   command! -nargs=0 MatchDebug call matchit#Match_debug()
line 114: endif
line 115: if !exists(":MatchDisable")
line 116:   command! -nargs=0 MatchDisable :call MatchDisable()
line 117: endif
line 118: if !exists(":MatchEnable")
line 119:   command! -nargs=0 MatchEnable :call MatchEnable()
line 120: endif
line 121: 
line 122: call MatchEnable()
calling MatchEnable()

line 1:   nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
line 2:   nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
line 3:   xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
line 5:   xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
line 6:   onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
line 7:   onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
line 8: 
line 9:   " Analogues of [{ and ]} using matching patterns:
line 10:   nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
line 11:   nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
line 12:   xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
line 13:   xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
line 14:   onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
line 15:   onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
line 16: 
line 17:   " text object:
line 18:   xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
line 19: 
line 20:   if !exists("g:no_plugin_maps")
line 21:     nmap <silent> %  <Plug>(MatchitNormalForward)
line 22:     nmap <silent> g% <Plug>(MatchitNormalBackward)
line 23:     xmap <silent> %  <Plug>(MatchitVisualForward)
line 24:     xmap <silent> g% <Plug>(MatchitVisualBackward)
line 25:     omap <silent> %  <Plug>(MatchitOperationForward)
line 26:     omap <silent> g% <Plug>(MatchitOperationBackward)
line 27: 
line 28:     " Analogues of [{ and ]} using matching patterns:
line 29:     nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
line 30:     nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
line 31:     xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
line 32:     xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
line 33:     omap <silent> [% <Plug>(MatchitOperationMultiBackward)
line 34:     omap <silent> ]% <Plug>(MatchitOperationMultiForward)
line 35: 
line 36:     " Text object
line 37:     xmap a% <Plug>(MatchitVisualTextObject)
line 38:   endif
MatchEnable returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim

line 123: 
line 124: let &cpo = s:save_cpo
line 125: unlet s:save_cpo
line 126: 
line 127: " vim:sts=2:sw=2:et:
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
line 3: augroup filetypedetect
line 3: augroup END
line 4: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2025 Mar 14
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: " - Vim has no support for :defer
line 10: if exists("g:loaded_matchparen") || &cp || exists(":defer") != 2
line 12:   finish
line 13: endif
line 14: let g:loaded_matchparen = 1
line 15: 
line 16: if !exists("g:matchparen_timeout")
line 17:   let g:matchparen_timeout = 300
line 18: endif
line 19: if !exists("g:matchparen_insert_timeout")
line 20:   let g:matchparen_insert_timeout = 60
line 21: endif
line 22: if !exists("g:matchparen_disable_cursor_hl")
line 23:   let g:matchparen_disable_cursor_hl = 0
line 24: endif
line 25: 
line 26: augroup matchparen
line 27:   " Replace all matchparen autocommands
line 28:   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 29:   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
line 30:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 31:   autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 32:   autocmd! TextChangedP * call s:Remove_Matches()
line 33: augroup END
line 34: 
line 35: " Skip the rest if it was already done.
line 36: if exists("*s:Highlight_Matching_Pair")
line 37:   finish
line 38: endif
line 39: 
line 40: let s:cpo_save = &cpo
line 41: set cpo-=C
line 42: 
line 43: " The function that is invoked (very often) to define a ":match" highlighting
line 44: " for any matching paren.
line 45: func s:Highlight_Matching_Pair()
line 202: 
line 203: func s:Remove_Matches()
line 211: 
line 212: " Define commands that will disable and enable the plugin.
line 213: command DoMatchParen call s:DoMatchParen()
line 214: command NoMatchParen call s:NoMatchParen()
line 215: 
line 216: func s:NoMatchParen()
line 223: 
line 224: func s:DoMatchParen()
line 230: 
line 231: let &cpo = s:cpo_save
line 232: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim"
line 1: " Load the netrw package.
line 2: 
line 3: if &cp || exists("g:loaded_netrw") || exists("g:loaded_netrwPlugin")
line 4:   finish
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim"
line 1: if exists('g:loaded_remote_plugins')
line 2:   finish
line 3: endif
line 4: let g:loaded_remote_plugins = '/path/to/manifest'
line 5: 
line 6: " Get the path to the rplugin manifest file.
line 7: function! s:GetManifestPath() abort
line 26: 
line 27: " Old manifest file based on known script locations.
line 28: function! s:GetOldManifestPaths() abort
line 43: 
line 44: function! s:GetManifest() abort
line 57: 
line 58: function! s:LoadRemotePlugins() abort
line 64: 
line 65: command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
line 66: 
line 67: if index(v:argv, "--clean") < 0
line 68:   call s:LoadRemotePlugins()
calling <SNR>74_LoadRemotePlugins()

line 1:   let g:loaded_remote_plugins = s:GetManifest()
calling <SNR>74_GetManifest()

line 1:   let manifest = s:GetManifestPath()
calling <SNR>74_GetManifestPath()

line 1:   let manifest_base = ''
line 2: 
line 3:   if exists('$NVIM_RPLUGIN_MANIFEST')
line 4:     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
line 5:   endif
line 6: 
line 7:   let dest = stdpath('data')
line 8:   if !empty(dest)
line 9:     if !isdirectory(dest)
line 10:       if getftype(dest) != "link"
line 11:         call mkdir(dest, 'p', 0700)
line 12:       endif
line 13:     endif
line 14:     let manifest_base = dest
line 15:   endif
line 16: 
line 17:   return manifest_base.'/rplugin.vim'
<SNR>74_GetManifestPath returning '/Users/joe/.local/share/nvim/rplugin.vim'

continuing in <SNR>74_GetManifest

line 2:   if !filereadable(manifest)
line 3:     " Check if an old manifest file exists and move it to the new location.
line 4:     for old_manifest in s:GetOldManifestPaths()
calling <SNR>74_GetOldManifestPaths()

line 1:   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
line 4:   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
line 6:   if !has('win32')
line 7:     return [origpath]
<SNR>74_GetOldManifestPaths returning ['/Users/joe/.config/nvim/.init.lua-rplugin~']

continuing in <SNR>74_GetManifest

line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 4:     for old_manifest in s:GetOldManifestPaths()
line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 10:   endif
line 11:   return manifest
<SNR>74_GetManifest returning '/Users/joe/.local/share/nvim/rplugin.vim'

continuing in <SNR>74_LoadRemotePlugins

line 2:   if filereadable(g:loaded_remote_plugins)
line 3:     execute 'source' fnameescape(g:loaded_remote_plugins)
line 4:   endif
<SNR>74_LoadRemotePlugins returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim

line 69: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim"
line 1: if exists('g:loaded_shada_plugin')
line 2:   finish
line 3: endif
line 4: let g:loaded_shada_plugin = 1
line 5: 
line 6: augroup ShaDaCommands
line 7:   autocmd!
line 8:   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b'))) |setlocal filetype=shada
line 12:   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
line 15:   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |if writefile(shada#get_binstrings(getline(1, '$')),expand('<afile>'), 'b') == 0 |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))? 0: stridx(&cpoptions, '+') != -1) |endif
line 23:   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'b')
line 30:   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'ab')
line 37:   autocmd SourceCmd *.shada,*.shada.tmp.[a-z] :execute 'rshada' fnameescape(expand('<afile>'))
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: 
line 3: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 4:   finish
line 5: endif
line 6: let loaded_spellfile_plugin = 1
line 7: 
line 8: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: "
line 3: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 4: " Modified by Charles E. Campbell
line 5: " Distributed under the GNU General Public License.
line 6: "
line 7: " Updates are available from <http://michael.toren.net/code/>.  If you
line 8: " find this script useful, or have suggestions for improvements, please
line 9: " let me know.
line 10: " Also look there for further comments and documentation.
line 11: "
line 12: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 13: " ---------------------------------------------------------------------
line 14: "  Load Once: {{{1
line 15: if &cp || exists("g:loaded_tarPlugin")
line 16:  finish
line 17: endif
line 18: let g:loaded_tarPlugin = "v32"
line 19: let s:keepcpo          = &cpo
line 20: set cpo&vim
line 21: 
line 22: " ---------------------------------------------------------------------
line 23: "  Public Interface: {{{1
line 24: augroup tar
line 25:   au!
line 26:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 27:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 28:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 30: 
line 31:   if has("unix")
line 32:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 33:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 34:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 36:   endif
line 37: 
line 38:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.bz3^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tar.lz4^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^I^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 49:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 50:   au BufReadCmd   *.tlz4^I^Icall tar#Browse(expand("<amatch>"))
line 51:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 52:   au BufReadCmd   *.tzst^I^Icall tar#Browse(expand("<amatch>"))
line 53: augroup END
line 54: 
line 55: " ---------------------------------------------------------------------
line 56: " Restoration And Modelines: {{{1
line 57: " vim: fdm=marker
line 58: let &cpo= s:keepcpo
line 59: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim"
line 1: if exists('g:loaded_tutor_mode_plugin') || &compatible
line 2:     finish
line 3: endif
line 4: let g:loaded_tutor_mode_plugin = 1
line 5: 
line 6: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 5: " Former Maintainer:^ICharles E Campbell
line 6: " License:^I^IVim License  (see vim's :help license)
line 7: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 8: "               Permission is hereby granted to use and distribute this code,
line 9: "               with or without modifications, provided that this copyright
line 10: "               notice is copied with it. Like anything else that's free,
line 11: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 12: "               of any kind, either expressed or implied. By using this
line 13: "               plugin, you agree that in no event will the copyright
line 14: "               holder be liable for any damages resulting from the use
line 15: "               of this software.
line 16: "
line 17: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 18: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 19: " ---------------------------------------------------------------------
line 20: " Load Once: {{{1
line 21: if &cp || exists("g:loaded_zipPlugin")
line 22:  finish
line 23: endif
line 24: let g:loaded_zipPlugin = "v33"
line 25: let s:keepcpo          = &cpo
line 26: set cpo&vim
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Options: {{{1
line 30: if !exists("g:zipPlugin_ext")
line 31:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 32: endif
line 33: 
line 34: " ---------------------------------------------------------------------
line 35: " Public Interface: {{{1
line 36: augroup zip
line 37:  au!
line 38:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 39:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 40:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 42: 
line 43:  if has("unix")
line 44:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 45:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 46:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 48:  endif
line 49: 
line 50:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 50: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 51: augroup END
line 52: 
line 53: " ---------------------------------------------------------------------
line 54: "  Restoration And Modelines: {{{1
line 55: "  vim: fdm=marker
line 56: let &cpo= s:keepcpo
line 57: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
Executing User Autocommands for "LazyDone"
autocommand <Lua 76: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:183>

Executing: 
finished sourcing /Users/joe/.config/nvim/init.lua
Searching for "filetype.lua filetype.vim" in runtime path
Searching for "/Users/joe/.config/nvim/filetype.lua"
Searching for "/Users/joe/.config/nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/filetype.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/filetype.lua"
Searching for "/Users/joe/git/joe-p/fetch.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/filetype.vim"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/filetype.lua"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/filetype.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in runtime path
Searching for "/Users/joe/.config/nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/syntax/synload.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/syntax/synload.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim"
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Line continuation is used here, remove 'C' from 'cpoptions'
line 19: let s:cpo_save = &cpo
line 20: set cpo&vim
line 21: 
line 22: " First remove all old syntax autocommands.
line 23: au! Syntax
line 24: 
line 25: au Syntax *^I^Icall s:SynSet()
line 26: 
line 27: fun! s:SynSet()
line 58: 
line 59: 
line 60: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 61: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 66: 
line 67: 
line 68: " Source the user-specified syntax highlighting file
line 69: if exists("mysyntaxfile")
line 70:   let s:fname = expand(mysyntaxfile)
line 71:   if filereadable(s:fname)
line 72:     execute "source " . fnameescape(s:fname)
line 73:   endif
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected
line 32: " unless treesitter highlighting is enabled.
line 33: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 34: augroup syntaxset
line 35:   au! FileType *^Iif !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
line 36: augroup END
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim
Reading ShaDa file "/Users/joe/.local/state/nvim/shada/main.shada" info marks oldfiles
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 210: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1308>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 491: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufWinEnter Autocommands for "*"
autocommand silent! normal! g`"zv

Executing: silent! normal! g`"zv
Executing BufEnter Autocommands for "*"
autocommand <Lua 204: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 224: ~/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua:37>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 209: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1278>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 108: ~/.local/share/nvim/lazy/stickybuf.nvim/lua/stickybuf.lua:237>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})

Executing: call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
Executing BufEnter Autocommands for "*"
autocommand <Lua 392: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 451: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 490: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 69: vim/_defaults.lua:0>

Executing: 
autocommand <Lua 70: vim/_defaults.lua:0>

Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 100: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: source /Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim"
line 1: command! -nargs=* TodoQuickFix lua require("todo-comments.search").setqflist(<q-args>)
line 2: command! -nargs=* TodoLocList lua require("todo-comments.search").setloclist(<q-args>)
line 3: command! -nargs=* TodoTelescope Telescope todo-comments todo <args>
line 4: command! -nargs=* TodoFzfLua lua require("todo-comments.fzf").todo() <args>
line 5: command! -nargs=* TodoTrouble Trouble todo <args>
finished sourcing /Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
continuing in nvim_exec2() called at VimEnter Autocommands for "*":0
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup END
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgTODO guibg=#8cf8f7 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgTODO guibg=NONE guifg=#8cf8f7 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignTODO guibg=NONE guifg=#8cf8f7 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgFIX guibg=#ffc0b9 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgFIX guibg=NONE guifg=#ffc0b9 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignFIX guibg=NONE guifg=#ffc0b9 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgNOTE guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgNOTE guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignNOTE guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgTEST guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgTEST guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignTEST guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgWARN guibg=#fce094 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgWARN guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignWARN guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgHACK guibg=#fce094 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgHACK guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignHACK guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgPERF guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgPERF guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignPERF guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup Todo
line 2:         autocmd!
line 3:         autocmd BufWinEnter,WinNew * lua require("todo-comments.highlight").attach()
line 4:         autocmd WinScrolled * lua require("todo-comments.highlight").highlight_win()
line 5:         autocmd ColorScheme * lua vim.defer_fn(require("todo-comments.config").colors, 10)
line 6:       augroup end
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 261: ~/.local/share/nvim/lazy/mason-tool-installer.nvim/lua/mason-tool-installer/init.lua:267>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand call vimade#Load()

Executing: call vimade#Load()
Searching for "autoload/vimade.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/autoload/vimade.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim"
line 0: sourcing "/Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim"
line 1: let g:vimade_loaded = 1
line 2: function! vimade#Load()
line 5: 
line 6: function! vimade#Empty()
line 8: 
line 9: function! vimade#CreateGlobals()
line 29: 
line 30: function! vimade#SetupRenderer()
line 58: 
line 59: function! vimade#SetupPython()
line 78: 
line 79: function! vimade#SetupPythonFeatures()
line 84: 
line 85: function! vimade#GetFeatures()
line 138: 
line 139: function! vimade#GetDefaults()
line 359: 
line 360: function! vimade#Enable()
line 369: 
line 370: function! vimade#WinEnable()
line 376: 
line 377: function! vimade#WinDisable()
line 381: 
line 382: function! vimade#BufEnable()
line 388: 
line 389: function! vimade#BufDisable()
line 393: 
line 394: function! vimade#Disable()
line 403: 
line 404: function! vimade#UnhighlightAll()
line 410: 
line 411: function! vimade#Toggle()
line 419: 
line 420: function! vimade#Override(name)
line 423: 
line 424: function! vimade#OverrideFolded()
line 427: 
line 428: function! vimade#OverrideSignColumn()
line 431: 
line 432: function! vimade#OverrideLineNr()
line 435: 
line 436: function! vimade#OverrideVertSplit()
line 439: 
line 440: function! vimade#OverrideEndOfBuffer()
line 443: 
line 444: function! vimade#OverrideNonText()
line 447: 
line 448: function! vimade#OverrideAll()
line 456: 
line 457: function! vimade#Pause()
line 460: 
line 461: function! vimade#Unpause()
line 464: 
line 465: function! vimade#FocusGained()
line 474: 
line 475: function! vimade#FocusLost()
line 482: 
line 483: function! vimade#InvalidateSigns()
line 493: 
line 494: function! vimade#Recalculate()
line 499: 
line 500: function! vimade#Redraw()
line 509: 
line 510: function! vimade#GetSigns (bufnr, rows)
line 521: 
line 522: function! vimade#GetInfo()
line 546: 
line 547: function! vimade#FadeLevel(level)
line 551: 
line 552: function! vimade#FadePriority(priority)
line 556: 
line 557: function! vimade#DeferredCheckWindows()
line 569: 
line 570: function! vimade#DeferredTick(num)
line 574: 
line 575: function! vimade#CheckWindows()
line 587: 
line 588: function! vimade#StartAnimationTimer()
line 598: 
line 599: function! vimade#DoAnimations(val)
line 606: 
line 607: function! vimade#softInvalidateBuffer(bufnr)
line 618: 
line 619: function! vimade#UpdateEvents()
line 639: 
line 640: function! vimade#ExtendState()
line 647: 
line 648: function! vimade#GetMaybeFromOverlay(field)
line 655: 
line 656: function! vimade#UpdateState()
line 692: 
line 693: function! vimade#Tick(num)
line 709: 
line 710: function! vimade#FadeActive()
line 716: 
line 717: function! vimade#UnfadeActive()
line 723: 
line 724: function! vimade#GetNvimHi(id)
line 733: 
line 734: function! vimade#GetHi(id)
line 739: 
line 740: function! vimade#GetVisibleRows(startRow, endRow)
line 757: 
line 758: function! vimade#StartTimer()
line 766: function! vimade#StopTimer()
line 772: 
line 773: function! vimade#Init()
line 806: 
line 807: " Variables
line 808: let g:vimade_eval_ret = []
line 809: let g:vimade_active_renderer = 0
line 810: let g:vimade_python_setup = 0
line 811: 
line 812: "Empty Renderer START
line 813: let s:empty_renderer = { 'name': 'empty', 'getInfo': function('vimade#Empty'), 'recalculate': function('vimade#Empty'), 'redraw': function('vimade#Empty'), 'disable': function('vimade#Empty'), 'unhighlightAll': function('vimade#Empty'), 'update': function('vimade#Empty'), 'softInvalidateBuffer': function('vimade#Empty'), 'softInvalidateSigns': function('vimade#Empty'), }
line 824: "Empty Renderer END
line 825: "
line 826: let g:vimade_active_renderer = s:empty_renderer 
line 827: 
line 828: 
line 829: function! s:Recalculate_Lua()
line 832: function! s:Redraw_Lua()
line 835: function! s:Disable_Lua()
line 838: function! s:UnhighlightAll_Lua()
line 841: function! s:Update_Lua()
line 844: function! s:Animate_Lua()
line 847: function! s:SoftInvalidateBuffer_Lua()
line 850: function! s:SoftInvalidateSigns_Lua()
line 853: function! s:GetInfo_Lua()
line 856: let s:lua_renderer = { 'name': 'lua', 'animate': function('s:Animate_Lua'), 'getInfo': function('s:GetInfo_Lua'), 'recalculate': function('s:Recalculate_Lua'), 'redraw': function('s:Redraw_Lua'), 'disable': function('s:Disable_Lua'), 'unhighlightAll': function('s:UnhighlightAll_Lua'), 'update': function('s:Update_Lua'), 'softInvalidateBuffer': function('s:SoftInvalidateBuffer_Lua'), 'softInvalidateSigns': function('s:SoftInvalidateSigns_Lua'), }
line 868: " Lua Renderer END
line 869: 
line 870: " Python Renderer START
line 871: function! s:GetInfo_Python()
line 874: function! s:Recalculate_Python()
line 877: function! s:Redraw_Python()
line 881: function! s:Disable_Python()
line 884: function! s:UnhighlightAll_Python()
line 887: function! s:Update_Python()
line 890: function! s:Animate_Python()
line 893: function! s:SoftInvalidateBuffer_Python()
line 896: function! s:SoftInvalidateSigns_Python()
line 899: let s:python_renderer = { 'name': 'python', 'animate': function('s:Animate_Python'), 'getInfo': function('s:GetInfo_Python'), 'recalculate': function('s:Recalculate_Python'), 'redraw': function('s:Redraw_Python'), 'disable': function('s:Disable_Python'), 'unhighlightAll': function('s:UnhighlightAll_Python'), 'update': function('s:Update_Python'), 'softInvalidateBuffer': function('s:SoftInvalidateBuffer_Python'), 'softInvalidateSigns': function('s:SoftInvalidateSigns_Python'), }
line 911: " Python Renderer END
line 912: 
line 913: call vimade#Init()
calling vimade#Init()

line 1:   let l:already_running = 0
line 2:   if exists('g:vimade_init')
line 3:     let l:already_running = 1
line 4:   endif
line 5:   let g:vimade_init = 1
line 6:   call vimade#CreateGlobals()
calling vimade#CreateGlobals()

line 1:   "let g:vimade_lua_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'lua'
line 2:   "let g:vimade_py_v2_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'python-v2'
line 3: 
line 4:   if !exists('g:vimade_running')
line 5:     ""@setting vimade_running
line 6:     "This flag is used to control whether or not vimade should be running.  This can be useful to toggle vimade during startup.  Alternatively, you may as also use VimadeDisable, VimadeEnable, call vimade#Disable, call vimade#Enable respectively
line 7: 
line 8:     let g:vimade_running = 1
line 9:   endif
line 10:   let g:vimade_paused = 0
line 11:   let g:vimade_error_count = 0
line 12:   let g:vimade_fade_active = 0
line 13:   if !exists('g:vimade')
line 14:     let g:vimade = {}
line 15:   endif
line 16:   if !exists('g:vimade_overlay')
line 17:     let g:vimade_overlay = {}
line 18:   endif
vimade#CreateGlobals returning #0

continuing in vimade#Init

line 7:   call vimade#GetFeatures()
calling vimade#GetFeatures()

line 1:   if !exists('g:vimade_features')
line 2:     let g:vimade_features = {}
line 3:     let g:vimade_features.has_gui_running = has('gui_running')
line 4:     let g:vimade_features.has_gui = has('gui')
line 5:     let g:vimade_features.has_nvim = has('nvim')
line 6:     let g:vimade_features.has_vimr = has('gui_vimr')
line 7:     let g:vimade_features.has_timer_start = exists('*timer_start')
line 8:     let g:vimade_features.has_sign_getplaced = exists('*sign_getplaced')
line 9: 
line 10:     if g:vimade_features.has_nvim
line 11:       " Below are for lua renderer
line 12: 
line 13:       " Required:
line 14:       " Required: nvim_win_set_hl_ns
line 15:       let g:vimade_features.has_nvim_win_set_hl_ns = exists('*nvim_win_set_hl_ns')
line 16:       " Required:
line 17:       " Either (preferred) nvim_get_hl
line 18:       let g:vimade_features.has_nvim_get_hl = exists('*nvim_get_hl')
line 19:       " Or (fallback) nvim__get_hl_defs + nvim_get_hl_by_name (assume supported)
line 20:       let g:vimade_features.has__nvim_get_hl_defs = exists('*nvim__get_hl_defs')
line 21:       
line 22:       "Optional:
line 23:       " preferred but not required nvim_get_hl_ns
line 24:       " fallback is try and manually track (probably will have conflicts with some plugins)
line 25:       let g:vimade_features.has_nvim_get_hl_ns = exists('*nvim_get_hl_ns')
line 26: 
line 27:       let g:vimade_features.supports_lua_renderer = (g:vimade_features.has_nvim_get_hl || g:vimade_features.has__nvim_get_hl_defs) && g:vimade_features.has_nvim_win_set_hl_ns
line 28:       let g:vimade_features.has_wincolor = 0
line 29:       let g:vimade_features.has_gui_version = 0
line 30:     else
line 31:       let g:vimade_features.has_nvim_win_set_hl_ns = 0
line 32:       let g:vimade_features.has_nvim_get_hl = 0
line 33:       let g:vimade_features.has__nvim_get_hl_defs = 0
line 34:       let g:vimade_features.has_nvim_get_hl_ns = 0
line 35:       let g:vimade_features.supports_lua_renderer = 0
line 36:       let g:vimade_features.has_wincolor = exists('&wincolor')
line 37:       let g:vimade_features.has_gui_version = execute('version')=~"GUI version"
line 38:     endif
line 39: 
line 40:     try
line 41:       sign define Vimade_Test text=1
line 42:       sign place 1 group=vimade line=1 name=Vimade_Test priority=100
line 43:       sign unplace 1 group=vimade
line 44:       let g:vimade_features.has_sign_group = 1
line 45:       let g:vimade_features.has_sign_priority = 1
line 46:     catch
line 47:       let g:vimade_features.has_sign_group = 0
line 48:       let g:vimade_features.has_sign_priority = 0
line 49:     endtry
line 50:   endif
line 51:   return g:vimade_features
vimade#GetFeatures returning {'has_sign_getplaced': 1, 'has_gui_run..._set_hl_ns': 1, 'has_sign_priority': 1}

continuing in vimade#Init

line 8:   call vimade#GetDefaults()
calling vimade#GetDefaults()

line 1:   if !exists('g:vimade_defaults')
line 2: 
line 3:     ""The vimade configuration object
line 4:     "@setting vimade
line 5:     
line 6:     let g:vimade_defaults = {'$extended': 1}
line 7: 
line 8:     ""@setting vimade.renderer
line 9:     "Select the renderer to use for vimade window/buffer highlights.
line 10:     "If not specificed, defaults to 'auto'. It is recommended to leave this
line 11:     "option set to 'auto', 'lua', or 'python'.
line 12:     "Current options are:
line 13:     "  - 'auto' - Uses lua renderer if supported on your Neovim version. Otherwise, this option will automatically fallback to 'python'.
line 14:     "  - 'python' - Uses a new high performance renderer compatible with Vim and Neovim
line 15: 
line 16:     let g:vimade_defaults.renderer = 'auto'
line 17: 
line 18:     ""@setting vimade.fadelevel
line 19:     "Supported:     lua, python
line 20:     "Amount of fading applied between text and basebg.  0 will make the text the same color as the background and 1 applies no fading.  The default value is 0.4.  If you are using terminal, you may need to tweak this value to get better results.
line 21: 
line 22:     let g:vimade_defaults.fadelevel = 0.4
line 23:     
line 24:     ""@setting vimade.tint
line 25:     "Supported:     lua, python
line 26:     "Amount and type of tinting to apply. Unset by default.  This param is currently under maintainence. This function can currently be either a config object such as:
line 27:     "{'fg':{'rgb':[255,0,0], 'intensity': 0.5, 'type': 'MIX'}, 'bg':{'rgb':[255,0,0], 'type': 'REPLACE'}, 'sp': {'rgb':[255,0,0], 'type': 'MIX'}}
line 28:     "The fields in the object are completely optional (you can peform a bg-only or fg-only tint)
line 29:     "You can also set g:vimade.tint to a lua or python function that returns the tint object.
line 30:     "Lua
line 31:     "require('vimade').setup({
line 32:     " tint = function (win)
line 33:     "   return {
line 34:     "    fg = {
line 35:     "      rgb={255,0,0},
line 36:     "      intensity = 0.75,
line 37:     "    },
line 38:     "  }
line 39:     " end
line 40:     "})
line 41:     "Python
line 42:     "from vimade.v2 import vimade
line 43:     "vimade.setup({
line 44:     " 'tint': lambda a,test : {'fg':{'rgb':[255,0,0], 'intensity': 0.5}}
line 45:     "})
line 46: 
line 47:     ""@setting vimade.basebg
line 48:     "Supported:     lua, python
line 49:     "basebg can be either be six digit hexidecimal color, rgb array [0-255,0-255,0-255], or cterm code (in terminal).  basebg is used as the color that text is faded against.  You can override this config with another hexidecimal color.  A cool feature of basebg is to use it to change the tint of faded text even if its not your background!
line 50: 
line 51:     let g:vimade_defaults.basebg = ''
line 52: 
line 53:     ""@setting vimade.ncmode
line 54:     "Supported:     lua, python
line 55:     "Whether to fade active windows or buffers.  Options are 'windows' or 'buffers'.  Defaults to 'buffers'.
line 56: 
line 57:     let g:vimade_defaults.ncmode = 'buffers'
line 58: 
line 59:     ""@setting vimade.fadecondition
line 60:     "Supported:     lua, python
line 61:     "TODO docs
line 62: 
line 63:     "Can be set via vim object
line 64:     ""@setting vimade.blocklist
line 65:     "Supported:     lua, python
line 66:     "TODO docs
line 67: 
line 68:     ""@setting vimade.link
line 69:     "Supported:     lua, python
line 70:     "Controls whether or not diffs will fade/unfade together.
line 71:     "TODO docs
line 72: 
line 73: 
line 74:     ""@setting vimade.groupdiff
line 75:     "Supported:     lua, python
line 76:     "Controls whether or not diffs will fade/unfade together.  If you want diffs
line 77:     "to be treated separately, set this value to 0. Default is 1
line 78: 
line 79:     let g:vimade_defaults.groupdiff = 1
line 80: 
line 81:     ""@setting vimade.groupscrollbind
line 82:     "Supported:     lua, python
line 83:     "Controls whether or not scrollbound windows will fade/unfade together.  If
line 84:     "you want scrollbound windows to unfade together, set this to 1.  Default is
line 85:     "0.
line 86:     
line 87:     let g:vimade_defaults.groupscrollbind = 0
line 88: 
line 89:     ""@setting vimade.enablefocusfading
line 90:     "Supported:     lua, python
line 91:     "Fades the current active window on focus blur and unfades when focus gained.
line 92:     "This can be desirable when switching applications or TMUX splits.
line 93:     "* Install 'tmux-plugins/vim-tmux-focus-events' using your preferred plugin manager
line 94:     "* Add `set -g focus-events on` to your tmux.conf
line 95:     "* Neovim should work at this point, If you are using Vim you may also need the following snippet to the very end of your vimrc
line 96:     ">
line 97:     "  if has('gui_running') == 0 && has('nvim') == 0
line 98:     "     call feedkeys(":silent execute '!' | redraw!\<CR>")
line 99:     "  endif
line 100:     "<
line 101: 
line 102:     let g:vimade_defaults.enablefocusfading = 0
line 103:    
line 104:     ""@setting vimade.normalid
line 105:     "Supported:     lua, python
line 106:     "If not specified, the normalid is determined when vimade is first loaded.  normalid provides the id of the "Normal" highlight which is used to calculate fading.  You can override this config with another highlight group.
line 107:     "You shouldn't really ever need to modify this.
line 108: 
line 109:     let g:vimade_defaults.normalid = ''
line 110: 
line 111:     ""@setting vimade.normalncid
line 112:     "Supported:     lua, python
line 113:     "If not specified, the normalncid is determined when vimade is first loaded.  normalncid provides the id of the "NormalNC" highlight which is used to calculate fading for inactive buffers in NVIM.  You can override this config with another highlight group.
line 114:     "You shouldn't really ever need to modify this.
line 115: 
line 116:     let g:vimade_defaults.normalncid = ''
line 117: 
line 118:     ""@setting vimade.checkinterval
line 119:     "Supported:     lua, python
line 120:     "The amount of time in milliseconds that vimade should check the screen for changes.  This config is mainly used to detect resize and scroll changes that occur on inactive windows. Checkinterval does nothing on gvim, if you want to control the refresh time, see 'h updatetime'. Default is 1000.  
line 121: 
line 122:     let g:vimade_defaults.checkinterval = 1000
line 123: 
line 124:     ""@setting vimade.usecursorhold
line 125:     "Supported:     lua, python
line 126:     "Disables the timer running in the background and instead relies `OnCursorHold` and `updatetime` (see h:updatetime).  The default value is `0` except on older Windows GVIM, which defaults to `1` due to the timer breaking movements.  If you find that the timer is causing performance problems or other issues you can disable it by setting this option to `1`. 
line 127: 
line 128:     let g:vimade_defaults.usecursorhold = g:vimade_features.has_gui_running && !g:vimade_features.has_nvim && g:vimade_features.has_gui_version
line 129: 
line 130:     ""@setting vimade.basegroups
line 131:     "Supported:     python
line 132:     "lua uses namespaces and doesn't require this setting.
line 133:     "Neovim only setting that specifies the basegroups/built-in highlight groups that will be faded using winhl when switching windows
line 134: 
line 135:     let g:vimade_defaults.basegroups = ['Folded', 'Search', 'SignColumn', 'CursorLine', 'CursorLineNr', 'DiffAdd', 'DiffChange', 'DiffDelete', 'DiffText', 'FoldColumn', 'Whitespace', 'NonText', 'SpecialKey', 'Conceal', 'EndOfBuffer', 'WinSeparator', 'LineNr', 'LineNrAbove', 'LineNrBelow']
line 136: 
line 137:     ""@setting vimade.enablebasegroups
line 138:     "Supported:     python
line 139:     "lua uses namespaces and doesn't require this setting.
line 140:     "Neovim only setting.  Enabled by default and allows basegroups/built-in highlight fading using winhl.  This allows fading of built-in highlights such as Folded, Search, etc.
line 141: 
line 142:     let g:vimade_defaults.enablebasegroups = 1
line 143: 
line 144: 
line 145:     ""@setting vimade.enabletreesitter
line 146:     "Supported:     python
line 147:     "lua uses namespaces and doesn't require this setting.
line 148:     "Neovim only setting.  Disabled by default and hooks vimade into the internals of treesitter.
line 149: 
line 150:     let g:vimade_defaults.enabletreesitter = 0
line 151: 
line 152:     ""@setting vimade.enablesigns
line 153:     "Supported:     python
line 154:     "lua renderer doesn't require additional logic to fade signs.
line 155:     "Enabled by default for vim/nvim versions that support sign priority and causes signs to be faded when switching buffers.
line 156:     "Only visible signs are faded. This feature can cause performance issues
line 157:     "on older nvim/vim versions that don't support sign priority. 
line 158:     "Use signsretentionperiod to control the duration that vimade checks for sign updates after switching buffers.
line 159: 
line 160:     let g:vimade_defaults.enablesigns = g:vimade_features.has_sign_priority
line 161: 
line 162:     ""@setting vimade.signsid
line 163:     "Supported:     python
line 164:     "lua renderer doesn't require additional logic to fade signs.
line 165:     "The starting id that Vimade should use when creating new signs. By
line 166:     "default Vim requires numeric values to create signs and its possible that
line 167:     "collisions may occur between plugins.  If you need to override this value for
line 168:     "compatibility, please open an issue as well.  Default is 13100.
line 169: 
line 170:     let g:vimade_defaults.signsid = 13100
line 171: 
line 172:     ""@setting vimade.signsretentionperiod
line 173:     "Supported:     python
line 174:     "lua renderer doesn't require additional logic to fade signs.
line 175:     " *python*: Serves no purpose on lua renderer.
line 176:     "Amount of time in milliseconds that faded buffers should be tracked for sign changes.  Default value is 4000.
line 177: 
line 178:     let g:vimade_defaults.signsretentionperiod = 4000
line 179: 
line 180:     ""@setting vimade.signspriority
line 181:     "Supported:     python
line 182:     "lua renderer doesn't require additional logic to fade signs.
line 183:     "Controls the signs fade priority.
line 184:     "You may need to change this value if you find that not all signs are fading properly.
line 185:     "Please also open a defect if you need to tweak this value as Vimade strives to minimize manual configuration where possible.
line 186:     "Default is 31.
line 187: 
line 188:     let g:vimade_defaults.signspriority = 31
line 189: 
line 190:     ""@setting vimade.fademinimap
line 191:     "Supported:     lua, python
line 192:     "Enables fading for `severin-lemaignan/vim-minimap`. Setting vimade.fademinimap to
line 193:     "0 disables the special fade.  Default is 1.
line 194: 
line 195:     let g:vimade_defaults.fademinimap = 1
line 196: 
line 197:     ""@setting vimade.fadepriority
line 198:     "Supported:     python
line 199:     "lua uses namespaces and doesn't require priority settings
line 200:     "Controls the highlighting priority.
line 201:     "You may want to tweak this value to make Vimade play nicely with other highlighting plugins and behaviors.
line 202:     "For example, if you want hlsearch to show results on all buffers, you may want to lower this value to 0.
line 203:     "Default is 10.
line 204: 
line 205:     let g:vimade_defaults.fadepriority = 10
line 206: 
line 207:     ""@setting vimade.disablebatch
line 208:     "Supported:     python
line 209:     "Disables interprocess batching. Useful if you are seeing issues and need to debug an error.
line 210: 
line 211:     let g:vimade_defaults.disablebatch = 0
line 212: 
line 213:     let g:vimade_defaults_keys = keys(g:vimade_defaults)
line 214:     if exists('g:vimade_usecursorhold')
line 215:       let g:vimade.usecursorhold = g:vimade_usecursorhold
line 216:     endif
line 217:   endif
line 218:   return g:vimade_defaults
vimade#GetDefaults returning {'ncmode': 'buffers', 'enablesigns': 1...focusfading': 0, 'checkinterval': 1000}

continuing in vimade#Init

line 9:   call vimade#ExtendState()
calling vimade#ExtendState()

line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
vimade#ExtendState returning #0

continuing in vimade#Init

line 10:   call vimade#UpdateEvents()
calling vimade#UpdateEvents()

line 1:   augroup vimade
line 2:       au!
line 3:       au VimLeave * call vimade#Disable()
line 4:       au FocusGained * call vimade#FocusGained()
line 5:       au FocusLost * call vimade#FocusLost()
line 6:       " TODO neovim is broken in many scenarios in v0.10. Python logic is not
line 7:       " executed properly when called directly off and autoevent. This is
line 8:       " easily reproduceable when using netrw...
line 9:       au WinEnter,BufEnter * call vimade#DeferredCheckWindows()
line 10:       au OptionSet diff call vimade#DeferredCheckWindows()
line 11:       au ColorScheme * call vimade#Redraw()
line 12:       au FileChangedShellPost * call vimade#softInvalidateBuffer(expand("<abuf>"))
line 13:       let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateEvents

line 14:       if usecursorhold
line 15:         au CursorHold,CursorHoldI * call vimade#DeferredCheckWindows()
line 16:         au VimResized * call vimade#DeferredCheckWindows()
line 17:       endif
line 18:   augroup END
vimade#UpdateEvents returning #0

continuing in vimade#Init

line 11: 
line 12:   let g:vimade_last = extend({}, g:vimade)
line 13: 
line 14:   "check immediately
line 15:   if l:already_running == 0
line 16:     call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
line 6:     endif
line 7:     let g:vimade_deferred_timer = timer_start(1, 'vimade#DeferredTick')
line 8:   else
line 9:     return vimade#CheckWindows()
line 10:   endif
vimade#DeferredCheckWindows returning #0

continuing in vimade#Init

line 17:   else
line 18:     call vimade#Redraw()
line 19:   endif
line 20:   call vimade#StartTimer()
calling vimade#StartTimer()

line 1:   "timer is disabled when usecursorhold=1
line 2:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#StartTimer

line 3:   if !usecursorhold && !exists('g:vimade_timer') && g:vimade_running
line 4:     let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#StartTimer

line 5:     let g:vimade_timer = timer_start(checkinterval, 'vimade#Tick', {'repeat': -1})
line 6:   endif
vimade#StartTimer returning #0

continuing in vimade#Init

line 21: 
line 22:   "run the timer once during startup
line 23:   "we use try here to possibly support vim 7
line 24:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#Init

line 25:   if usecursorhold
line 26:     let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
line 27:     try
line 28:       call timer_start(checkinterval, 'vimade#Tick')
line 29:     catch
line 30:     endtry
line 31:   endif
vimade#Init returning #0

continuing in /Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim

finished sourcing /Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim
continuing in VimEnter Autocommands for "*"
calling vimade#Load()

line 1:   " empty hook to initiate loading
vimade#Load returning #0

continuing in VimEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand <Lua 399: vim/_editor.lua:0>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 485: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:381>

Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: silent %bw!
Executing BufDelete Autocommands for "*"
autocommand <Lua 459: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:226>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 218: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1373>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 489: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 224: ~/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua:37>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 209: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1278>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 108: ~/.local/share/nvim/lazy/stickybuf.nvim/lua/stickybuf.lua:237>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})

Executing: call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
Executing BufEnter Autocommands for "*"
autocommand <Lua 392: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 451: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 490: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call vimade#DeferredCheckWindows()

Executing: call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
vimade#DeferredCheckWindows returning #0

continuing in BufEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand <Lua 210: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1308>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 491: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufWinEnter Autocommands for "*"
autocommand silent! normal! g`"zv

Executing: silent! normal! g`"zv
Executing BufWinEnter Autocommands for "*"
autocommand lua require("todo-comments.highlight").attach()

Executing: lua require("todo-comments.highlight").attach()
line 1: unlet! b:keymap_name
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: silent clearjumps
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: silent source /Users/joe/.local/share/nvim/sessions/\%2FUsers\%2Fjoe\%2Fgit\%2Fjoe-p\%2Ffetch\%2Envim.vim
line 1: sourcing "/Users/joe/.local/share/nvim/sessions/%2FUsers%2Fjoe%2Fgit%2Fjoe-p%2Ffetch%2Envim.vim"
line 1: let SessionLoad = 1
line 2: let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
line 2:  let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
line 2:  setg so=0 siso=0 | setl so=-1 siso=-1
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 2:  setl so=-1 siso=-1
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 3: let v:this_session=expand("<sfile>:p")
line 4: silent only
line 5: silent tabonly
Already only one tab page
line 6: cd ~/git/joe-p/fetch.nvim
[global] /Users/joe/git/joe-p/fetch.nvim
line 7: if expand('%') == '' && !&modified && line('$') <= 1 && getline(1) == ''
line 8:   let s:wipebuf = bufnr('%')
line 9: endif
line 10: let s:shortmess_save = &shortmess
line 11: if &shortmess =~ 'A'
line 12:   set shortmess=aoOA
line 13: else
line 14:   set shortmess=aoO
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 15: endif
line 16: badd +1 out.log
Executing BufAdd Autocommands for "*"
autocommand <Lua 218: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1373>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 489: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
line 17: argglobal
line 18: %argdel
line 19: edit out.log
Executing BufLeave Autocommands for "*"
autocommand <Lua 202: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1264>

Executing: 
Executing BufLeave Autocommands for "*"
autocommand call                      s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)

Executing: call                      s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)
calling <SNR>51_pick_chunk([''], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
<SNR>51_pick_chunk returning #0

continuing in BufLeave Autocommands for "*"

Executing BufLeave Autocommands for "*"
autocommand <Lua 460: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing BufLeave Autocommands for "*"
autocommand call s:Remove_Matches()

Executing: call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in BufLeave Autocommands for "*"

Found a swap file that is not useful, deleting it
Executing BufReadPre Autocommands for "*"
autocommand <Lua 104: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at BufReadPre Autocommands for "*":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at BufReadPre Autocommands for "*":0
continuing in BufReadPre Autocommands for "*"
line 0: sourcing "nvim_exec2() called at BufReadPre Autocommands for "*":0"
line 1: augroup END
finished sourcing nvim_exec2() called at BufReadPre Autocommands for "*":0
continuing in BufReadPre Autocommands for "*"
Executing: 
Executing BufReadPre Autocommands for "*"
autocommand <Lua 207: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
"out.log" [noeol] 11482L, 541974B
Reading ShaDa file "/Users/joe/.local/state/nvim/shada/main.shada" marks
Reading undo file: /Users/joe/.local/state/nvim/undo/%Users%joe%git%joe-p%fetch.nvim%out.log
Executing BufReadPost Autocommands for "*"
autocommand <Lua 187: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:10>

Executing: 
autocommand if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif

Executing: if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif
Executing:  runtime! scripts.vim | endif
Searching for "scripts.vim" in runtime path
Searching for "/Users/joe/.config/nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/scripts.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/scripts.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/scripts.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/scripts.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/scripts.vim"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/scripts.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/scripts.vim"
not found in runtime path: "scripts.vim"
Executing:  endif
Executing BufReadPost Autocommands for "*"
autocommand <Lua 206: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif

Executing: if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
Executing:  exe s:AutoInit() | endif
calling <SNR>19_AutoInit()

line 1:   return s:Init(1, 1, 1, 1)
calling <SNR>19_Init(1, 1, 1, 1)

line 1:   if !a:redetect && exists('b:sleuth.defaults')
line 2:     let detected = b:sleuth
line 3:   endif
line 4:   unlet! b:sleuth
line 5:   if &l:buftype !~# '^\%(nowrite\|nofile\|acwrite\)\=$'
line 6:     return s:Warn(':Sleuth disabled for buftype=' . &l:buftype, a:silent)
line 7:   endif
line 8:   if &l:filetype ==# 'netrw'
line 9:     return s:Warn(':Sleuth disabled for filetype=' . &l:filetype, a:silent)
line 10:   endif
line 11:   if &l:binary
line 12:     return s:Warn(':Sleuth disabled for binary files', a:silent)
line 13:   endif
line 14:   if !exists('detected')
line 15:     let detected = s:DetectDeclared()
calling <SNR>19_DetectDeclared()

line 1:   let detected = {'bufname': s:Slash(@%), 'declared': {}}
calling <SNR>19_Slash('out.log')

line 1:     return a:path
<SNR>19_Slash returning 'out.log'

continuing in <SNR>19_DetectDeclared

line 2:   let absolute_or_empty = detected.bufname =~# '^$\|^\a\+:\|^/'
line 3:   if &l:buftype =~# '^\%(nowrite\)\=$' && !absolute_or_empty
line 4:     let detected.bufname = substitute(s:Slash(getcwd()), '/\=$', '/', '') . detected.bufname
calling <SNR>19_Slash('/Users/joe/git/joe-p/fetch.nvim')

line 1:     return a:path
<SNR>19_Slash returning '/Users/joe/git/joe-p/fetch.nvim'

continuing in <SNR>19_DetectDeclared

line 5:     let absolute_or_empty = 1
line 6:   endif
line 7:   let detected.path = absolute_or_empty ? detected.bufname : ''
line 8:   let pre = substitute(matchstr(detected.path, '^\a\a\+\ze:'), '^\a', '\u&', 'g')
line 9:   if len(pre) && exists('*' . pre . 'Real')
line 10:     let detected.path = s:Slash(call(pre . 'Real', [detected.path]))
line 11:   endif
line 12: 
line 13:   try
line 14:     if len(detected.path) && exists('*ExcludeBufferFromDiscovery') && !empty(ExcludeBufferFromDiscovery(detected.path, 'sleuth'))
line 15:       let detected.path = ''
line 16:     endif
line 17:   catch
line 18:   endtry
line 19:   let [detected.editorconfig, detected.root] = s:DetectEditorConfig(detected.path)
calling <SNR>19_DetectEditorConfig('/Users/joe/git/joe-p/fetch.nvim/out.log')

line 1:   if empty(a:absolute_path)
line 2:     return [{}, '']
line 3:   endif
line 4:   let root = ''
line 5:   let tail = a:0 ? a:1 : '.editorconfig'
line 6:   let dir = fnamemodify(a:absolute_path, ':h')
line 7:   let previous_dir = ''
line 8:   let sections = []
line 9:   let overrides = get(g:, 'sleuth_editorconfig_overrides', {})
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 34: 
line 35:   let config = {}
line 36:   for [pattern, pairs] in sections
line 37:     if a:absolute_path =~# pattern
line 38:       call extend(config, pairs)
line 39:     endif
line 40:   endfor
line 41: 
line 42:   return [config, root]
<SNR>19_DetectEditorConfig returning [{}, '']

continuing in <SNR>19_DetectDeclared

line 20:   call extend(detected.declared, s:EditorConfigToOptions(detected.editorconfig))
calling <SNR>19_EditorConfigToOptions({})

line 1:   let options = {}
line 2:   let pairs = map(copy(a:pairs), 'v:val[0]')
line 3:   let sources = map(copy(a:pairs), 'v:val[1:-1]')
line 4:   call filter(pairs, 'v:val !=? "unset"')
line 5: 
line 6:   if get(pairs, 'indent_style', '') ==? 'tab'
line 7:     let options.expandtab = [0] + sources.indent_style
line 8:   elseif get(pairs, 'indent_style', '') ==? 'space'
line 9:     let options.expandtab = [1] + sources.indent_style
line 10:   endif
line 11: 
line 12:   if get(pairs, 'indent_size', '') =~? '^[1-9]\d*$\|^tab$'
line 13:     let options.shiftwidth = [str2nr(pairs.indent_size)] + sources.indent_size
line 14:     if &g:shiftwidth == 0 && !has_key(pairs, 'tab_width') && pairs.indent_size !=? 'tab'
line 15:       let options.tabstop = options.shiftwidth
line 16:       let options.shiftwidth = [0] + sources.indent_size
line 17:     endif
line 18:   endif
line 19: 
line 20:   if get(pairs, 'tab_width', '') =~? '^[1-9]\d*$'
line 21:     let options.tabstop = [str2nr(pairs.tab_width)] + sources.tab_width
line 22:     if !has_key(pairs, 'indent_size') && get(pairs, 'indent_style', '') ==? 'tab'
line 23:       let options.shiftwidth = [0] + options.tabstop[1:-1]
line 24:     endif
line 25:   endif
line 26: 
line 27:   if get(pairs, 'max_line_length', '') =~? '^[1-9]\d*$\|^off$'
line 28:     let options.textwidth = [str2nr(pairs.max_line_length)] + sources.max_line_length
line 29:   endif
line 30: 
line 31:   if get(pairs, 'insert_final_newline', '') =~? '^true$\|^false$'
line 32:     let options.endofline = [pairs.insert_final_newline ==? 'true'] + sources.insert_final_newline
line 33:     let options.fixendofline = copy(options.endofline)
line 34:   endif
line 35: 
line 36:   let eol = tolower(get(pairs, 'end_of_line', ''))
line 37:   if has_key(s:editorconfig_fileformat, eol)
line 38:     let options.fileformat = [s:editorconfig_fileformat[eol]] + sources.end_of_line
line 39:   endif
line 40: 
line 41:   let charset = tolower(get(pairs, 'charset', ''))
line 42:   if has_key(s:editorconfig_bomb, charset)
line 43:     let options.bomb = [s:editorconfig_bomb[charset]] + sources.charset
line 44:     let options.fileencoding = [substitute(charset, '\C-bom$', '', '')] + sources.charset
line 45:   endif
line 46: 
line 47:   let filetype = tolower(get(pairs, 'vim_filetype', 'unset'))
line 48:   if filetype !=# 'unset' && filetype =~# '^[.a-z0-9_-]*$'
line 49:     let options.filetype = [substitute(filetype, '^\.\+\|\.\+$', '', 'g')] + sources.vim_filetype
line 50:   endif
line 51: 
line 52:   return options
<SNR>19_EditorConfigToOptions returning {}

continuing in <SNR>19_DetectDeclared

line 21:   call extend(detected.declared, s:ModelineOptions())
calling <SNR>19_ModelineOptions()

line 1:   let options = {}
line 2:   if !&l:modeline && (&g:modeline || s:Capture('setlocal') =~# '\\\@<![[:space:]]nomodeline\>' && s:Capture('verbose setglobal modeline?') !=# s:Capture('verbose setlocal modeline?'))
line 4:     return options
line 5:   endif
line 6:   let modelines = get(b:, 'sleuth_modelines', get(g:, 'sleuth_modelines', 5))
line 7:   if line('$') > 2 * modelines
line 8:     let lnums = range(1, modelines) + range(line('$') - modelines + 1, line('$'))
line 9:   else
line 10:     let lnums = range(1, line('$'))
line 11:   endif
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 1)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 2)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 3)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 4)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 5)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 11478)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 11479)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 11480)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 11481)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>19_ParseOptions([], {}, 'modeline', 11482)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>19_ParseOptions returning #0

continuing in <SNR>19_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
line 16:       break
line 17:     endif
line 18:   endfor
line 19:   return options
<SNR>19_ModelineOptions returning {}

continuing in <SNR>19_DetectDeclared

line 22:   return detected
<SNR>19_DetectDeclared returning {'root': '', 'path': '/Users/joe/git/j...g', 'declared': {}, 'editorconfig': {}}

continuing in <SNR>19_Init

line 16:   endif
line 17:   let setfiletype = ''
line 18:   if a:do_filetype && has_key(detected.declared, 'filetype')
line 19:     let filetype = detected.declared.filetype[0]
line 20:     if filetype !=# &l:filetype || empty(filetype)
line 21:       let setfiletype = 'setlocal filetype=' . filetype
line 22:     else
line 23:       let setfiletype = 'setfiletype ' . filetype
line 24:     endif
line 25:   endif
line 26:   exe setfiletype
line 26: 
line 27:   call s:DetectHeuristics(detected)
calling <SNR>19_DetectHeuristics({'root': '', 'path': '/Users/joe/git/j...g', 'declared': {}, 'editorconfig': {}})

line 1:   let detected = a:into
line 2:   let filetype = split(&l:filetype, '\.', 1)[0]
line 3:   if get(detected, 'filetype', '*') ==# filetype
line 4:     return detected
line 5:   endif
line 6:   let detected.filetype = filetype
line 7:   let options = copy(detected.declared)
line 8:   let detected.options = options
line 9:   let detected.heuristics = {}
line 10:   if has_key(detected, 'patterns')
line 11:     call remove(detected, 'patterns')
line 12:   endif
line 13:   let detected.defaults = s:UserOptions(filetype, 'defaults')
calling <SNR>19_UserOptions('', 'defaults')

line 1:   if exists('b:sleuth_' . a:name)
line 2:     let source = 'b:sleuth_' . a:name
line 3:   elseif exists('g:sleuth_' . a:ft . '_' . a:name)
line 4:     let source = 'g:sleuth_' . a:ft . '_' . a:name
line 5:   endif
line 6:   if !exists('l:source') || type(eval(source)) == type(function('tr'))
line 7:     return {}
<SNR>19_UserOptions returning {}

continuing in <SNR>19_DetectHeuristics

line 14:   if empty(filetype) || !get(b:, 'sleuth_automatic', 1) || empty(get(b:, 'sleuth_heuristics', get(g:, 'sleuth_' . filetype . '_heuristics', get(g:, 'sleuth_heuristics', 1))))
line 15:     return detected
<SNR>19_DetectHeuristics returning {'root': '', 'options': {}, 'defaults'...{}, 'editorconfig': {}, 'filetype': ''}

continuing in <SNR>19_Init

line 28:   let cmd = s:Apply(detected, (a:do_filetype ? ['filetype'] : []) + (a:unsafe ? s:all_options : s:safe_options), a:silent)
calling <SNR>19_Apply({'root': '', 'options': {}, 'defaults'...{}, 'editorconfig': {}, 'filetype': ''}, ['filetype', 'expandtab', 'shiftwidth'..., 'fileformat', 'fileencoding', 'bomb'], 1)

line 1:   let options = extend(copy(a:detected.defaults), a:detected.options)
line 2:   if get(a:detected.defaults, 'shiftwidth', [1])[0] == 0 && get(options, 'shiftwidth', [0])[0] != 0 && !has_key(a:detected.declared, 'tabstop')
line 3:     let options.tabstop = options.shiftwidth
line 4:     let options.shiftwidth = a:detected.defaults.shiftwidth
line 5:   endif
line 6:   if has_key(options, 'shiftwidth') && !has_key(options, 'expandtab')
line 7:     let options.expandtab = [stridx(join(getline(1, 256), "\n"), "\t") == -1, a:detected.bufname]
line 8:   endif
line 9:   if !exists('*shiftwidth') && !get(options, 'shiftwidth', [1])[0]
line 10:     let options.shiftwidth = [get(options, 'tabstop', [&tabstop])[0]] + options.shiftwidth[1:-1]
line 11:   endif
line 12:   let msg = ''
line 13:   let cmd = 'setlocal'
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 18:     endif
line 19:     let value = options[option]
line 20:     if has_key(s:booleans, option)
line 21:       let setting = (value[0] ? '' : 'no') . option
line 22:     else
line 23:       let setting = option . '=' . value[0]
line 24:     endif
line 25:     if getbufvar('', '&' . option) !=# value[0] || index(s:safe_options, option) >= 0
line 26:       let cmd .= ' ' . setting
line 27:     endif
line 28:     if !&verbose || a:silent
line 29:       if has_key(s:booleans, option)
line 30:         let msg .= ' ' . (value[0] ? '' : 'no') . get(s:short_options, option, option)
line 31:       else
line 32:         let msg .= ' ' . get(s:short_options, option, option) . '=' . value[0]
line 33:       endif
line 34:       continue
line 35:     endif
line 36:     if len(value) > 1
line 37:       if value[1] ==# a:detected.bufname
line 38:         let file = '%'
line 39:       else
line 40:         let file = value[1] =~# '/' ? fnamemodify(value[1], ':~:.') : value[1]
line 41:         if file !=# value[1] && file[0:0] !=# '~'
line 42:           let file = './' . file
line 43:         endif
line 44:       endif
line 45:       if len(value) > 2
line 46:         let file .= ' line ' . value[2]
line 47:       endif
line 48:       echo printf(':setlocal %-21s " from %s', setting, file)
line 49:     else
line 50:       echo ':setlocal ' . setting
line 51:     endif
line 52:   endfor
line 53:   if !&verbose && !empty(msg) && !a:silent
line 54:     echo ':setlocal' . msg
line 55:   endif
line 56:   if has_key(options, 'shiftwidth')
line 57:     let cmd .= ' softtabstop=' . (exists('*shiftwidth') ? -1 : options.shiftwidth[0])
line 58:   else
line 59:     call s:Warn(':Sleuth failed to detect indent settings', a:silent)
calling <SNR>19_Warn(':Sleuth failed to detect indent settings', 1)

line 1:   if !get(a:000, 0, 0)
line 2:     echohl WarningMsg
line 3:     echo a:msg
line 4:     echohl NONE
line 5:   endif
line 6:   return ''
<SNR>19_Warn returning ''

continuing in <SNR>19_Apply

line 60:   endif
line 61:   return cmd ==# 'setlocal' ? '' : cmd
<SNR>19_Apply returning ''

continuing in <SNR>19_Init

line 29:   let b:sleuth = detected
line 30:   if exists('s:polyglot') && !a:silent
line 31:     call s:Warn('Charlatan :Sleuth implementation in vim-polyglot has been found and disabled.')
line 32:     call s:Warn('To get rid of this message, uninstall vim-polyglot, or disable the')
line 33:     call s:Warn('corresponding feature in your vimrc:')
line 34:     call s:Warn('        let g:polyglot_disabled = ["autoindent"]')
line 35:   endif
line 36:   return cmd
<SNR>19_Init returning ''

continuing in <SNR>19_AutoInit

<SNR>19_AutoInit returning ''

continuing in BufReadPost Autocommands for "*"

Executing: 
Executing:  endif
Executing BufReadPost Autocommands for "*"
autocommand <Lua 234: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns.lua:143>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 389: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:136>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 458: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:222>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 512: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua:4>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 224: ~/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua:37>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 209: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1278>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 108: ~/.local/share/nvim/lazy/stickybuf.nvim/lua/stickybuf.lua:237>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})

Executing: call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
Executing BufEnter Autocommands for "*"
autocommand <Lua 392: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 451: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 490: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call vimade#DeferredCheckWindows()

Executing: call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
vimade#DeferredCheckWindows returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand <Lua 542: ~/.config/nvim/lua/kickstart/plugins/lint.lua:52>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 105: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 210: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1308>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 491: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufWinEnter Autocommands for "*"
autocommand silent! normal! g`"zv

Executing: silent! normal! g`"zv
Executing BufWinEnter Autocommands for "*"
autocommand lua require("todo-comments.highlight").attach()

Executing: lua require("todo-comments.highlight").attach()
line 19: unlet! b:keymap_name
line 20: wincmd t
line 21: let s:save_winminheight = &winminheight
line 22: let s:save_winminwidth = &winminwidth
line 23: set winminheight=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 24: set winheight=1
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 25: set winminwidth=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 26: set winwidth=1
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 27: argglobal
line 28: setlocal keymap=
line 28: unlet! b:keymap_name
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 29: setlocal noarabic
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 30: setlocal autoindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 31: setlocal nobinary
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 32: setlocal breakindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 33: setlocal breakindentopt=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 34: setlocal bufhidden=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 35: setlocal buflisted
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 36: setlocal buftype=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 37: setlocal nocindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 38: setlocal cinkeys=0{,0},0),0],:,0#,!^F,o,O,e
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 39: setlocal cinoptions=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 40: setlocal cinscopedecls=public,protected,private
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 41: setlocal cinwords=if,else,while,do,for,switch
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 42: setlocal colorcolumn=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 43: setlocal comments=s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-,fb:^V<e2>^V<80>^V<a2>
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 44: setlocal commentstring=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 45: setlocal complete=.,w,b,u,t
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 46: setlocal completefunc=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 47: setlocal completeslash=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 48: setlocal concealcursor=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 49: setlocal conceallevel=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 50: setlocal nocopyindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 51: setlocal nocursorbind
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 52: setlocal nocursorcolumn
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 53: setlocal cursorline
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 54: setlocal cursorlineopt=both
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 55: setlocal nodiff
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "diff"
autocommand call vimade#DeferredCheckWindows()

Executing: call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
vimade#DeferredCheckWindows returning #0

continuing in OptionSet Autocommands for "diff"

line 56: setlocal eventignorewin=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 57: setlocal noexpandtab
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 58: if &filetype != ''
line 59: setlocal filetype=
line 60: endif
line 61: setlocal fixendofline
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 62: setlocal foldcolumn=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 63: setlocal foldenable
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 64: setlocal foldexpr=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 65: setlocal foldignore=#
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 66: setlocal foldlevel=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 67: setlocal foldmarker={{{,}}}
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 68: setlocal foldmethod=manual
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 69: setlocal foldminlines=1
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 70: setlocal foldnestmax=20
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 71: setlocal foldtext=foldtext()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 72: setlocal formatexpr=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 73: setlocal formatlistpat=^\\s*\\d\\+[\\]:.)}\\t\ ]\\s*
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 74: setlocal formatoptions=tcqj
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 75: setlocal iminsert=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 76: setlocal imsearch=-1
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 77: setlocal includeexpr=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 78: setlocal indentexpr=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 79: setlocal indentkeys=0{,0},0),0],:,0#,!^F,o,O,e
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 80: setlocal noinfercase
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 81: setlocal iskeyword=@,48-57,_,192-255
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 82: setlocal nolinebreak
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 83: setlocal nolisp
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 84: setlocal lispoptions=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 85: setlocal list
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 86: setlocal matchpairs=(:),{:},[:]
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 87: setlocal modeline
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 88: setlocal modifiable
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 89: setlocal nrformats=bin,hex
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 90: setlocal number
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 91: setlocal numberwidth=4
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 92: setlocal omnifunc=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 93: setlocal nopreserveindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 94: setlocal nopreviewwindow
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 95: setlocal quoteescape=\\
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 96: setlocal noreadonly
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 97: setlocal norelativenumber
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 98: setlocal norightleft
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 99: setlocal rightleftcmd=search
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 100: setlocal scrollback=-1
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 101: setlocal noscrollbind
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 102: setlocal shiftwidth=8
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 103: setlocal signcolumn=yes
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 104: setlocal nosmartindent
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 105: setlocal nosmoothscroll
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 106: setlocal softtabstop=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 107: setlocal nospell
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 108: setlocal spellcapcheck=[.?!]\\_[\\])'\"\\t\ ]\\+
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 109: setlocal spellfile=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 110: setlocal spelllang=en
Searching for "spell/en.*" in runtime path
Searching for "/Users/joe/.config/nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/spell/en.*"
Searching for "/Users/joe/git/joe-p/fetch.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/spell/en.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/spell/en.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/spell/en.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/spell/en.*"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/spell/en.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/spell/en.*"
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 111: setlocal spelloptions=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 112: setlocal statuscolumn=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 113: setlocal suffixesadd=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 114: setlocal swapfile
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 115: setlocal synmaxcol=3000
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 116: if &syntax != ''
line 117: setlocal syntax=
line 118: endif
line 119: setlocal tabstop=8
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 120: setlocal tagfunc=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 121: setlocal textwidth=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 122: setlocal undofile
Reading undo file: /Users/joe/.local/state/nvim/undo/%Users%joe%git%joe-p%fetch.nvim%out.log
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 123: setlocal varsofttabstop=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 124: setlocal vartabstop=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 125: setlocal winblend=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 126: setlocal nowinfixbuf
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 127: setlocal nowinfixheight
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 128: setlocal nowinfixwidth
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 129: setlocal winhighlight=
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 130: setlocal wrap
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 131: setlocal wrapmargin=0
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 132: silent! normal! zE
line 133: let &fdl = &fdl
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 134: let s:l = 1 - ((0 * winheight(0) + 32) / 64)
line 135: if s:l < 1 | let s:l = 1 | endif
line 135:  let s:l = 1 | endif
line 135:  endif
line 136: keepjumps exe s:l
line 136: 1
line 137: normal! zt
line 138: keepjumps 1
line 139: normal! 0
line 140: tabnext 1
line 141: if exists('s:wipebuf') && len(win_findbuf(s:wipebuf)) == 0 && getbufvar(s:wipebuf, '&buftype') isnot# 'terminal'
line 142:   silent exe 'bwipe ' . s:wipebuf
line 142: bwipe 1
Executing BufDelete Autocommands for "*"
autocommand <Lua 459: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:226>

Executing: 
Executing BufDelete Autocommands for "*"
autocommand <Lua 91: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufDelete Autocommands for "*"
autocommand <Lua 448: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 377: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 466: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
line 143: endif
line 144: unlet! s:wipebuf
line 145: set winheight=1 winwidth=20
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 146: let &shortmess = s:shortmess_save
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 147: let &winminheight = s:save_winminheight
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 148: let &winminwidth = s:save_winminwidth
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 149: let s:sx = expand("<sfile>:p:r")."x.vim"
line 150: if filereadable(s:sx)
line 151:   exe "source " . fnameescape(s:sx)
line 152: endif
line 153: let &g:so = s:so_save | let &g:siso = s:siso_save
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 153:  let &g:siso = s:siso_save
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 154: set hlsearch
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
line 155: nohlsearch
line 156: doautoall SessionLoadPost
Executing SessionLoadPost Autocommands for "*"
autocommand <Lua 219: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1383>

Executing: 
Executing SessionLoadPost Autocommands for "*"
autocommand <Lua 321: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline/groups.lua:244>

Executing: 
Executing SessionLoadPost Autocommands for "*"
autocommand <Lua 388: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:121>

Executing: 
line 157: unlet SessionLoad
line 158: " vim: set ft=vim :
finished sourcing /Users/joe/.local/share/nvim/sessions/%2FUsers%2Fjoe%2Fgit%2Fjoe-p%2Ffetch%2Envim.vim
continuing in nvim_exec2() called at VimEnter Autocommands for "*":0
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 74: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:327>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 205: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 517: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua:8>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 322: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:189>

Executing: 
Executing SafeState Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

sourcing "nvim_exec2()"
line 1: autocmd User CocDiagnosticChange lua require('bufferline.diagnostics').refresh_coc_diagnostics()
finished sourcing nvim_exec2()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 68: vim/_defaults.lua:0>

Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 538: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 561: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/termcap.lua:36>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 538: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
Executing ColorSchemePre Autocommands for "*"
autocommand <Lua 77: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/loader.lua:31>

Executing: 
Searching for "colors/catppuccin.*" in runtime path
Searching for "/Users/joe/.config/nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/colors/catppuccin.*"
Searching for "/Users/joe/git/joe-p/fetch.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.*"
sourcing "/Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim"
line 1: lua require("catppuccin").load()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 538: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
finished sourcing /Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim
Executing ColorScheme Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/highlight.lua:275>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 251: ~/.local/share/nvim/lazy/mini.icons/lua/mini/icons.lua:1998>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 191: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:947>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 385: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:111>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 440: ~/.local/share/nvim/lazy/mini.nvim/lua/mini/surround.lua:1229>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 444: ~/.local/share/nvim/lazy/mini.nvim/lua/mini/statusline.lua:538>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 502: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:587>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand lua vim.defer_fn(require("todo-comments.config").colors, 10)

Executing: lua vim.defer_fn(require("todo-comments.config").colors, 10)
Executing ColorScheme Autocommands for "*"
autocommand call vimade#Redraw()

Executing: call vimade#Redraw()
calling vimade#Redraw()

line 1:   "prevent if inside popup window
line 2:   if winnr() == 0
line 3:     return
line 4:   endif
line 5:   if g:vimade_running && g:vimade_paused == 0
line 6:     call g:vimade_active_renderer.redraw()
calling vimade#Empty()

vimade#Empty returning #0

continuing in vimade#Redraw

line 7:   endif
vimade#Redraw returning #0

continuing in ColorScheme Autocommands for "*"

Executing ColorScheme Autocommands for "*"
autocommand <Lua 221: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/util/init.lua:19>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 445: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:510>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 547: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:152>

Executing: 
calling vimade#DeferredTick(3)

line 1:   unlet g:vimade_deferred_timer
line 2:   call vimade#Tick(0)
calling vimade#Tick(0)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning ''

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning ''

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
calling vimade#UnhighlightAll()

line 1:   if winnr() == 0
line 2:     return
line 3:   endif
line 4:   call g:vimade_active_renderer.unhighlightAll()
calling vimade#Empty()

vimade#Empty returning #0

continuing in vimade#UnhighlightAll

vimade#UnhighlightAll returning #0

continuing in vimade#SetupRenderer

line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

continuing in vimade#DeferredTick

vimade#DeferredTick returning #0

Executing User Autocommands for "VeryLazy"
autocommand <Lua 75: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:338>

Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 126: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at User Autocommands for "VeryLazy":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at User Autocommands for "VeryLazy":0
continuing in User Autocommands for "VeryLazy"
line 0: sourcing "nvim_exec2() called at User Autocommands for "VeryLazy":0"
line 1: augroup END
finished sourcing nvim_exec2() called at User Autocommands for "VeryLazy":0
continuing in User Autocommands for "VeryLazy"
Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 190: ~/.config/nvim/lua/joe-p/plugins/snacks.lua:307>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 68: vim/_defaults.lua:0>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 561: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/termcap.lua:36>

Executing: 


--- Terminal info --- {{{
&term: xterm-256color
Description: xterm with 256 colors
Aliases: xterm-256color
Boolean capabilities:
  auto_left_margin          bw         = false
  auto_right_margin         am         = true
  no_esc_ctlc               xsb        = false
  ceol_standout_glitch      xhp        = false
  eat_newline_glitch        xenl       = true
  erase_overstrike          eo         = false
  generic_type              gn         = false
  hard_copy                 hc         = false
  has_meta_key              km         = true
  has_status_line           hs         = false
  insert_null_glitch        in         = false
  memory_above              da         = false
  memory_below              db         = false
  move_insert_mode          mir        = true
  move_standout_mode        msgr       = true
  over_strike               os         = false
  status_line_esc_ok        eslok      = false
  dest_tabs_magic_smso      xt         = false
  tilde_glitch              hz         = false
  transparent_underline     ul         = false
  xon_xoff                  xon        = false
  needs_xon_xoff            nxon       = false
  prtr_silent               mc5i       = true
  hard_cursor               chts       = false
  non_rev_rmcup             nrrmc      = false
  no_pad_char               npc        = true
  non_dest_scroll_region    ndscr      = false
  can_change                ccc        = true
  back_color_erase          bce        = true
  hue_lightness_saturation  hls        = false
  col_addr_glitch           xhpa       = false
  cr_cancels_micro_mode     crxm       = false
  has_print_wheel           daisy      = false
  row_addr_glitch           xvpa       = false
  semi_auto_right_margin    sam        = false
  cpi_changes_res           cpix       = false
  lpi_changes_res           lpix       = false
  backspaces_with_bs        OTbs       = true
  crt_no_scrolling          OTns       = false
  no_correctly_working_cr   OTnc       = false
  gnu_has_meta_key          OTMT       = false
  linefeed_is_newline       OTNL       = false
  has_hardware_tabs         OTpt       = false
  return_does_clr_eol       OTxr       = false
Numeric capabilities:
  columns                   cols       = 80
  init_tabs                 it         = 8
  lines                     lines      = 24
  lines_of_memory           lm         = -1
  magic_cookie_glitch       xmc        = -1
  padding_baud_rate         pb         = -1
  virtual_terminal          vt         = -1
  width_status_line         wsl        = -1
  num_labels                nlab       = -1
  label_height              lh         = -1
  label_width               lw         = -1
  max_attributes            ma         = -1
  maximum_windows           wnum       = -1
  max_colors                colors     = 256
  max_pairs                 pairs      = 65536
  no_color_video            ncv        = -1
  buffer_capacity           bufsz      = -1
  dot_vert_spacing          spinv      = -1
  dot_horz_spacing          spinh      = -1
  max_micro_address         maddr      = -1
  max_micro_jump            mjump      = -1
  micro_col_size            mcs        = -1
  micro_line_size           mls        = -1
  number_of_pins            npins      = -1
  output_res_char           orc        = -1
  output_res_line           orl        = -1
  output_res_horz_inch      orhi       = -1
  output_res_vert_inch      orvi       = -1
  print_rate                cps        = -1
  wide_char_size            widcs      = -1
  buttons                   btns       = -1
  bit_image_entwining       bitwin     = -1
  bit_image_type            bitype     = -1
  magic_cookie_glitch_ul    OTug       = -1
  carriage_return_delay     OTdC       = -1
  new_line_delay            OTdN       = -1
  backspace_delay           OTdB       = -1
  horizontal_tab_delay      OTdT       = -1
  number_of_function_keys   OTkn       = -1
String capabilities:
  back_tab                  cbt        = ^[[Z
  bell                      bel        = ^G
  carriage_return           cr         = ^M
  change_scroll_region      csr        = ^[[%i%p1%d;%p2%dr
  clear_all_tabs            tbc        = ^[[3g
  clear_screen              clear      = ^[[H^[[2J
  clr_eol                   el         = ^[[K
  clr_eos                   ed         = ^[[J
  column_address            hpa        = ^[[%i%p1%dG
  cursor_address            cup        = ^[[%i%p1%d;%p2%dH
  cursor_down               cud1       = ^@
  cursor_home               home       = ^[[H
  cursor_invisible          civis      = ^[[?25l
  cursor_left               cub1       = ^H
  cursor_normal             cnorm      = ^[[?25h
  cursor_right              cuf1       = ^[[C
  cursor_up                 cuu1       = ^[[A
  cursor_visible            cvvis      = ^[[?12;25h
  delete_character          dch1       = ^[[P
  delete_line               dl1        = ^[[M
  enter_alt_charset_mode    smacs      = ^[(0
  enter_blink_mode          blink      = ^[[5m
  enter_bold_mode           bold       = ^[[1m
  enter_ca_mode             smcup      = ^[[?1049h^[[22;0;0t
  enter_dim_mode            dim        = ^[[2m
  enter_insert_mode         smir       = ^[[4h
  enter_secure_mode         invis      = ^[[8m
  enter_reverse_mode        rev        = ^[[7m
  enter_standout_mode       smso       = ^[[7m
  enter_underline_mode      smul       = ^[[4m
  erase_chars               ech        = ^[[%p1%dX
  exit_alt_charset_mode     rmacs      = ^[(B
  exit_attribute_mode       sgr0       = ^[(B^[[m
  exit_ca_mode              rmcup      = ^[[?1049l^[[23;0;0t
  exit_insert_mode          rmir       = ^[[4l
  exit_standout_mode        rmso       = ^[[27m
  exit_underline_mode       rmul       = ^[[24m
  flash_screen              flash      = ^[[?5h$<100/>^[[?5l
  from_status_line          fsl        = ^G
  init_2string              is2        = ^[[!p^[[?3;4l^[[4l^[>
  insert_line               il1        = ^[[L
  key_backspace             kbs        = ^H
  key_dc                    kdch1      = ^[[3~
  key_down                  kcud1      = ^[OB
  key_f1                    kf1        = ^[OP
  key_f10                   kf10       = ^[[21~
  key_f2                    kf2        = ^[OQ
  key_f3                    kf3        = ^[OR
  key_f4                    kf4        = ^[OS
  key_f5                    kf5        = ^[[15~
  key_f6                    kf6        = ^[[17~
  key_f7                    kf7        = ^[[18~
  key_f8                    kf8        = ^[[19~
  key_f9                    kf9        = ^[[20~
  key_home                  khome      = ^[OH
  key_ic                    kich1      = ^[[2~
  key_left                  kcub1      = ^[OD
  key_npage                 knp        = ^[[6~
  key_ppage                 kpp        = ^[[5~
  key_right                 kcuf1      = ^[OC
  key_sf                    kind       = ^[[1;2B
  key_sr                    kri        = ^[[1;2A
  key_up                    kcuu1      = ^[OA
  keypad_local              rmkx       = ^[[?1l^[>
  keypad_xmit               smkx       = ^[[?1h^[=
  meta_off                  rmm        = ^[[?1034l
  meta_on                   smm        = ^[[?1034h
  newline                   nel        = ^[E
  parm_dch                  dch        = ^[[%p1%dP
  parm_delete_line          dl         = ^[[%p1%dM
  parm_down_cursor          cud        = ^[[%p1%dB
  parm_ich                  ich        = ^[[%p1%d@
  parm_index                indn       = ^[[%p1%dS
  parm_insert_line          il         = ^[[%p1%dL
  parm_left_cursor          cub        = ^[[%p1%dD
  parm_right_cursor         cuf        = ^[[%p1%dC
  parm_rindex               rin        = ^[[%p1%dT
  parm_up_cursor            cuu        = ^[[%p1%dA
  print_screen              mc0        = ^[[i
  prtr_off                  mc4        = ^[[4i
  prtr_on                   mc5        = ^[[5i
  repeat_char               rep        = %p1%c^[[%p2%{1}%-%db
  reset_1string             rs1        = ^[c^[]104^G
  reset_2string             rs2        = ^[[!p^[[?3;4l^[[4l^[>
  restore_cursor            rc         = ^[8
  row_address               vpa        = ^[[%i%p1%dd
  save_cursor               sc         = ^[7
  scroll_forward            ind        = ^@
  scroll_reverse            ri         = ^[M
  set_attributes            sgr        = %?%p9%t^[(0%e^[(B%;^[[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m
  set_tab                   hts        = ^[H
  tab                       ht         = 	
  to_status_line            tsl        = ^[]0;
  key_a1                    ka1        = ^[Ow
  key_a3                    ka3        = ^[Oy
  key_b2                    kb2        = ^[Ou
  key_c1                    kc1        = ^[Oq
  key_c3                    kc3        = ^[Os
  acs_chars                 acsc       = ``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~
  key_btab                  kcbt       = ^[[Z
  enter_am_mode             smam       = ^[[?7h
  exit_am_mode              rmam       = ^[[?7l
  key_beg                   kbeg       = ^[OE
  key_end                   kend       = ^[OF
  key_enter                 kent       = ^[OM
  key_sdc                   kDC        = ^[[3;2~
  key_send                  kEND       = ^[[1;2F
  key_shome                 kHOM       = ^[[1;2H
  key_sic                   kIC        = ^[[2;2~
  key_sleft                 kLFT       = ^[[1;2D
  key_snext                 kNXT       = ^[[6;2~
  key_sprevious             kPRV       = ^[[5;2~
  key_sright                kRIT       = ^[[1;2C
  key_f11                   kf11       = ^[[23~
  key_f12                   kf12       = ^[[24~
  key_f13                   kf13       = ^[[1;2P
  key_f14                   kf14       = ^[[1;2Q
  key_f15                   kf15       = ^[[1;2R
  key_f16                   kf16       = ^[[1;2S
  key_f17                   kf17       = ^[[15;2~
  key_f18                   kf18       = ^[[17;2~
  key_f19                   kf19       = ^[[18;2~
  key_f20                   kf20       = ^[[19;2~
  key_f21                   kf21       = ^[[20;2~
  key_f22                   kf22       = ^[[21;2~
  key_f23                   kf23       = ^[[23;2~
  key_f24                   kf24       = ^[[24;2~
  key_f25                   kf25       = ^[[1;5P
  key_f26                   kf26       = ^[[1;5Q
  key_f27                   kf27       = ^[[1;5R
  key_f28                   kf28       = ^[[1;5S
  key_f29                   kf29       = ^[[15;5~
  key_f30                   kf30       = ^[[17;5~
  key_f31                   kf31       = ^[[18;5~
  key_f32                   kf32       = ^[[19;5~
  key_f33                   kf33       = ^[[20;5~
  key_f34                   kf34       = ^[[21;5~
  key_f35                   kf35       = ^[[23;5~
  key_f36                   kf36       = ^[[24;5~
  key_f37                   kf37       = ^[[1;6P
  key_f38                   kf38       = ^[[1;6Q
  key_f39                   kf39       = ^[[1;6R
  key_f40                   kf40       = ^[[1;6S
  key_f41                   kf41       = ^[[15;6~
  key_f42                   kf42       = ^[[17;6~
  key_f43                   kf43       = ^[[18;6~
  key_f44                   kf44       = ^[[19;6~
  key_f45                   kf45       = ^[[20;6~
  key_f46                   kf46       = ^[[21;6~
  key_f47                   kf47       = ^[[23;6~
  key_f48                   kf48       = ^[[24;6~
  key_f49                   kf49       = ^[[1;3P
  key_f50                   kf50       = ^[[1;3Q
  key_f51                   kf51       = ^[[1;3R
  key_f52                   kf52       = ^[[1;3S
  key_f53                   kf53       = ^[[15;3~
  key_f54                   kf54       = ^[[17;3~
  key_f55                   kf55       = ^[[18;3~
  key_f56                   kf56       = ^[[19;3~
  key_f57                   kf57       = ^[[20;3~
  key_f58                   kf58       = ^[[21;3~
  key_f59                   kf59       = ^[[23;3~
  key_f60                   kf60       = ^[[24;3~
  key_f61                   kf61       = ^[[1;4P
  key_f62                   kf62       = ^[[1;4Q
  key_f63                   kf63       = ^[[1;4R
  clr_bol                   el1        = ^[[1K
  clear_margins             mgc        = ^[[?69l
  user6                     u6         = ^[[%i%d;%dR
  user7                     u7         = ^[[6n
  user8                     u8         = ^[[?%[;0123456789]c
  user9                     u9         = ^[[c
  orig_pair                 op         = ^[[39;49m
  orig_colors               oc         = ^[]104^G
  initialize_color          initc      = ^[]4;%p1%d;rgb:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X^[\
  enter_italics_mode        sitm       = ^[[3m
  exit_italics_mode         ritm       = ^[[23m
  key_mouse                 kmous      = ^[[<
  set_a_foreground          setaf      = ^[[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m
  set_a_background          setab      = ^[[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m
  set_tb_margin             smgtb      = ^[[%i%p1%d;%p2%dr
  memory_lock               meml       = ^[l
  memory_unlock             memu       = ^[m
Extended boolean capabilities:
  AX                        = true
  XF                        = true
  XT                        = true
Extended string capabilities:
  BD                        = ^[[?2004l
  BE                        = ^[[?2004h
  Cr                        = ^[]112^G
  Cs                        = ^[]12;%p1%s^G
  E3                        = ^[[3J
  Ms                        = ^[]52;%p1%s;%p2%s^G
  PE                        = ^[[201~
  PS                        = ^[[200~
  RV                        = ^[[>c
  Se                        = ^[[2 q
  Ss                        = ^[[%p1%d q
  XM                        = ^[[?1006;1000%?%p1%{1}%=%th%el%;
  XR                        = ^[[>0q
  fd                        = ^[[?1004l
  fe                        = ^[[?1004h
  kDC3                      = ^[[3;3~
  kDC4                      = ^[[3;4~
  kDC5                      = ^[[3;5~
  kDC6                      = ^[[3;6~
  kDC7                      = ^[[3;7~
  kDN                       = ^[[1;2B
  kDN3                      = ^[[1;3B
  kDN4                      = ^[[1;4B
  kDN5                      = ^[[1;5B
  kDN6                      = ^[[1;6B
  kDN7                      = ^[[1;7B
  kEND3                     = ^[[1;3F
  kEND4                     = ^[[1;4F
  kEND5                     = ^[[1;5F
  kEND6                     = ^[[1;6F
  kEND7                     = ^[[1;7F
  kHOM3                     = ^[[1;3H
  kHOM4                     = ^[[1;4H
  kHOM5                     = ^[[1;5H
  kHOM6                     = ^[[1;6H
  kHOM7                     = ^[[1;7H
  kIC3                      = ^[[2;3~
  kIC4                      = ^[[2;4~
  kIC5                      = ^[[2;5~
  kIC6                      = ^[[2;6~
  kIC7                      = ^[[2;7~
  kLFT3                     = ^[[1;3D
  kLFT4                     = ^[[1;4D
  kLFT5                     = ^[[1;5D
  kLFT6                     = ^[[1;6D
  kLFT7                     = ^[[1;7D
  kNXT3                     = ^[[6;3~
  kNXT4                     = ^[[6;4~
  kNXT5                     = ^[[6;5~
  kNXT6                     = ^[[6;6~
  kNXT7                     = ^[[6;7~
  kPRV3                     = ^[[5;3~
  kPRV4                     = ^[[5;4~
  kPRV5                     = ^[[5;5~
  kPRV6                     = ^[[5;6~
  kPRV7                     = ^[[5;7~
  kRIT3                     = ^[[1;3C
  kRIT4                     = ^[[1;4C
  kRIT5                     = ^[[1;5C
  kRIT6                     = ^[[1;6C
  kRIT7                     = ^[[1;7C
  kUP                       = ^[[1;2A
  kUP3                      = ^[[1;3A
  kUP4                      = ^[[1;4A
  kUP5                      = ^[[1;5A
  kUP6                      = ^[[1;6A
  kUP7                      = ^[[1;7A
  ka2                       = ^[Ox
  kb1                       = ^[Ot
  kb3                       = ^[Ov
  kc2                       = ^[Or
  kp5                       = ^[OE
  kpADD                     = ^[Ok
  kpCMA                     = ^[Ol
  kpDIV                     = ^[Oo
  kpDOT                     = ^[On
  kpMUL                     = ^[Oj
  kpSUB                     = ^[Om
  kpZRO                     = ^[Op
  kxIN                      = ^[[I
  kxOUT                     = ^[[O
  rmxx                      = ^[[29m
  rv                        = ^[\[41;[1-6][0-9][0-9];0c
  smxx                      = ^[[9m
  xm                        = ^[[<%i%p3%d;%p1%d;%p2%d;%?%p4%tM%em%;
  xr                        = ^[P>\|XTerm\([1-9][0-9]+\)^[\\
  ext.resize_screen         = ^[[8;%p1%d;%p2%dt
  ext.reset_scroll_region   = ^[[r
  ext.enter_altfont_mode    = ^[[11m
  setrgbf                   = ^[[38;2;%p1%d;%p2%d;%p3%dm
  setrgbb                   = ^[[48;2;%p1%d;%p2%d;%p3%dm
  ext.save_title            = ^[[22;0t
  ext.restore_title         = ^[[23;0t
  ext.set_title             = ^[]0;%p2%s^G
  ext.enable_lr_margin      = ^[[?69h
  ext.disable_lr_margin     = ^[[?69l
  ext.enable_bpaste         = ^[[?2004h
  ext.disable_bpaste        = ^[[?2004l
  ext.enable_focus          = ^[[?1004h
  ext.disable_focus         = ^[[?1004l
  ext.enable_mouse          = ^[[?1002h^[[?1006h
  ext.disable_mouse         = ^[[?1002l^[[?1006l
  ext.enable_mouse_move     = ^[[?1003h
  ext.disable_mouse_move    = ^[[?1003l
  ext.set_underline_style   = ^[[4:%p1%dm
  ext.set_underline_color   = ^[[58:2::%p1%d:%p2%d:%p3%dm
  Sync                      = ^[[?2026%?%p1%{1}%-%tl%eh%;
}}}

sourcing "nvim_exec2()"
line 1: hi def TodoBgTODO guibg=#91d7e3 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgTODO guibg=NONE guifg=#91d7e3 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignTODO guibg=NONE guifg=#91d7e3 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgFIX guibg=#ed8796 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgFIX guibg=NONE guifg=#ed8796 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignFIX guibg=NONE guifg=#ed8796 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgNOTE guibg=#8bd5ca guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgNOTE guibg=NONE guifg=#8bd5ca gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignNOTE guibg=NONE guifg=#8bd5ca gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgTEST guibg=#f0c6c6 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgTEST guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignTEST guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgWARN guibg=#eed49f guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgWARN guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignWARN guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgHACK guibg=#eed49f guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgHACK guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignHACK guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgPERF guibg=#f0c6c6 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgPERF guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignPERF guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
calling <lambda>2(2)

calling <SNR>51_pick_chunk(['', 'sourcing "nvim_exec2()"', 'line ...d_load_ftplugin")', 'line 8:   finish'], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
line 4:     endif
line 5: 
line 6:     " if the extra context option is disabled - do nothing
line 7:     if g:llama_config.ring_n_chunks <= 0
line 8:         return
line 9:     endif
line 10: 
line 11:     " don't pick very small chunks
line 12:     if len(a:text) < 3
line 13:         return
line 14:     endif
line 15: 
line 16:     if len(a:text) + 1 < g:llama_config.ring_chunk_size
line 17:         let l:chunk = a:text
line 18:     else
line 19:         let l:l0 = s:rand(0, max([0, len(a:text) - g:llama_config.ring_chunk_size/2]))
line 20:         let l:l1 = min([l:l0 + g:llama_config.ring_chunk_size/2, len(a:text)])
line 21: 
line 22:         let l:chunk = a:text[l:l0:l:l1]
line 23:     endif
line 24: 
line 25:     let l:chunk_str = join(l:chunk, "\n") . "\n"
line 26: 
line 27:     " check if this chunk is already added
line 28:     let l:exist = v:false
line 29: 
line 30:     for i in range(len(s:ring_chunks))
line 31:         if s:ring_chunks[i].data == l:chunk
line 32:             let l:exist = v:true
line 33:             break
line 34:         endif
line 35:     endfor
line 36: 
line 37:     for i in range(len(s:ring_queued))
line 38:         if s:ring_queued[i].data == l:chunk
line 39:             let l:exist = v:true
line 40:             break
line 41:         endif
line 42:     endfor
line 43: 
line 44:     if l:exist
line 45:         return
line 46:     endif
line 47: 
line 48:     " evict queued chunks that are very similar to the new one
line 49:     for i in range(len(s:ring_queued) - 1, 0, -1)
line 50:         if s:chunk_sim(s:ring_queued[i].data, l:chunk) > 0.9
line 51:             if a:do_evict
line 52:                 call remove(s:ring_queued, i)
line 53:                 let s:ring_n_evict += 1
line 54:             else
line 55:                 return
line 56:             endif
line 57:         endif
line 58:     endfor
line 59: 
line 60:     " also from s:ring_chunks
line 61:     for i in range(len(s:ring_chunks) - 1, 0, -1)
line 62:         if s:chunk_sim(s:ring_chunks[i].data, l:chunk) > 0.9
line 63:             if a:do_evict
line 64:                 call remove(s:ring_chunks, i)
line 65:                 let s:ring_n_evict += 1
line 66:             else
line 67:                 return
line 68:             endif
line 69:         endif
line 70:     endfor
line 71: 
line 72:     " TODO: become parameter ?
line 73:     if len(s:ring_queued) == 16
line 74:         call remove(s:ring_queued, 0)
line 75:     endif
line 76: 
line 77:     call add(s:ring_queued, {'data': l:chunk, 'str': l:chunk_str, 'time': reltime(), 'filename': expand('%')})
line 78: 
line 79:     "let &statusline = 'extra context: ' . len(s:ring_chunks) . ' / ' . len(s:ring_queued)
<SNR>51_pick_chunk returning #0

continuing in <lambda>2

<lambda>2 returning #0

calling <lambda>3(5)

calling <SNR>51_pick_chunk(['', 'sourcing "nvim_exec2()"', 'line ...d_load_ftplugin")', 'line 8:   finish'], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
line 4:     endif
line 5: 
line 6:     " if the extra context option is disabled - do nothing
line 7:     if g:llama_config.ring_n_chunks <= 0
line 8:         return
line 9:     endif
line 10: 
line 11:     " don't pick very small chunks
line 12:     if len(a:text) < 3
line 13:         return
line 14:     endif
line 15: 
line 16:     if len(a:text) + 1 < g:llama_config.ring_chunk_size
line 17:         let l:chunk = a:text
line 18:     else
line 19:         let l:l0 = s:rand(0, max([0, len(a:text) - g:llama_config.ring_chunk_size/2]))
line 20:         let l:l1 = min([l:l0 + g:llama_config.ring_chunk_size/2, len(a:text)])
line 21: 
line 22:         let l:chunk = a:text[l:l0:l:l1]
line 23:     endif
line 24: 
line 25:     let l:chunk_str = join(l:chunk, "\n") . "\n"
line 26: 
line 27:     " check if this chunk is already added
line 28:     let l:exist = v:false
line 29: 
line 30:     for i in range(len(s:ring_chunks))
line 31:         if s:ring_chunks[i].data == l:chunk
line 32:             let l:exist = v:true
line 33:             break
line 34:         endif
line 35:     endfor
line 36: 
line 37:     for i in range(len(s:ring_queued))
line 38:         if s:ring_queued[i].data == l:chunk
line 39:             let l:exist = v:true
line 40:             break
line 41:         endif
line 42:     endfor
line 43: 
line 44:     if l:exist
line 45:         return
<SNR>51_pick_chunk returning #0

continuing in <lambda>3

<lambda>3 returning #0

calling <lambda>4(6)

calling <SNR>51_pick_chunk(['', 'sourcing "nvim_exec2()"', 'line ...d_load_ftplugin")', 'line 8:   finish'], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
line 4:     endif
line 5: 
line 6:     " if the extra context option is disabled - do nothing
line 7:     if g:llama_config.ring_n_chunks <= 0
line 8:         return
line 9:     endif
line 10: 
line 11:     " don't pick very small chunks
line 12:     if len(a:text) < 3
line 13:         return
line 14:     endif
line 15: 
line 16:     if len(a:text) + 1 < g:llama_config.ring_chunk_size
line 17:         let l:chunk = a:text
line 18:     else
line 19:         let l:l0 = s:rand(0, max([0, len(a:text) - g:llama_config.ring_chunk_size/2]))
line 20:         let l:l1 = min([l:l0 + g:llama_config.ring_chunk_size/2, len(a:text)])
line 21: 
line 22:         let l:chunk = a:text[l:l0:l:l1]
line 23:     endif
line 24: 
line 25:     let l:chunk_str = join(l:chunk, "\n") . "\n"
line 26: 
line 27:     " check if this chunk is already added
line 28:     let l:exist = v:false
line 29: 
line 30:     for i in range(len(s:ring_chunks))
line 31:         if s:ring_chunks[i].data == l:chunk
line 32:             let l:exist = v:true
line 33:             break
line 34:         endif
line 35:     endfor
line 36: 
line 37:     for i in range(len(s:ring_queued))
line 38:         if s:ring_queued[i].data == l:chunk
line 39:             let l:exist = v:true
line 40:             break
line 41:         endif
line 42:     endfor
line 43: 
line 44:     if l:exist
line 45:         return
<SNR>51_pick_chunk returning #0

continuing in <lambda>4

<lambda>4 returning #0

calling <lambda>1(1)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
line 10:     endif
line 11: 
line 12:     " move the first queued chunk to the ring buffer
line 13:     if len(s:ring_chunks) == g:llama_config.ring_n_chunks
line 14:         call remove(s:ring_chunks, 0)
line 15:     endif
line 16: 
line 17:     call add(s:ring_chunks, remove(s:ring_queued, 0))
line 18: 
line 19:     "let &statusline = 'updated context: ' . len(s:ring_chunks) . ' / ' . len(s:ring_queued)
line 20: 
line 21:     " send asynchronous job with the new extra context so that it is ready for the next FIM
line 22:     let l:extra_context = []
line 23:     for l:chunk in s:ring_chunks
line 24:         call add(l:extra_context, { 'text':     l:chunk.str, 'time':     l:chunk.time, 'filename': l:chunk.filename })
line 29:     endfor
line 23:     for l:chunk in s:ring_chunks
line 24:         call add(l:extra_context, { 'text':     l:chunk.str, 'time':     l:chunk.time, 'filename': l:chunk.filename })
line 29:     endfor
line 30: 
line 31:     " no samplers needed here
line 32:     let l:request = json_encode({ 'input_prefix':     "", 'input_suffix':     "", 'input_extra':      l:extra_context, 'prompt':           "", 'n_predict':        0, 'temperature':      0.0, 'stream':           v:false, 'samplers':         [], 'cache_prompt':     v:true, 't_max_prompt_ms':  1, 't_max_predict_ms': 1, 'response_fields':  [""] })
line 46:     let l:curl_command = [ "curl", "--silent", "--no-buffer", "--request", "POST", "--url", g:llama_config.endpoint, "--header", "Content-Type: application/json", "--data", "@-", ]
line 55:     if exists ("g:llama_config.api_key") && len("g:llama_config.api_key") > 0
line 56:         call extend(l:curl_command, ['--header', 'Authorization: Bearer ' .. g:llama_config.api_key])
line 57:     endif
line 58: 
line 59:     " no callbacks because we don't need to process the response
line 60:     if s:ghost_text_nvim
line 61:         let jobid = jobstart(l:curl_command, {})
line 62:         call chansend(jobid, l:request)
line 63:         call chanclose(jobid, 'stdin')
line 64:     elseif s:ghost_text_vim
line 65:         let jobid = job_start(l:curl_command, {})
line 66:         let channel = job_getchannel(jobid)
line 67:         call ch_sendraw(channel, l:request)
line 68:         call ch_close_in(channel)
line 69:     endif
<SNR>51_ring_update returning #0

continuing in <lambda>1

<lambda>1 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

calling <lambda>5(7)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in <lambda>5

<lambda>5 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 462: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 487: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:432>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 92: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 446: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 377: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 466: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 462: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 487: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:432>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 92: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 446: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 377: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 466: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Searching for "autoload/provider/clipboard.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/flash.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/autoload/provider/clipboard.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/autoload/provider/clipboard.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim"
line 1: " The clipboard provider uses shell commands to communicate with the clipboard.
line 2: " The provider function will only be registered if a supported command is
line 3: " available.
line 4: 
line 5: if exists('g:loaded_clipboard_provider')
line 6:   finish
line 7: endif
line 8: " Default to 0.  provider#clipboard#Executable() may set 2.
line 9: " To force a reload:
line 10: "   :unlet g:loaded_clipboard_provider
line 11: "   :runtime autoload/provider/clipboard.vim
line 12: let g:loaded_clipboard_provider = 0
line 13: 
line 14: let s:copy = {}
line 15: let s:paste = {}
line 16: let s:clipboard = {}
line 17: 
line 18: " When caching is enabled, store the jobid of the xclip/xsel process keeping
line 19: " ownership of the selection, so we know how long the cache is valid.
line 20: let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
line 21: 
line 22: function! s:selection.on_exit(jobid, data, event) abort
line 35: 
line 36: let s:selections = { '*': s:selection, '+': copy(s:selection) }
line 37: 
line 38: function! s:try_cmd(cmd, ...) abort
line 51: 
line 52: " Returns TRUE if `cmd` exits with success, else FALSE.
line 53: function! s:cmd_ok(cmd) abort
line 57: 
line 58: function! s:split_cmd(cmd) abort
line 61: 
line 62: function! s:set_osc52() abort
line 69: 
line 70: function! s:set_pbcopy() abort
line 78: 
line 79: function! s:set_wayland() abort
line 86: 
line 87: function! s:set_wayclip() abort
line 94: 
line 95: function! s:set_xsel() abort
line 102: 
line 103: function! s:set_xclip() abort
line 110: 
line 111: function! s:set_lemonade() abort
line 118: 
line 119: function! s:set_doitclient() abort
line 126: 
line 127: function! s:set_win32yank() abort
line 139: 
line 140: function! s:set_putclip() abort
line 147: 
line 148: function! s:set_clip() abort
line 155: 
line 156: function! s:set_termux() abort
line 163: 
line 164: function! s:set_tmux() abort
line 176: 
line 177: let s:cache_enabled = 1
line 178: let s:err = ''
line 179: 
line 180: function! provider#clipboard#Error() abort
line 183: 
line 184: function! provider#clipboard#Executable() abort
line 269: 
line 270: function! s:clipboard.get(reg) abort
line 287: 
line 288: function! s:clipboard.set(lines, regtype, reg) abort
line 346: 
line 347: function! provider#clipboard#Call(method, args) abort
line 358: 
line 359: " eval_has_provider() decides based on this variable.
line 360: let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 0 : 2
calling provider#clipboard#Executable()

line 1:   " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
line 2:   if exists('g:clipboard') && g:clipboard isnot# v:false
line 3:     if v:t_string ==# type(g:clipboard)
line 4:       " Handle string form of g:clipboard for all builtin providers
line 5:       if 'osc52' == g:clipboard
line 6:         " User opted-in to OSC 52 by manually setting g:clipboard.
line 7:         return s:set_osc52()
line 8:       elseif 'pbcopy' == g:clipboard
line 9:         return s:set_pbcopy()
line 10:       elseif 'wl-copy' == g:clipboard
line 11:         return s:set_wayland()
line 12:       elseif 'wayclip' == g:clipboard
line 13:         return s:set_wayclip()
line 14:       elseif 'xsel' == g:clipboard
line 15:         return s:set_xsel()
line 16:       elseif 'xclip' == g:clipboard
line 17:         return s:set_xclip()
line 18:       elseif 'lemonade' == g:clipboard
line 19:         return s:set_lemonade()
line 20:       elseif 'doitclient' == g:clipboard
line 21:         return s:set_doitclient()
line 22:       elseif 'win32yank' == g:clipboard
line 23:         return s:set_win32yank()
line 24:       elseif 'putclip' == g:clipboard
line 25:         return s:set_putclip()
line 26:       elseif 'clip' == g:clipboard
line 27:         return s:set_clip()
line 28:       elseif 'termux' == g:clipboard
line 29:         return s:set_termux()
line 30:       elseif 'tmux' == g:clipboard
line 31:         return s:set_tmux()
line 32:       endif
line 33:     endif
line 34: 
line 35:     if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
line 38:       let s:err = 'clipboard: invalid g:clipboard'
line 39:       return ''
line 40:     endif
line 41: 
line 42:     let s:copy = {}
line 43:     let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
line 44:     let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
line 45: 
line 46:     let s:paste = {}
line 47:     let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
line 48:     let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
line 49: 
line 50:     let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
line 51:     return get(g:clipboard, 'name', 'g:clipboard')
line 52:   elseif has('mac')
line 53:     return s:set_pbcopy()
calling <SNR>122_set_pbcopy()

line 1:   let s:copy['+'] = ['pbcopy']
line 2:   let s:paste['+'] = ['pbpaste']
line 3:   let s:copy['*'] = s:copy['+']
line 4:   let s:paste['*'] = s:paste['+']
line 5:   let s:cache_enabled = 0
line 6:   return 'pbcopy'
<SNR>122_set_pbcopy returning 'pbcopy'

continuing in provider#clipboard#Executable

provider#clipboard#Executable returning 'pbcopy'

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim

finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 32^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 1H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 744^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 5H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 756^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 9H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 780^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 13H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 743^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 17H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 712^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 21H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 768^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 25H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 810^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 30H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
sourcing "nvim_exec2()"
line 1: keepjumps normal! 745^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 34H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 730^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 38H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 802^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 42H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 736^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 46H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 785^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 51H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 750^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 55H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 752^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 59H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 795^E
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 63H
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: keepjumps normal! 0zh
finished sourcing nvim_exec2()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
calling <lambda>6(8)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in <lambda>6

<lambda>6 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

Executing WinClosed Autocommands for "*"
autocommand <Lua 462: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 487: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:432>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 92: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 446: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 377: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 466: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 462: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 487: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:432>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 92: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 446: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 377: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 466: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 498: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 273: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 279: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 557: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 315: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 611: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand <Lua 450: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 560: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:191>

Executing: 

calling <lambda>19(9)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in <lambda>19

<lambda>19 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

calling <lambda>20(10)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in <lambda>20

<lambda>20 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

calling <lambda>21(11)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in <lambda>21

<lambda>21 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>89_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 493: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 495: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>89_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0


Executing ModeChanged Autocommands for "*"
autocommand <Lua 496: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:280>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 61: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 536: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:86>

Executing: 

Executing VimLeavePre Autocommands for "*"
autocommand <Lua 249: ~/.local/share/nvim/lazy/mason.nvim/lua/mason/init.lua:9>

Executing: 
autocommand <Lua 272: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/lsp.lua:1111>

Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 486: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:419>

line 0: sourcing "nvim_exec2() called at VimLeavePre Autocommands for "*":0"
line 1: %argdelete
finished sourcing nvim_exec2() called at VimLeavePre Autocommands for "*":0
continuing in VimLeavePre Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimLeavePre Autocommands for "*":0"
line 1: mks! /Users/joe/.local/share/nvim/sessions/\%2FUsers\%2Fjoe\%2Fgit\%2Fjoe-p\%2Ffetch\%2Envim.vim
chdir(/Users/joe/git/joe-p/fetch.nvim)
finished sourcing nvim_exec2() called at VimLeavePre Autocommands for "*":0
continuing in VimLeavePre Autocommands for "*"
Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 537: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/attach.lua:318>

Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 744>

Executing: 
Writing ShaDa file "/Users/joe/.local/state/nvim/shada/main.shada"
Executing VimLeave Autocommands for "*"
autocommand call vimade#Disable()

Executing: call vimade#Disable()
calling vimade#Disable()

line 1:   if winnr() == 0
line 2:     return
line 3:   endif
line 4:   "disable vimade
line 5:   let g:vimade_running = 0
line 6:   call vimade#StopTimer()
calling vimade#StopTimer()

line 1:   if exists('g:vimade_timer')
line 2:     call timer_stop(g:vimade_timer)
line 3:     unlet g:vimade_timer
line 4:   endif
vimade#StopTimer returning #0

continuing in vimade#Disable

line 7:   call g:vimade_active_renderer.disable()
calling <SNR>89_Disable_Lua()

line 1:   lua require('vimade').disable()
<SNR>89_Disable_Lua returning #0

continuing in vimade#Disable

vimade#Disable returning #0

continuing in VimLeave Autocommands for "*"

Executing UILeave Autocommands for "*"
autocommand <Lua 281: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua:55>

Executing: 
sourcing "nvim_exec2()"
line 1:     amenu     PopUp.Open\ in\ web\ browser  gx
line 2:     anoremenu PopUp.Inspect                 <Cmd>Inspect<CR>
line 3:     anoremenu PopUp.Go\ to\ definition      <Cmd>lua vim.lsp.buf.definition()<CR>
line 4:     anoremenu PopUp.Show\ Diagnostics       <Cmd>lua vim.diagnostic.open_float()<CR>
line 5:     anoremenu PopUp.Show\ All\ Diagnostics  <Cmd>lua vim.diagnostic.setqflist()<CR>
line 6:     anoremenu PopUp.Configure\ Diagnostics  <Cmd>help vim.diagnostic.config()<CR>
line 7:     anoremenu PopUp.-1-                     <Nop>
line 8:     vnoremenu PopUp.Cut                     "+x
line 9:     vnoremenu PopUp.Copy                    "+y
line 10:     anoremenu PopUp.Paste                   "+gP
line 11:     vnoremenu PopUp.Paste                   "+P
line 12:     vnoremenu PopUp.Delete                  "_x
line 13:     nnoremenu PopUp.Select\ All             ggVG
line 14:     vnoremenu PopUp.Select\ All             gg0oG$
line 15:     inoremenu PopUp.Select\ All             <C-Home><C-O>VG
line 16:     anoremenu PopUp.-2-                     <Nop>
line 17:     anoremenu PopUp.How-to\ disable\ mouse  <Cmd>help disable-mouse<CR>
line 18:   
finished sourcing nvim_exec2()
Searching for "ftplugin.vim" in runtime path
Searching for "/Users/joe/.config/nvim/ftplugin.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_load_ftplugin")
line 8:   finish
line 9: endif
line 10: let did_load_ftplugin = 1
line 11: 
line 12: augroup filetypeplugin
line 13:   au FileType * call s:LoadFTPlugin()
line 14: 
line 15:   func! s:LoadFTPlugin()
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin.vim
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/Users/joe/.config/nvim/indent.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   finish
line 9: endif
line 10: let did_indent_on = 1
line 11: 
line 12: augroup filetypeindent
line 13:   au FileType * call s:LoadIndent()
line 14:   func! s:LoadIndent()
line 33: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent.vim
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/indent.vim"
could not source "/opt/homebrew/etc/xdg/nvim/sysinit.vim"
could not source "/etc/xdg/nvim/sysinit.vim"
could not source "$VIM/sysinit.vim"
sourcing "/Users/joe/.config/nvim/init.lua"
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
line 0: sourcing "nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:0"
line 1:   augroup filetypedetect
line 2:   runtime! ftdetect/*.{vim,lua}
Searching for "ftdetect/*.{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftdetect/*.{vim,lua}"
not found in runtime path: "ftdetect/*.{vim,lua}"
line 3:   augroup END
finished sourcing nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:0
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim"
line 1: 
line 2: " Create command for running busted
line 3: command! -nargs=1 -complete=file PlenaryBustedFile lua require('plenary.test_harness').test_file([[<args>]])
line 5: 
line 6: command! -nargs=+ -complete=file PlenaryBustedDirectory lua require('plenary.test_harness').test_directory_command([[<args>]])
line 8: 
line 9: nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>
finished sourcing /Users/joe/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim"
line 1: if exists('g:loaded_devicons') | finish | endif
line 1:  finish | endif
line 1:  endif
line 2: 
line 3: let s:save_cpo = &cpo
line 4: set cpo&vim
line 5: 
line 6: " TODO change so its easier to get
line 7: let g:nvim_web_devicons = 1
line 8: 
line 9: let &cpo = s:save_cpo
line 10: unlet s:save_cpo
line 11: 
line 12: let g:loaded_devicons = 1
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/plugin/treesitter-context.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim"
line 1: lua << EOF
line 3: sourcing "nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua"
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#installed_parsers TSUninstall lua require'nvim-treesitter.install'.commands.TSUninstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallFromGrammar lua require'nvim-treesitter.install'.commands.TSInstallFromGrammar['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdateSync lua require'nvim-treesitter.install'.commands.TSUpdateSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstall lua require'nvim-treesitter.install'.commands.TSInstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdate lua require'nvim-treesitter.install'.commands.TSUpdate['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallSync lua require'nvim-treesitter.install'.commands.TSInstallSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=? -complete=custom,nvim_treesitter#available_modules TSModuleInfo lua require'nvim-treesitter.info'.commands.TSModuleInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSInstallInfo lua require'nvim-treesitter.info'.commands.TSInstallInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSToggle lua require'nvim-treesitter.configs'.commands.TSToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSDisable lua require'nvim-treesitter.configs'.commands.TSDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSEnable lua require'nvim-treesitter.configs'.commands.TSEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufToggle lua require'nvim-treesitter.configs'.commands.TSBufToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufDisable lua require'nvim-treesitter.configs'.commands.TSBufDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufEnable lua require'nvim-treesitter.configs'.commands.TSBufEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQueryUserAfter lua require'nvim-treesitter.configs'.commands.TSEditQueryUserAfter['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQuery lua require'nvim-treesitter.configs'.commands.TSEditQuery['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSConfigInfo lua require'nvim-treesitter.configs'.commands.TSConfigInfo['run<bang>'](<f-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
continuing in nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3
finished sourcing nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3
continuing in /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
line 3: sourcing "nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3
continuing in /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
line 3: sourcing "nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim:3
continuing in /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
Searching for "parser/bash.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/bash.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/bash.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/bash.so"
Searching for "parser/c.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/c.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/c.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/c.so"
Searching for "parser/diff.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/diff.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/diff.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/diff.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/diff.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/diff.so"
Searching for "parser/html.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/html.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/html.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/html.so"
Searching for "parser/lua.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/lua.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/lua.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/lua.so"
Searching for "parser/luadoc.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/luadoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/luadoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/luadoc.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/luadoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/luadoc.so"
Searching for "parser/markdown.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/markdown.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/markdown.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/markdown.so"
Searching for "parser/markdown_inline.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/markdown_inline.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/markdown_inline.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/markdown_inline.so"
Searching for "parser/query.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/query.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/query.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/query.so"
Searching for "parser/vim.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/vim.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/vim.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/vim.so"
Searching for "parser/vimdoc.so" in runtime path
Searching for "/Users/joe/.config/nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/vimdoc.so"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/vimdoc.so"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/vimdoc.so"
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSelect lua require'nvim-treesitter.textobjects.select'.commands.TSTextobjectSelect['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoPreviousStart lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoPreviousStart['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoNextEnd lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoNextEnd['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoNextStart lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoNextStart['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectGotoPreviousEnd lua require'nvim-treesitter.textobjects.move'.commands.TSTextobjectGotoPreviousEnd['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltint lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltint['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinF lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinF['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinf lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinf['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMovePrevious lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMovePrevious['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMoveNext lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMoveNext['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMoveOpposite lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMoveOpposite['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectRepeatLastMove lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectRepeatLastMove['run<bang>'](<f-args>)
line 3: command! -bar TSTextobjectBuiltinT lua require'nvim-treesitter.textobjects.repeatable_move'.commands.TSTextobjectBuiltinT['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSwapPrevious lua require'nvim-treesitter.textobjects.swap'.commands.TSTextobjectSwapPrevious['run<bang>'](<f-args>)
line 3: command! -bar -nargs=1 -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectSwapNext lua require'nvim-treesitter.textobjects.swap'.commands.TSTextobjectSwapNext['run<bang>'](<f-args>)
line 3: command! -bar -nargs=+ -complete=custom,nvim_treesitter_textobjects#available_textobjects TSTextobjectPeekDefinitionCode lua require'nvim-treesitter.textobjects.lsp_interop'.commands.TSTextobjectPeekDefinitionCode['run<bang>'](<f-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/plugin/nvim-treesitter-textobjects.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim"
line 1: if exists('g:vimade_loaded')
line 2:   finish
line 3: endif
line 4: 
line 5: let g:vimade_loaded = 1
line 6: 
line 7: if !exists('g:vimade')
line 8:   let g:vimade = {}
line 9: endif
line 10: 
line 11: 
line 12: ""Enables Vimade
line 13: command! VimadeEnable call vimade#Enable()
line 14: 
line 15: ""Unfades all buffers, signs, and disables Vimade
line 16: command! VimadeDisable call vimade#Disable()
line 17: 
line 18: ""Disables the current window
line 19: command! VimadeWinDisable call vimade#WinDisable()
line 20: 
line 21: ""Disables the current buffer
line 22: command! VimadeBufDisable call vimade#BufDisable()
line 23: 
line 24: ""Fades the current buffer
line 25: command! VimadeFadeActive call vimade#FadeActive()
line 26: "
line 27: ""Unfades the current buffer
line 28: command! VimadeUnfadeActive call vimade#UnfadeActive()
line 29: 
line 30: ""Enables the current window
line 31: command! VimadeWinEnable call vimade#WinEnable()
line 32: 
line 33: ""Enables the current buffer
line 34: command! VimadeBufEnable call vimade#BufEnable()
line 35: 
line 36: ""Toggles Vimade between enabled and disabled states
line 37: command! VimadeToggle call vimade#Toggle()
line 38: 
line 39: ""Prints debug information that should be included in bug reports
line 40: command! VimadeInfo echo json_encode(vimade#GetInfo())
line 41: 
line 42: ""Recalculates all fades and redraws all inactive buffers and signs
line 43: command! VimadeRedraw call vimade#Redraw()
line 44: 
line 45: ""Changes vimade_fadelevel to the {value} specified.  {value} can be between
line 46: "0.0 and 1.0
line 47: command! -nargs=1 VimadeFadeLevel call vimade#FadeLevel(<q-args>)
line 48: 
line 49: ""Changes vimade_fadepriority to the {value} specified.  This can be useful
line 50: "when combining Vimade with other plugins that also highlight using matches
line 51: command! -nargs=1 VimadeFadePriority call vimade#FadePriority(<q-args>)
line 52: 
line 53: ""Overrides the Folded highlight by creating a link to the Vimade base fade.
line 54: "This should produce acceptable results for colorschemes that include Folded
line 55: "highlights that are distracting in faded windows.
line 56: command! VimadeOverrideFolded call vimade#OverrideFolded()
line 57: 
line 58: ""EXPERIMENTAL -- Overrides the SignColumn highlight by creating a link to the Vimade base fade.
line 59: "This should produce acceptable results for colorschemes that include Folded
line 60: "highlights that are distracting in faded windows.
line 61: command! VimadeOverrideSignColumn call vimade#OverrideSignColumn()
line 62: 
line 63: ""EXPERIMENTAL -- Overrides the LineNr highlight by creating a link to the Vimade base fade.
line 64: "This should produce acceptable results for colorschemes that include Folded
line 65: "highlights that are distracting in faded windows.
line 66: command! VimadeOverrideLineNr call vimade#OverrideLineNr()
line 67: 
line 68: ""EXPERIMENTAL -- Overrides the VertSplit highlight by creating a link to the Vimade base fade.
line 69: "This should produce acceptable results for colorschemes that include Folded
line 70: "highlights that are distracting in faded windows.
line 71: command! VimadeOverrideSplits call vimade#OverrideVertSplit()
line 72: 
line 73: ""EXPERIMENTAL -- Overrides the NonText highlight by creating a link to the Vimade base fade.
line 74: "This should produce acceptable results for colorschemes that include Folded
line 75: "highlights that are distracting in faded windows.
line 76: command! VimadeOverrideNonText call vimade#OverrideNonText()
line 77: 
line 78: ""EXPERIMENTAL -- Overrides the EndOfBuffer highlight by creating a link to the Vimade base fade.
line 79: "This should produce acceptable results for colorschemes that include Folded
line 80: "highlights that are distracting in faded windows.
line 81: command! VimadeOverrideEndOfBuffer call vimade#OverrideEndOfBuffer()
line 82: 
line 83: ""EXPERIMENTAL -- Overrides static highlights by creating a link to the Vimade base fade.
line 84: "This should produce acceptable results for colorschemes that include Folded
line 85: "highlights that are distracting in faded windows.
line 86: command! VimadeOverrideAll call vimade#OverrideAll()
line 87: 
line 88: "" EXPERIMENTAL - Loads the current lua-only commands for Neovim (VimadeFocus & VimadeMark)
line 89: if has('nvim')
line 90:   lua require('vimade.focus.commands')
line 91: endif
line 92: 
line 93: let g:vimade_plugin_current_directory = resolve(expand('<sfile>:p:h').'/../lib')
line 94: 
line 95: if (!exists('g:vimade.lazy') || !g:vimade.lazy) && !exists('g::vimade_loaded')
line 96:   if v:vim_did_enter
line 97:     call vimade#Load()
line 98:   else
line 99:     augroup vimade
line 100:       au!
line 101:       au VimEnter * call vimade#Load()
line 102:     augroup END
line 103:   endif
line 104: endif
finished sourcing /Users/joe/.local/share/nvim/lazy/vimade/plugin/vimade.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim"
line 1: call llama#init()
Searching for "autoload/llama.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/llama.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/llama.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim"
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim"
line 1: " vim: ts=4 sts=4 expandtab
line 2: " colors (adjust to your liking)
line 3: highlight llama_hl_hint guifg=#ff772f ctermfg=202
line 4: highlight llama_hl_info guifg=#77ff2f ctermfg=119
line 5: 
line 6: " general parameters:
line 7: "
line 8: "   endpoint:         llama.cpp server endpoint
line 9: "   api_key:          llama.cpp server api key (optional)
line 10: "   n_prefix:         number of lines before the cursor location to include in the local prefix
line 11: "   n_suffix:         number of lines after  the cursor location to include in the local suffix
line 12: "   n_predict:        max number of tokens to predict
line 13: "   t_max_prompt_ms:  max alloted time for the prompt processing (TODO: not yet supported)
line 14: "   t_max_predict_ms: max alloted time for the prediction
line 15: "   show_info:        show extra info about the inference (0 - disabled, 1 - statusline, 2 - inline)
line 16: "   auto_fim:         trigger FIM completion automatically on cursor movement
line 17: "   max_line_suffix:  do not auto-trigger FIM completion if there are more than this number of characters to the right of the cursor
line 18: "   max_cache_keys:   max number of cached completions to keep in result_cache
line 19: "
line 20: " ring buffer of chunks, accumulated with time upon:
line 21: "
line 22: "  - completion request
line 23: "  - yank
line 24: "  - entering a buffer
line 25: "  - leaving a buffer
line 26: "  - writing a file
line 27: "
line 28: " parameters for the ring-buffer with extra context:
line 29: "
line 30: "   ring_n_chunks:    max number of chunks to pass as extra context to the server (0 to disable)
line 31: "   ring_chunk_size:  max size of the chunks (in number of lines)
line 32: "                     note: adjust these numbers so that you don't overrun your context
line 33: "                           at ring_n_chunks = 64 and ring_chunk_size = 64 you need ~32k context
line 34: "   ring_scope:       the range around the cursor position (in number of lines) for gathering chunks after FIM
line 35: "   ring_update_ms:   how often to process queued chunks in normal mode
line 36: "
line 37: let s:default_config = { 'endpoint':         'http://127.0.0.1:8012/infill', 'api_key':          '', 'n_prefix':         256, 'n_suffix':         64, 'n_predict':        128, 't_max_prompt_ms':  500, 't_max_predict_ms': 500, 'show_info':        2, 'auto_fim':         v:true, 'max_line_suffix':  8, 'max_cache_keys':   250, 'ring_n_chunks':    16, 'ring_chunk_size':  64, 'ring_scope':       1024, 'ring_update_ms':   1000, }
line 54: 
line 55: let llama_config = get(g:, 'llama_config', s:default_config)
line 56: let g:llama_config = extendnew(s:default_config, llama_config, 'force')
line 57: 
line 58: let g:result_cache = {}
line 59: 
line 60: function! s:get_indent(str)
line 71: 
line 72: function! s:rand(i0, i1) abort
line 75: 
line 76: let s:llama_enabled = v:true
line 77: 
line 78: function! llama#disable()
line 83: 
line 84: function! llama#toggle()
line 92: 
line 93: function llama#setup_commands()
line 98: 
line 99: function! llama#init()
line 183: 
line 184: " compute how similar two chunks of text are
line 185: " 0 - no similarity, 1 - high similarity
line 186: " TODO: figure out something better
line 187: function! s:chunk_sim(c0, c1)
line 204: 
line 205: " pick a random chunk of size g:llama_config.ring_chunk_size from the provided text and queue it for processing
line 206: "
line 207: " no_mod   - do not pick chunks from buffers with pending changes
line 208: " do_evict - evict chunks that are very similar to the new one
line 209: "
line 210: function! s:pick_chunk(text, no_mod, do_evict)
line 291: 
line 292: " picks a queued chunk, sends it for processing and adds it to s:ring_chunks
line 293: " called every g:llama_config.ring_update_ms
line 294: function! s:ring_update()
line 365: 
line 366: " necessary for 'inoremap <expr>'
line 367: function! llama#fim_inline(is_auto, cache) abort
line 371: 
line 372: " the main FIM call
line 373: " takes local context around the cursor and sends it together with the extra context to the server for completion
line 374: function! llama#fim(is_auto, cache) abort
line 568: 
line 569: " if accept_type == 'full', accept entire response
line 570: " if accept_type == 'line', accept only the first line of the response
line 571: " if accept_type == 'word', accept only the first word of the response
line 572: function! llama#fim_accept(accept_type)
line 607: 
line 608: function! llama#fim_cancel()
line 627: 
line 628: function! s:on_move()
line 633: 
line 634: " TODO: Currently the cache uses a random eviction policy. A more clever policy could be implemented (eg. LRU).
line 635: function! s:insert_cache(key, value)
line 646: 
line 647: " callback that processes the FIM result from the server and displays the suggestion
line 648: function! s:fim_on_stdout(hash, cache, pos_x, pos_y, is_auto, job_id, data, event = v:null)
line 894: 
line 895: function! s:fim_on_exit(job_id, exit_code, event = v:null)
finished sourcing /Users/joe/.local/share/nvim/lazy/llama.vim/autoload/llama.vim
continuing in /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
calling llama#init()

line 1:     if !executable('curl')
line 2:         echohl WarningMsg
line 3:         echo 'llama.vim requires the "curl" command to be available'
line 4:         echohl None
line 5:         return
line 6:     endif
line 7: 
line 8:     call llama#setup_commands()
calling llama#setup_commands()

line 1:     command! LlamaEnable call llama#init()
line 2:     command! LlamaDisable call llama#disable()
line 3:     command! LlamaToggle call llama#toggle()
llama#setup_commands returning #0

continuing in llama#init

line 9: 
line 10:     let s:pos_x = 0 " cursor position upon start of completion
line 11:     let s:pos_y = 0
line 12: 
line 13:     let s:line_cur = ''
line 14: 
line 15:     let s:line_cur_prefix = ''
line 16:     let s:line_cur_suffix = ''
line 17: 
line 18:     let s:ring_chunks = [] " current set of chunks used as extra context
line 19:     let s:ring_queued = [] " chunks that are queued to be sent for processing
line 20:     let s:ring_n_evict = 0
line 21: 
line 22:     let s:hint_shown = v:false
line 23:     let s:pos_y_pick = -9999 " last y where we picked a chunk
line 24:     let s:pos_dx = 0
line 25:     let s:content = []
line 26:     let s:can_accept = v:false
line 27: 
line 28:     let s:timer_fim = -1
line 29:     let s:t_fim_start = reltime() " used to measure total FIM time
line 30:     let s:t_last_move = reltime() " last time the cursor moved
line 31: 
line 32:     let s:current_job = v:null
line 33:     let s:job_error = 0
line 34: 
line 35:     let s:ghost_text_nvim = exists('*nvim_buf_get_mark')
line 36:     let s:ghost_text_vim = has('textprop')
line 37: 
line 38:     if s:ghost_text_vim
line 39:         if version < 901
line 40:             echom 'Warning: llama.vim requires version 901 or greater. Current version: ' . version
line 41:         endif
line 42:         let s:hlgroup_hint = 'llama_hl_hint'
line 43:         let s:hlgroup_info = 'llama_hl_info'
line 44: 
line 45:         if empty(prop_type_get(s:hlgroup_hint))
line 46:             call prop_type_add(s:hlgroup_hint, {'highlight': s:hlgroup_hint})
line 47:         endif
line 48:         if empty(prop_type_get(s:hlgroup_info))
line 49:             call prop_type_add(s:hlgroup_info, {'highlight': s:hlgroup_info})
line 50:         endif
line 51:     endif
line 52: 
line 53:     augroup llama
line 54:         autocmd!
line 55:         autocmd InsertEnter     * inoremap <expr> <silent> <C-F> llama#fim_inline(v:false, v:false)
line 56:         autocmd InsertLeavePre  * call llama#fim_cancel()
line 57: 
line 58:         autocmd CursorMoved     * call s:on_move()
line 59:         autocmd CursorMovedI    * call s:on_move()
line 60:         autocmd CompleteChanged * call llama#fim_cancel()
line 61: 
line 62:         if g:llama_config.auto_fim
line 63:             autocmd CursorMovedI * call llama#fim(v:true, v:true)
line 64:         endif
line 65: 
line 66:         " gather chunks upon yanking
line 67:         autocmd TextYankPost    * if v:event.operator ==# 'y' | call s:pick_chunk(v:event.regcontents, v:false, v:true) | endif
line 68: 
line 69:         " gather chunks upon entering/leaving a buffer
line 70:         autocmd BufEnter        * call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
line 71:         autocmd BufLeave        * call                      s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)
line 72: 
line 73:         " gather chunk upon saving the file
line 74:         autocmd BufWritePost    * call s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)
line 75:     augroup END
line 76: 
line 77:     silent! call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing /Users/joe/.config/nvim/init.lua..nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0[1]../Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim[1]..function llama#init[77]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in llama#init

line 78: 
line 79:     " init background update of the ring buffer
line 80:     if g:llama_config.ring_n_chunks > 0
line 81:         call s:ring_update()
calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in llama#init

line 82:     endif
llama#init returning #0

continuing in /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim

finished sourcing /Users/joe/.local/share/nvim/lazy/llama.vim/plugin/llama.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/blink.cmp/plugin/blink-cmp.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/plugin/mason-tool-installer.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua"
finished sourcing /Users/joe/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim"
line 1: " sleuth.vim - Heuristically set buffer options
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.0
line 4: " GetLatestVimScripts: 4375 1 :AutoInstall: sleuth.vim
line 5: 
line 6: if exists("#polyglot-sleuth")
line 7:   autocmd! polyglot-sleuth
line 8:   augroup! polyglot-sleuth
line 9:   unlet! g:loaded_sleuth
line 10:   let s:polyglot = 1
line 11: endif
line 12: 
line 13: if exists("g:loaded_sleuth") || v:version < 700 || &cp
line 14:   finish
line 15: endif
line 16: let g:loaded_sleuth = 1
line 17: lockvar g:loaded_sleuth
line 18: 
line 19: function! s:Warn(msg, ...) abort
line 27: 
line 28: if exists('+shellslash')
line 29:   function! s:Slash(path) abort
line 32: else
line 33:   function! s:Slash(path) abort
line 36: endif
line 37: 
line 38: function! s:Guess(source, detected, lines) abort
line 149: 
line 150: function! s:Capture(cmd) abort
line 156: 
line 157: let s:modeline_numbers = { 'shiftwidth': 'shiftwidth', 'sw': 'shiftwidth', 'tabstop': 'tabstop', 'ts': 'tabstop', 'textwidth': 'textwidth', 'tw': 'textwidth', }
line 162: let s:modeline_booleans = { 'expandtab': 'expandtab', 'et': 'expandtab', 'fixendofline': 'fixendofline', 'fixeol': 'fixendofline', }
line 166: function! s:ParseOptions(declarations, into, ...) abort
line 181: 
line 182: function! s:ModelineOptions() abort
line 203: 
line 204: let s:fnmatch_replacements = { '.': '\.', '\%': '%', '\(': '(', '\)': ')', '\{': '{', '\}': '}', '\_': '_', '?': '[^/]', '*': '[^/]*', '/**/*': '/.*', '/**/': '/\%(.*/\)\=', '**': '.*'}
line 207: function! s:FnmatchReplace(pat) abort
line 231: 
line 232: function! s:FnmatchTranslate(pat) abort
line 235: 
line 236: function! s:ReadEditorConfig(absolute_path) abort
line 268: 
line 269: let s:editorconfig_cache = {}
line 270: function! s:DetectEditorConfig(absolute_path, ...) abort
line 314: 
line 315: let s:editorconfig_bomb = { 'utf-8':     0, 'utf-8-bom': 1, 'utf-16be':  1, 'utf-16le':  1, 'latin1':    0, }
line 322: 
line 323: let s:editorconfig_fileformat = { 'cr':   'mac', 'crlf': 'dos', 'lf':   'unix', }
line 328: 
line 329: function! s:EditorConfigToOptions(pairs) abort
line 383: 
line 384: function! s:Ready(detected) abort
line 387: 
line 388: let s:booleans = {'expandtab': 1, 'fixendofline': 1, 'endofline': 1, 'bomb': 1}
line 389: let s:safe_options = ['expandtab', 'shiftwidth', 'tabstop', 'textwidth', 'fixendofline']
line 390: let s:all_options = s:safe_options + ['endofline', 'fileformat', 'fileencoding', 'bomb']
line 391: let s:short_options = { 'expandtab': 'et', 'shiftwidth': 'sw', 'tabstop': 'ts', 'textwidth': 'tw', 'fixendofline': 'fixeol', 'endofline': 'eol', 'fileformat': 'ff', 'fileencoding': 'fenc'}
line 395: 
line 396: function! s:Apply(detected, permitted_options, silent) abort
line 459: 
line 460: function! s:UserOptions(ft, name) abort
line 487: 
line 488: function! s:DetectDeclared() abort
line 512: 
line 513: function! s:DetectHeuristics(into) abort
line 592: 
line 593: function! s:Init(redetect, unsafe, do_filetype, silent) abort
line 631: 
line 632: function! s:AutoInit() abort
line 635: 
line 636: function! s:Sleuth(line1, line2, range, bang, mods, args) abort
line 640: 
line 641: if !exists('g:did_indent_on') && !get(g:, 'sleuth_no_filetype_indent_on')
line 642:   filetype indent on
line 643: elseif !exists('g:did_load_filetypes')
line 644:   filetype on
line 645: endif
line 646: 
line 647: function! SleuthIndicator() abort
line 664: 
line 665: augroup sleuth
line 666:   autocmd!
line 667:   autocmd BufNewFile,BufReadPost * nested if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
line 670:   autocmd BufFilePost * nested if (@% !~# '^!' || exists('b:sleuth')) && get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
line 673:   autocmd FileType * nested if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif
line 675:   autocmd User Flags call Hoist('buffer', 5, 'SleuthIndicator')
line 676: augroup END
line 677: 
line 678: command! -bar -bang Sleuth exe s:Sleuth(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
finished sourcing /Users/joe/.local/share/nvim/lazy/vim-sleuth/plugin/sleuth.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2025 Feb 28
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.bz3,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo,*.lz4 setlocal bin
line 24: 
line 25:   " Use "gzip -d" and similar commands, gunzip isn't always available.
line 26:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 27:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.bz3 call gzip#read("bzip3 -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.lz4 call gzip#read("lz4 -d -q --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 35:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 36:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 37: 
line 38:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 39:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 40:   autocmd BufWritePost,FileWritePost^I*.bz3 call gzip#write("bzip3")
line 41:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 42:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 43:   autocmd BufWritePost,FileWritePost^I*.lz4  call gzip#write("lz4 -q --rm")
line 44:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 45:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 46:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 47:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 48:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 49: 
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 52:   autocmd FileAppendPre^I^I^I*.bz3 call gzip#appre("bzip3 -d")
line 53:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 54:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 55:   autocmd FileAppendPre^I^I^I*.lz4 call gzip#appre("lz4 -d -q --rm")
line 56:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 57:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 58:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 59:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 60:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 61: 
line 62:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 63:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 64:   autocmd FileAppendPost^I^I*.bz3 call gzip#write("bzip3")
line 65:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 66:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 67:   autocmd FileAppendPost^I^I*.lz4 call gzip#write("lz4 --rm")
line 68:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 69:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 70:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 71:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 72:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 73: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/gzip.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/man.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim"
line 1: " Nvim: load the matchit plugin by default.
line 2: if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
line 3:   packadd matchit
Searching for "pack/*/start/matchit" in "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/*/start/matchit"
not found in 'packpath': "pack/*/start/matchit"
Searching for "pack/*/opt/matchit" in "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/*/opt/matchit"
line 3: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim"
line 1: "  matchit.vim: (global plugin) Extended "%" matching
line 2: "  Maintainer:  Christian Brabandt
line 3: "  Version:     1.20
line 4: "  Last Change: 2024 May 20
line 5: "  Repository:  https://github.com/chrisbra/matchit
line 6: "  Previous URL:http://www.vim.org/script.php?script_id=39
line 7: "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
line 8: 
line 9: " Documentation:
line 10: "  The documentation is in a separate file: ../doc/matchit.txt
line 11: 
line 12: " Credits:
line 13: "  Vim editor by Bram Moolenaar (Thanks, Bram!)
line 14: "  Original script and design by Raul Segura Acevedo
line 15: "  Support for comments by Douglas Potts
line 16: "  Support for back references and other improvements by Benji Fisher
line 17: "  Support for many languages by Johannes Zellner
line 18: "  Suggestions for improvement, bug reports, and support for additional
line 19: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
line 20: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
line 21: 
line 22: " Debugging:
line 23: "  If you'd like to try the built-in debugging commands...
line 24: "   :MatchDebug      to activate debugging for the current buffer
line 25: "  This saves the values of several key script variables as buffer-local
line 26: "  variables.  See the MatchDebug() function, below, for details.
line 27: 
line 28: " TODO:  I should think about multi-line patterns for b:match_words.
line 29: "   This would require an option:  how many lines to scan (default 1).
line 30: "   This would be useful for Python, maybe also for *ML.
line 31: " TODO:  Maybe I should add a menu so that people will actually use some of
line 32: "   the features that I have implemented.
line 33: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
line 34: "   Match_wrapper() instead.
line 35: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
line 36: " TODO:  Make backrefs safer by using '\V' (very no-magic).
line 37: " TODO:  Add a level of indirection, so that custom % scripts can use my
line 38: "   work but extend it.
line 39: 
line 40: " Allow user to prevent loading and prevent duplicate loading.
line 41: if exists("g:loaded_matchit") || &cp
line 42:   finish
line 43: endif
line 44: let g:loaded_matchit = 1
line 45: 
line 46: let s:save_cpo = &cpo
line 47: set cpo&vim
line 48: 
line 49: fun MatchEnable()
line 89: 
line 90: fun MatchDisable()
line 108: 
line 109: " Call this function to turn on debugging information.  Every time the main
line 110: " script is run, buffer variables will be saved.  These can be used directly
line 111: " or viewed using the menu items below.
line 112: if !exists(":MatchDebug")
line 113:   command! -nargs=0 MatchDebug call matchit#Match_debug()
line 114: endif
line 115: if !exists(":MatchDisable")
line 116:   command! -nargs=0 MatchDisable :call MatchDisable()
line 117: endif
line 118: if !exists(":MatchEnable")
line 119:   command! -nargs=0 MatchEnable :call MatchEnable()
line 120: endif
line 121: 
line 122: call MatchEnable()
calling MatchEnable()

line 1:   nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
line 2:   nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
line 3:   xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
line 5:   xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
line 6:   onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
line 7:   onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
line 8: 
line 9:   " Analogues of [{ and ]} using matching patterns:
line 10:   nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
line 11:   nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
line 12:   xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
line 13:   xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
line 14:   onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
line 15:   onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
line 16: 
line 17:   " text object:
line 18:   xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
line 19: 
line 20:   if !exists("g:no_plugin_maps")
line 21:     nmap <silent> %  <Plug>(MatchitNormalForward)
line 22:     nmap <silent> g% <Plug>(MatchitNormalBackward)
line 23:     xmap <silent> %  <Plug>(MatchitVisualForward)
line 24:     xmap <silent> g% <Plug>(MatchitVisualBackward)
line 25:     omap <silent> %  <Plug>(MatchitOperationForward)
line 26:     omap <silent> g% <Plug>(MatchitOperationBackward)
line 27: 
line 28:     " Analogues of [{ and ]} using matching patterns:
line 29:     nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
line 30:     nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
line 31:     xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
line 32:     xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
line 33:     omap <silent> [% <Plug>(MatchitOperationMultiBackward)
line 34:     omap <silent> ]% <Plug>(MatchitOperationMultiForward)
line 35: 
line 36:     " Text object
line 37:     xmap a% <Plug>(MatchitVisualTextObject)
line 38:   endif
MatchEnable returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim

line 123: 
line 124: let &cpo = s:save_cpo
line 125: unlet s:save_cpo
line 126: 
line 127: " vim:sts=2:sw=2:et:
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
line 3: augroup filetypedetect
line 3: augroup END
line 4: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchit.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2025 Mar 14
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: " - Vim has no support for :defer
line 10: if exists("g:loaded_matchparen") || &cp || exists(":defer") != 2
line 12:   finish
line 13: endif
line 14: let g:loaded_matchparen = 1
line 15: 
line 16: if !exists("g:matchparen_timeout")
line 17:   let g:matchparen_timeout = 300
line 18: endif
line 19: if !exists("g:matchparen_insert_timeout")
line 20:   let g:matchparen_insert_timeout = 60
line 21: endif
line 22: if !exists("g:matchparen_disable_cursor_hl")
line 23:   let g:matchparen_disable_cursor_hl = 0
line 24: endif
line 25: 
line 26: augroup matchparen
line 27:   " Replace all matchparen autocommands
line 28:   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 29:   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
line 30:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 31:   autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 32:   autocmd! TextChangedP * call s:Remove_Matches()
line 33: augroup END
line 34: 
line 35: " Skip the rest if it was already done.
line 36: if exists("*s:Highlight_Matching_Pair")
line 37:   finish
line 38: endif
line 39: 
line 40: let s:cpo_save = &cpo
line 41: set cpo-=C
line 42: 
line 43: " The function that is invoked (very often) to define a ":match" highlighting
line 44: " for any matching paren.
line 45: func s:Highlight_Matching_Pair()
line 202: 
line 203: func s:Remove_Matches()
line 211: 
line 212: " Define commands that will disable and enable the plugin.
line 213: command DoMatchParen call s:DoMatchParen()
line 214: command NoMatchParen call s:NoMatchParen()
line 215: 
line 216: func s:NoMatchParen()
line 223: 
line 224: func s:DoMatchParen()
line 230: 
line 231: let &cpo = s:cpo_save
line 232: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/matchparen.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim"
line 1: " Load the netrw package.
line 2: 
line 3: if &cp || exists("g:loaded_netrw") || exists("g:loaded_netrwPlugin")
line 4:   finish
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/netrwPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim"
line 1: if exists('g:loaded_remote_plugins')
line 2:   finish
line 3: endif
line 4: let g:loaded_remote_plugins = '/path/to/manifest'
line 5: 
line 6: " Get the path to the rplugin manifest file.
line 7: function! s:GetManifestPath() abort
line 26: 
line 27: " Old manifest file based on known script locations.
line 28: function! s:GetOldManifestPaths() abort
line 43: 
line 44: function! s:GetManifest() abort
line 57: 
line 58: function! s:LoadRemotePlugins() abort
line 64: 
line 65: command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
line 66: 
line 67: if index(v:argv, "--clean") < 0
line 68:   call s:LoadRemotePlugins()
calling <SNR>74_LoadRemotePlugins()

line 1:   let g:loaded_remote_plugins = s:GetManifest()
calling <SNR>74_GetManifest()

line 1:   let manifest = s:GetManifestPath()
calling <SNR>74_GetManifestPath()

line 1:   let manifest_base = ''
line 2: 
line 3:   if exists('$NVIM_RPLUGIN_MANIFEST')
line 4:     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
line 5:   endif
line 6: 
line 7:   let dest = stdpath('data')
line 8:   if !empty(dest)
line 9:     if !isdirectory(dest)
line 10:       if getftype(dest) != "link"
line 11:         call mkdir(dest, 'p', 0700)
line 12:       endif
line 13:     endif
line 14:     let manifest_base = dest
line 15:   endif
line 16: 
line 17:   return manifest_base.'/rplugin.vim'
<SNR>74_GetManifestPath returning '/Users/joe/.local/share/nvim/rplugin.vim'

continuing in <SNR>74_GetManifest

line 2:   if !filereadable(manifest)
line 3:     " Check if an old manifest file exists and move it to the new location.
line 4:     for old_manifest in s:GetOldManifestPaths()
calling <SNR>74_GetOldManifestPaths()

line 1:   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
line 4:   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
line 6:   if !has('win32')
line 7:     return [origpath]
<SNR>74_GetOldManifestPaths returning ['/Users/joe/.config/nvim/.init.lua-rplugin~']

continuing in <SNR>74_GetManifest

line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 4:     for old_manifest in s:GetOldManifestPaths()
line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 10:   endif
line 11:   return manifest
<SNR>74_GetManifest returning '/Users/joe/.local/share/nvim/rplugin.vim'

continuing in <SNR>74_LoadRemotePlugins

line 2:   if filereadable(g:loaded_remote_plugins)
line 3:     execute 'source' fnameescape(g:loaded_remote_plugins)
line 4:   endif
<SNR>74_LoadRemotePlugins returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim

line 69: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/rplugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim"
line 1: if exists('g:loaded_shada_plugin')
line 2:   finish
line 3: endif
line 4: let g:loaded_shada_plugin = 1
line 5: 
line 6: augroup ShaDaCommands
line 7:   autocmd!
line 8:   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b'))) |setlocal filetype=shada
line 12:   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
line 15:   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |if writefile(shada#get_binstrings(getline(1, '$')),expand('<afile>'), 'b') == 0 |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))? 0: stridx(&cpoptions, '+') != -1) |endif
line 23:   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'b')
line 30:   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'ab')
line 37:   autocmd SourceCmd *.shada,*.shada.tmp.[a-z] :execute 'rshada' fnameescape(expand('<afile>'))
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/shada.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: 
line 3: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 4:   finish
line 5: endif
line 6: let loaded_spellfile_plugin = 1
line 7: 
line 8: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/spellfile.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: "
line 3: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 4: " Modified by Charles E. Campbell
line 5: " Distributed under the GNU General Public License.
line 6: "
line 7: " Updates are available from <http://michael.toren.net/code/>.  If you
line 8: " find this script useful, or have suggestions for improvements, please
line 9: " let me know.
line 10: " Also look there for further comments and documentation.
line 11: "
line 12: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 13: " ---------------------------------------------------------------------
line 14: "  Load Once: {{{1
line 15: if &cp || exists("g:loaded_tarPlugin")
line 16:  finish
line 17: endif
line 18: let g:loaded_tarPlugin = "v32"
line 19: let s:keepcpo          = &cpo
line 20: set cpo&vim
line 21: 
line 22: " ---------------------------------------------------------------------
line 23: "  Public Interface: {{{1
line 24: augroup tar
line 25:   au!
line 26:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 27:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 28:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 30: 
line 31:   if has("unix")
line 32:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 33:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 34:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 36:   endif
line 37: 
line 38:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.bz3^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tar.lz4^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^I^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 49:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 50:   au BufReadCmd   *.tlz4^I^Icall tar#Browse(expand("<amatch>"))
line 51:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 52:   au BufReadCmd   *.tzst^I^Icall tar#Browse(expand("<amatch>"))
line 53: augroup END
line 54: 
line 55: " ---------------------------------------------------------------------
line 56: " Restoration And Modelines: {{{1
line 57: " vim: fdm=marker
line 58: let &cpo= s:keepcpo
line 59: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tarPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tohtml.lua
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim"
line 1: if exists('g:loaded_tutor_mode_plugin') || &compatible
line 2:     finish
line 3: endif
line 4: let g:loaded_tutor_mode_plugin = 1
line 5: 
line 6: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/tutor.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
line 0: sourcing "nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0"
line 1: source /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 5: " Former Maintainer:^ICharles E Campbell
line 6: " License:^I^IVim License  (see vim's :help license)
line 7: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 8: "               Permission is hereby granted to use and distribute this code,
line 9: "               with or without modifications, provided that this copyright
line 10: "               notice is copied with it. Like anything else that's free,
line 11: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 12: "               of any kind, either expressed or implied. By using this
line 13: "               plugin, you agree that in no event will the copyright
line 14: "               holder be liable for any damages resulting from the use
line 15: "               of this software.
line 16: "
line 17: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 18: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 19: " ---------------------------------------------------------------------
line 20: " Load Once: {{{1
line 21: if &cp || exists("g:loaded_zipPlugin")
line 22:  finish
line 23: endif
line 24: let g:loaded_zipPlugin = "v33"
line 25: let s:keepcpo          = &cpo
line 26: set cpo&vim
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Options: {{{1
line 30: if !exists("g:zipPlugin_ext")
line 31:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 32: endif
line 33: 
line 34: " ---------------------------------------------------------------------
line 35: " Public Interface: {{{1
line 36: augroup zip
line 37:  au!
line 38:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 39:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 40:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 42: 
line 43:  if has("unix")
line 44:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 45:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 46:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 48:  endif
line 49: 
line 50:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 50: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 51: augroup END
line 52: 
line 53: " ---------------------------------------------------------------------
line 54: "  Restoration And Modelines: {{{1
line 55: "  vim: fdm=marker
line 56: let &cpo= s:keepcpo
line 57: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/zipPlugin.vim
continuing in nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
finished sourcing nvim_exec2() called at /Users/joe/.config/nvim/init.lua:0
continuing in /Users/joe/.config/nvim/init.lua
Executing User Autocommands for "LazyDone"
autocommand <Lua 76: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:183>

Executing: 
finished sourcing /Users/joe/.config/nvim/init.lua
Searching for "filetype.lua filetype.vim" in runtime path
Searching for "/Users/joe/.config/nvim/filetype.lua"
Searching for "/Users/joe/.config/nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/filetype.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/filetype.lua"
Searching for "/Users/joe/git/joe-p/fetch.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/filetype.vim"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/filetype.lua"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/filetype.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/filetype.lua"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/filetype.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in runtime path
Searching for "/Users/joe/.config/nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/syntax/synload.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/syntax/synload.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/syntax/synload.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim"
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Line continuation is used here, remove 'C' from 'cpoptions'
line 19: let s:cpo_save = &cpo
line 20: set cpo&vim
line 21: 
line 22: " First remove all old syntax autocommands.
line 23: au! Syntax
line 24: 
line 25: au Syntax *^I^Icall s:SynSet()
line 26: 
line 27: fun! s:SynSet()
line 58: 
line 59: 
line 60: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 61: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 66: 
line 67: 
line 68: " Source the user-specified syntax highlighting file
line 69: if exists("mysyntaxfile")
line 70:   let s:fname = expand(mysyntaxfile)
line 71:   if filereadable(s:fname)
line 72:     execute "source " . fnameescape(s:fname)
line 73:   endif
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/synload.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected
line 32: " unless treesitter highlighting is enabled.
line 33: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 34: augroup syntaxset
line 35:   au! FileType *^Iif !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
line 36: augroup END
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/syntax.vim
Reading ShaDa file "/Users/joe/.local/state/nvim/shada/main.shada" info marks oldfiles
Executing BufReadCmd Autocommands for "oil://*"
autocommand <Lua 80: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1219>

Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}
Searching for "ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.config/nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.config/nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil/*.{vim,lua}"
not found in runtime path: "ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/oil[.]{vim,lua}
Searching for "indent/oil[.]{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/indent/oil[.]{vim,lua}"
not found in runtime path: "indent/oil[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand <Lua 325: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/install.lua:558>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 326: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Searching for "parser/oil.*" in runtime path
Searching for "/Users/joe/.config/nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/parser/oil.*"
Searching for "/Users/joe/git/joe-p/fetch.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/parser/oil.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/parser/oil.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/parser/oil.*"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/parser/oil.*"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/parser/oil.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/parser/oil.*"
not found in runtime path: "parser/oil.*"
Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 327: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 330: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif

Executing: if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif
Executing:  exe s:Init(0, 0, 0, 1) | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 179: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1308>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 165: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufWinEnter Autocommands for "*"
autocommand silent! normal! g`"zv

Executing: silent! normal! g`"zv
Executing BufEnter Autocommands for "*"
autocommand <Lua 204: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 281: ~/.local/share/nvim/lazy/neo-tree.nvim/plugin/neo-tree.lua:37>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 180: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1278>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 283: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 301: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:130>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 359: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 92: ~/.local/share/nvim/lazy/stickybuf.nvim/lua/stickybuf.lua:237>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})

Executing: call timer_start(100, {-> s:pick_chunk(getline(max([1, line('.') - g:llama_config.ring_chunk_size/2]), min([line('.') + g:llama_config.ring_chunk_size/2, line('$')])), v:true, v:true)})
Executing VimEnter Autocommands for "*"
autocommand <Lua 69: vim/_defaults.lua:0>

Executing: 
autocommand <Lua 70: vim/_defaults.lua:0>

Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 157: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: source /Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
line 1: sourcing "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim"
line 1: command! -nargs=* TodoQuickFix lua require("todo-comments.search").setqflist(<q-args>)
line 2: command! -nargs=* TodoLocList lua require("todo-comments.search").setloclist(<q-args>)
line 3: command! -nargs=* TodoTelescope Telescope todo-comments todo <args>
line 4: command! -nargs=* TodoFzfLua lua require("todo-comments.fzf").todo() <args>
line 5: command! -nargs=* TodoTrouble Trouble todo <args>
finished sourcing /Users/joe/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
continuing in nvim_exec2() called at VimEnter Autocommands for "*":0
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup END
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgTEST guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgTEST guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignTEST guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgTODO guibg=#8cf8f7 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgTODO guibg=NONE guifg=#8cf8f7 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignTODO guibg=NONE guifg=#8cf8f7 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgWARN guibg=#fce094 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgWARN guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignWARN guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgHACK guibg=#fce094 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgHACK guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignHACK guibg=NONE guifg=#fce094 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgPERF guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgPERF guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignPERF guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgNOTE guibg=#a6dbff guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgNOTE guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignNOTE guibg=NONE guifg=#a6dbff gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoBgFIX guibg=#ffc0b9 guifg=#14161b gui=BOLD
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoFgFIX guibg=NONE guifg=#ffc0b9 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: hi def TodoSignFIX guibg=NONE guifg=#ffc0b9 gui=NONE
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
line 0: sourcing "nvim_exec2() called at VimEnter Autocommands for "*":0"
line 1: augroup Todo
line 2:         autocmd!
line 3:         autocmd BufWinEnter,WinNew * lua require("todo-comments.highlight").attach()
line 4:         autocmd WinScrolled * lua require("todo-comments.highlight").highlight_win()
line 5:         autocmd ColorScheme * lua vim.defer_fn(require("todo-comments.config").colors, 10)
line 6:       augroup end
finished sourcing nvim_exec2() called at VimEnter Autocommands for "*":0
continuing in VimEnter Autocommands for "*"
Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 224: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:381>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 366: vim/_editor.lua:0>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand call vimade#Load()

Executing: call vimade#Load()
Searching for "autoload/vimade.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/autoload/vimade.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/vimade.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim"
line 0: sourcing "/Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim"
line 1: let g:vimade_loaded = 1
line 2: function! vimade#Load()
line 5: 
line 6: function! vimade#Empty()
line 8: 
line 9: function! vimade#CreateGlobals()
line 29: 
line 30: function! vimade#SetupRenderer()
line 58: 
line 59: function! vimade#SetupPython()
line 78: 
line 79: function! vimade#SetupPythonFeatures()
line 84: 
line 85: function! vimade#GetFeatures()
line 138: 
line 139: function! vimade#GetDefaults()
line 359: 
line 360: function! vimade#Enable()
line 369: 
line 370: function! vimade#WinEnable()
line 376: 
line 377: function! vimade#WinDisable()
line 381: 
line 382: function! vimade#BufEnable()
line 388: 
line 389: function! vimade#BufDisable()
line 393: 
line 394: function! vimade#Disable()
line 403: 
line 404: function! vimade#UnhighlightAll()
line 410: 
line 411: function! vimade#Toggle()
line 419: 
line 420: function! vimade#Override(name)
line 423: 
line 424: function! vimade#OverrideFolded()
line 427: 
line 428: function! vimade#OverrideSignColumn()
line 431: 
line 432: function! vimade#OverrideLineNr()
line 435: 
line 436: function! vimade#OverrideVertSplit()
line 439: 
line 440: function! vimade#OverrideEndOfBuffer()
line 443: 
line 444: function! vimade#OverrideNonText()
line 447: 
line 448: function! vimade#OverrideAll()
line 456: 
line 457: function! vimade#Pause()
line 460: 
line 461: function! vimade#Unpause()
line 464: 
line 465: function! vimade#FocusGained()
line 474: 
line 475: function! vimade#FocusLost()
line 482: 
line 483: function! vimade#InvalidateSigns()
line 493: 
line 494: function! vimade#Recalculate()
line 499: 
line 500: function! vimade#Redraw()
line 509: 
line 510: function! vimade#GetSigns (bufnr, rows)
line 521: 
line 522: function! vimade#GetInfo()
line 546: 
line 547: function! vimade#FadeLevel(level)
line 551: 
line 552: function! vimade#FadePriority(priority)
line 556: 
line 557: function! vimade#DeferredCheckWindows()
line 569: 
line 570: function! vimade#DeferredTick(num)
line 574: 
line 575: function! vimade#CheckWindows()
line 587: 
line 588: function! vimade#StartAnimationTimer()
line 598: 
line 599: function! vimade#DoAnimations(val)
line 606: 
line 607: function! vimade#softInvalidateBuffer(bufnr)
line 618: 
line 619: function! vimade#UpdateEvents()
line 639: 
line 640: function! vimade#ExtendState()
line 647: 
line 648: function! vimade#GetMaybeFromOverlay(field)
line 655: 
line 656: function! vimade#UpdateState()
line 692: 
line 693: function! vimade#Tick(num)
line 709: 
line 710: function! vimade#FadeActive()
line 716: 
line 717: function! vimade#UnfadeActive()
line 723: 
line 724: function! vimade#GetNvimHi(id)
line 733: 
line 734: function! vimade#GetHi(id)
line 739: 
line 740: function! vimade#GetVisibleRows(startRow, endRow)
line 757: 
line 758: function! vimade#StartTimer()
line 766: function! vimade#StopTimer()
line 772: 
line 773: function! vimade#Init()
line 806: 
line 807: " Variables
line 808: let g:vimade_eval_ret = []
line 809: let g:vimade_active_renderer = 0
line 810: let g:vimade_python_setup = 0
line 811: 
line 812: "Empty Renderer START
line 813: let s:empty_renderer = { 'name': 'empty', 'getInfo': function('vimade#Empty'), 'recalculate': function('vimade#Empty'), 'redraw': function('vimade#Empty'), 'disable': function('vimade#Empty'), 'unhighlightAll': function('vimade#Empty'), 'update': function('vimade#Empty'), 'softInvalidateBuffer': function('vimade#Empty'), 'softInvalidateSigns': function('vimade#Empty'), }
line 824: "Empty Renderer END
line 825: "
line 826: let g:vimade_active_renderer = s:empty_renderer 
line 827: 
line 828: 
line 829: function! s:Recalculate_Lua()
line 832: function! s:Redraw_Lua()
line 835: function! s:Disable_Lua()
line 838: function! s:UnhighlightAll_Lua()
line 841: function! s:Update_Lua()
line 844: function! s:Animate_Lua()
line 847: function! s:SoftInvalidateBuffer_Lua()
line 850: function! s:SoftInvalidateSigns_Lua()
line 853: function! s:GetInfo_Lua()
line 856: let s:lua_renderer = { 'name': 'lua', 'animate': function('s:Animate_Lua'), 'getInfo': function('s:GetInfo_Lua'), 'recalculate': function('s:Recalculate_Lua'), 'redraw': function('s:Redraw_Lua'), 'disable': function('s:Disable_Lua'), 'unhighlightAll': function('s:UnhighlightAll_Lua'), 'update': function('s:Update_Lua'), 'softInvalidateBuffer': function('s:SoftInvalidateBuffer_Lua'), 'softInvalidateSigns': function('s:SoftInvalidateSigns_Lua'), }
line 868: " Lua Renderer END
line 869: 
line 870: " Python Renderer START
line 871: function! s:GetInfo_Python()
line 874: function! s:Recalculate_Python()
line 877: function! s:Redraw_Python()
line 881: function! s:Disable_Python()
line 884: function! s:UnhighlightAll_Python()
line 887: function! s:Update_Python()
line 890: function! s:Animate_Python()
line 893: function! s:SoftInvalidateBuffer_Python()
line 896: function! s:SoftInvalidateSigns_Python()
line 899: let s:python_renderer = { 'name': 'python', 'animate': function('s:Animate_Python'), 'getInfo': function('s:GetInfo_Python'), 'recalculate': function('s:Recalculate_Python'), 'redraw': function('s:Redraw_Python'), 'disable': function('s:Disable_Python'), 'unhighlightAll': function('s:UnhighlightAll_Python'), 'update': function('s:Update_Python'), 'softInvalidateBuffer': function('s:SoftInvalidateBuffer_Python'), 'softInvalidateSigns': function('s:SoftInvalidateSigns_Python'), }
line 911: " Python Renderer END
line 912: 
line 913: call vimade#Init()
calling vimade#Init()

line 1:   let l:already_running = 0
line 2:   if exists('g:vimade_init')
line 3:     let l:already_running = 1
line 4:   endif
line 5:   let g:vimade_init = 1
line 6:   call vimade#CreateGlobals()
calling vimade#CreateGlobals()

line 1:   "let g:vimade_lua_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'lua'
line 2:   "let g:vimade_py_v2_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'python-v2'
line 3: 
line 4:   if !exists('g:vimade_running')
line 5:     ""@setting vimade_running
line 6:     "This flag is used to control whether or not vimade should be running.  This can be useful to toggle vimade during startup.  Alternatively, you may as also use VimadeDisable, VimadeEnable, call vimade#Disable, call vimade#Enable respectively
line 7: 
line 8:     let g:vimade_running = 1
line 9:   endif
line 10:   let g:vimade_paused = 0
line 11:   let g:vimade_error_count = 0
line 12:   let g:vimade_fade_active = 0
line 13:   if !exists('g:vimade')
line 14:     let g:vimade = {}
line 15:   endif
line 16:   if !exists('g:vimade_overlay')
line 17:     let g:vimade_overlay = {}
line 18:   endif
vimade#CreateGlobals returning #0

continuing in vimade#Init

line 7:   call vimade#GetFeatures()
calling vimade#GetFeatures()

line 1:   if !exists('g:vimade_features')
line 2:     let g:vimade_features = {}
line 3:     let g:vimade_features.has_gui_running = has('gui_running')
line 4:     let g:vimade_features.has_gui = has('gui')
line 5:     let g:vimade_features.has_nvim = has('nvim')
line 6:     let g:vimade_features.has_vimr = has('gui_vimr')
line 7:     let g:vimade_features.has_timer_start = exists('*timer_start')
line 8:     let g:vimade_features.has_sign_getplaced = exists('*sign_getplaced')
line 9: 
line 10:     if g:vimade_features.has_nvim
line 11:       " Below are for lua renderer
line 12: 
line 13:       " Required:
line 14:       " Required: nvim_win_set_hl_ns
line 15:       let g:vimade_features.has_nvim_win_set_hl_ns = exists('*nvim_win_set_hl_ns')
line 16:       " Required:
line 17:       " Either (preferred) nvim_get_hl
line 18:       let g:vimade_features.has_nvim_get_hl = exists('*nvim_get_hl')
line 19:       " Or (fallback) nvim__get_hl_defs + nvim_get_hl_by_name (assume supported)
line 20:       let g:vimade_features.has__nvim_get_hl_defs = exists('*nvim__get_hl_defs')
line 21:       
line 22:       "Optional:
line 23:       " preferred but not required nvim_get_hl_ns
line 24:       " fallback is try and manually track (probably will have conflicts with some plugins)
line 25:       let g:vimade_features.has_nvim_get_hl_ns = exists('*nvim_get_hl_ns')
line 26: 
line 27:       let g:vimade_features.supports_lua_renderer = (g:vimade_features.has_nvim_get_hl || g:vimade_features.has__nvim_get_hl_defs) && g:vimade_features.has_nvim_win_set_hl_ns
line 28:       let g:vimade_features.has_wincolor = 0
line 29:       let g:vimade_features.has_gui_version = 0
line 30:     else
line 31:       let g:vimade_features.has_nvim_win_set_hl_ns = 0
line 32:       let g:vimade_features.has_nvim_get_hl = 0
line 33:       let g:vimade_features.has__nvim_get_hl_defs = 0
line 34:       let g:vimade_features.has_nvim_get_hl_ns = 0
line 35:       let g:vimade_features.supports_lua_renderer = 0
line 36:       let g:vimade_features.has_wincolor = exists('&wincolor')
line 37:       let g:vimade_features.has_gui_version = execute('version')=~"GUI version"
line 38:     endif
line 39: 
line 40:     try
line 41:       sign define Vimade_Test text=1
line 42:       sign place 1 group=vimade line=1 name=Vimade_Test priority=100
line 43:       sign unplace 1 group=vimade
line 44:       let g:vimade_features.has_sign_group = 1
line 45:       let g:vimade_features.has_sign_priority = 1
line 46:     catch
line 47:       let g:vimade_features.has_sign_group = 0
line 48:       let g:vimade_features.has_sign_priority = 0
line 49:     endtry
line 50:   endif
line 51:   return g:vimade_features
vimade#GetFeatures returning {'has_sign_getplaced': 1, 'has_gui_run..._set_hl_ns': 1, 'has_sign_priority': 1}

continuing in vimade#Init

line 8:   call vimade#GetDefaults()
calling vimade#GetDefaults()

line 1:   if !exists('g:vimade_defaults')
line 2: 
line 3:     ""The vimade configuration object
line 4:     "@setting vimade
line 5:     
line 6:     let g:vimade_defaults = {'$extended': 1}
line 7: 
line 8:     ""@setting vimade.renderer
line 9:     "Select the renderer to use for vimade window/buffer highlights.
line 10:     "If not specificed, defaults to 'auto'. It is recommended to leave this
line 11:     "option set to 'auto', 'lua', or 'python'.
line 12:     "Current options are:
line 13:     "  - 'auto' - Uses lua renderer if supported on your Neovim version. Otherwise, this option will automatically fallback to 'python'.
line 14:     "  - 'python' - Uses a new high performance renderer compatible with Vim and Neovim
line 15: 
line 16:     let g:vimade_defaults.renderer = 'auto'
line 17: 
line 18:     ""@setting vimade.fadelevel
line 19:     "Supported:     lua, python
line 20:     "Amount of fading applied between text and basebg.  0 will make the text the same color as the background and 1 applies no fading.  The default value is 0.4.  If you are using terminal, you may need to tweak this value to get better results.
line 21: 
line 22:     let g:vimade_defaults.fadelevel = 0.4
line 23:     
line 24:     ""@setting vimade.tint
line 25:     "Supported:     lua, python
line 26:     "Amount and type of tinting to apply. Unset by default.  This param is currently under maintainence. This function can currently be either a config object such as:
line 27:     "{'fg':{'rgb':[255,0,0], 'intensity': 0.5, 'type': 'MIX'}, 'bg':{'rgb':[255,0,0], 'type': 'REPLACE'}, 'sp': {'rgb':[255,0,0], 'type': 'MIX'}}
line 28:     "The fields in the object are completely optional (you can peform a bg-only or fg-only tint)
line 29:     "You can also set g:vimade.tint to a lua or python function that returns the tint object.
line 30:     "Lua
line 31:     "require('vimade').setup({
line 32:     " tint = function (win)
line 33:     "   return {
line 34:     "    fg = {
line 35:     "      rgb={255,0,0},
line 36:     "      intensity = 0.75,
line 37:     "    },
line 38:     "  }
line 39:     " end
line 40:     "})
line 41:     "Python
line 42:     "from vimade.v2 import vimade
line 43:     "vimade.setup({
line 44:     " 'tint': lambda a,test : {'fg':{'rgb':[255,0,0], 'intensity': 0.5}}
line 45:     "})
line 46: 
line 47:     ""@setting vimade.basebg
line 48:     "Supported:     lua, python
line 49:     "basebg can be either be six digit hexidecimal color, rgb array [0-255,0-255,0-255], or cterm code (in terminal).  basebg is used as the color that text is faded against.  You can override this config with another hexidecimal color.  A cool feature of basebg is to use it to change the tint of faded text even if its not your background!
line 50: 
line 51:     let g:vimade_defaults.basebg = ''
line 52: 
line 53:     ""@setting vimade.ncmode
line 54:     "Supported:     lua, python
line 55:     "Whether to fade active windows or buffers.  Options are 'windows' or 'buffers'.  Defaults to 'buffers'.
line 56: 
line 57:     let g:vimade_defaults.ncmode = 'buffers'
line 58: 
line 59:     ""@setting vimade.fadecondition
line 60:     "Supported:     lua, python
line 61:     "TODO docs
line 62: 
line 63:     "Can be set via vim object
line 64:     ""@setting vimade.blocklist
line 65:     "Supported:     lua, python
line 66:     "TODO docs
line 67: 
line 68:     ""@setting vimade.link
line 69:     "Supported:     lua, python
line 70:     "Controls whether or not diffs will fade/unfade together.
line 71:     "TODO docs
line 72: 
line 73: 
line 74:     ""@setting vimade.groupdiff
line 75:     "Supported:     lua, python
line 76:     "Controls whether or not diffs will fade/unfade together.  If you want diffs
line 77:     "to be treated separately, set this value to 0. Default is 1
line 78: 
line 79:     let g:vimade_defaults.groupdiff = 1
line 80: 
line 81:     ""@setting vimade.groupscrollbind
line 82:     "Supported:     lua, python
line 83:     "Controls whether or not scrollbound windows will fade/unfade together.  If
line 84:     "you want scrollbound windows to unfade together, set this to 1.  Default is
line 85:     "0.
line 86:     
line 87:     let g:vimade_defaults.groupscrollbind = 0
line 88: 
line 89:     ""@setting vimade.enablefocusfading
line 90:     "Supported:     lua, python
line 91:     "Fades the current active window on focus blur and unfades when focus gained.
line 92:     "This can be desirable when switching applications or TMUX splits.
line 93:     "* Install 'tmux-plugins/vim-tmux-focus-events' using your preferred plugin manager
line 94:     "* Add `set -g focus-events on` to your tmux.conf
line 95:     "* Neovim should work at this point, If you are using Vim you may also need the following snippet to the very end of your vimrc
line 96:     ">
line 97:     "  if has('gui_running') == 0 && has('nvim') == 0
line 98:     "     call feedkeys(":silent execute '!' | redraw!\<CR>")
line 99:     "  endif
line 100:     "<
line 101: 
line 102:     let g:vimade_defaults.enablefocusfading = 0
line 103:    
line 104:     ""@setting vimade.normalid
line 105:     "Supported:     lua, python
line 106:     "If not specified, the normalid is determined when vimade is first loaded.  normalid provides the id of the "Normal" highlight which is used to calculate fading.  You can override this config with another highlight group.
line 107:     "You shouldn't really ever need to modify this.
line 108: 
line 109:     let g:vimade_defaults.normalid = ''
line 110: 
line 111:     ""@setting vimade.normalncid
line 112:     "Supported:     lua, python
line 113:     "If not specified, the normalncid is determined when vimade is first loaded.  normalncid provides the id of the "NormalNC" highlight which is used to calculate fading for inactive buffers in NVIM.  You can override this config with another highlight group.
line 114:     "You shouldn't really ever need to modify this.
line 115: 
line 116:     let g:vimade_defaults.normalncid = ''
line 117: 
line 118:     ""@setting vimade.checkinterval
line 119:     "Supported:     lua, python
line 120:     "The amount of time in milliseconds that vimade should check the screen for changes.  This config is mainly used to detect resize and scroll changes that occur on inactive windows. Checkinterval does nothing on gvim, if you want to control the refresh time, see 'h updatetime'. Default is 1000.  
line 121: 
line 122:     let g:vimade_defaults.checkinterval = 1000
line 123: 
line 124:     ""@setting vimade.usecursorhold
line 125:     "Supported:     lua, python
line 126:     "Disables the timer running in the background and instead relies `OnCursorHold` and `updatetime` (see h:updatetime).  The default value is `0` except on older Windows GVIM, which defaults to `1` due to the timer breaking movements.  If you find that the timer is causing performance problems or other issues you can disable it by setting this option to `1`. 
line 127: 
line 128:     let g:vimade_defaults.usecursorhold = g:vimade_features.has_gui_running && !g:vimade_features.has_nvim && g:vimade_features.has_gui_version
line 129: 
line 130:     ""@setting vimade.basegroups
line 131:     "Supported:     python
line 132:     "lua uses namespaces and doesn't require this setting.
line 133:     "Neovim only setting that specifies the basegroups/built-in highlight groups that will be faded using winhl when switching windows
line 134: 
line 135:     let g:vimade_defaults.basegroups = ['Folded', 'Search', 'SignColumn', 'CursorLine', 'CursorLineNr', 'DiffAdd', 'DiffChange', 'DiffDelete', 'DiffText', 'FoldColumn', 'Whitespace', 'NonText', 'SpecialKey', 'Conceal', 'EndOfBuffer', 'WinSeparator', 'LineNr', 'LineNrAbove', 'LineNrBelow']
line 136: 
line 137:     ""@setting vimade.enablebasegroups
line 138:     "Supported:     python
line 139:     "lua uses namespaces and doesn't require this setting.
line 140:     "Neovim only setting.  Enabled by default and allows basegroups/built-in highlight fading using winhl.  This allows fading of built-in highlights such as Folded, Search, etc.
line 141: 
line 142:     let g:vimade_defaults.enablebasegroups = 1
line 143: 
line 144: 
line 145:     ""@setting vimade.enabletreesitter
line 146:     "Supported:     python
line 147:     "lua uses namespaces and doesn't require this setting.
line 148:     "Neovim only setting.  Disabled by default and hooks vimade into the internals of treesitter.
line 149: 
line 150:     let g:vimade_defaults.enabletreesitter = 0
line 151: 
line 152:     ""@setting vimade.enablesigns
line 153:     "Supported:     python
line 154:     "lua renderer doesn't require additional logic to fade signs.
line 155:     "Enabled by default for vim/nvim versions that support sign priority and causes signs to be faded when switching buffers.
line 156:     "Only visible signs are faded. This feature can cause performance issues
line 157:     "on older nvim/vim versions that don't support sign priority. 
line 158:     "Use signsretentionperiod to control the duration that vimade checks for sign updates after switching buffers.
line 159: 
line 160:     let g:vimade_defaults.enablesigns = g:vimade_features.has_sign_priority
line 161: 
line 162:     ""@setting vimade.signsid
line 163:     "Supported:     python
line 164:     "lua renderer doesn't require additional logic to fade signs.
line 165:     "The starting id that Vimade should use when creating new signs. By
line 166:     "default Vim requires numeric values to create signs and its possible that
line 167:     "collisions may occur between plugins.  If you need to override this value for
line 168:     "compatibility, please open an issue as well.  Default is 13100.
line 169: 
line 170:     let g:vimade_defaults.signsid = 13100
line 171: 
line 172:     ""@setting vimade.signsretentionperiod
line 173:     "Supported:     python
line 174:     "lua renderer doesn't require additional logic to fade signs.
line 175:     " *python*: Serves no purpose on lua renderer.
line 176:     "Amount of time in milliseconds that faded buffers should be tracked for sign changes.  Default value is 4000.
line 177: 
line 178:     let g:vimade_defaults.signsretentionperiod = 4000
line 179: 
line 180:     ""@setting vimade.signspriority
line 181:     "Supported:     python
line 182:     "lua renderer doesn't require additional logic to fade signs.
line 183:     "Controls the signs fade priority.
line 184:     "You may need to change this value if you find that not all signs are fading properly.
line 185:     "Please also open a defect if you need to tweak this value as Vimade strives to minimize manual configuration where possible.
line 186:     "Default is 31.
line 187: 
line 188:     let g:vimade_defaults.signspriority = 31
line 189: 
line 190:     ""@setting vimade.fademinimap
line 191:     "Supported:     lua, python
line 192:     "Enables fading for `severin-lemaignan/vim-minimap`. Setting vimade.fademinimap to
line 193:     "0 disables the special fade.  Default is 1.
line 194: 
line 195:     let g:vimade_defaults.fademinimap = 1
line 196: 
line 197:     ""@setting vimade.fadepriority
line 198:     "Supported:     python
line 199:     "lua uses namespaces and doesn't require priority settings
line 200:     "Controls the highlighting priority.
line 201:     "You may want to tweak this value to make Vimade play nicely with other highlighting plugins and behaviors.
line 202:     "For example, if you want hlsearch to show results on all buffers, you may want to lower this value to 0.
line 203:     "Default is 10.
line 204: 
line 205:     let g:vimade_defaults.fadepriority = 10
line 206: 
line 207:     ""@setting vimade.disablebatch
line 208:     "Supported:     python
line 209:     "Disables interprocess batching. Useful if you are seeing issues and need to debug an error.
line 210: 
line 211:     let g:vimade_defaults.disablebatch = 0
line 212: 
line 213:     let g:vimade_defaults_keys = keys(g:vimade_defaults)
line 214:     if exists('g:vimade_usecursorhold')
line 215:       let g:vimade.usecursorhold = g:vimade_usecursorhold
line 216:     endif
line 217:   endif
line 218:   return g:vimade_defaults
vimade#GetDefaults returning {'ncmode': 'buffers', 'enablesigns': 1...focusfading': 0, 'checkinterval': 1000}

continuing in vimade#Init

line 9:   call vimade#ExtendState()
calling vimade#ExtendState()

line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
line 1:   for prop in g:vimade_defaults_keys
line 2:     if !has_key(g:vimade, prop)
line 3:       let g:vimade[prop] = g:vimade_defaults[prop]
line 4:     endif
line 5:   endfor
vimade#ExtendState returning #0

continuing in vimade#Init

line 10:   call vimade#UpdateEvents()
calling vimade#UpdateEvents()

line 1:   augroup vimade
line 2:       au!
line 3:       au VimLeave * call vimade#Disable()
line 4:       au FocusGained * call vimade#FocusGained()
line 5:       au FocusLost * call vimade#FocusLost()
line 6:       " TODO neovim is broken in many scenarios in v0.10. Python logic is not
line 7:       " executed properly when called directly off and autoevent. This is
line 8:       " easily reproduceable when using netrw...
line 9:       au WinEnter,BufEnter * call vimade#DeferredCheckWindows()
line 10:       au OptionSet diff call vimade#DeferredCheckWindows()
line 11:       au ColorScheme * call vimade#Redraw()
line 12:       au FileChangedShellPost * call vimade#softInvalidateBuffer(expand("<abuf>"))
line 13:       let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateEvents

line 14:       if usecursorhold
line 15:         au CursorHold,CursorHoldI * call vimade#DeferredCheckWindows()
line 16:         au VimResized * call vimade#DeferredCheckWindows()
line 17:       endif
line 18:   augroup END
vimade#UpdateEvents returning #0

continuing in vimade#Init

line 11: 
line 12:   let g:vimade_last = extend({}, g:vimade)
line 13: 
line 14:   "check immediately
line 15:   if l:already_running == 0
line 16:     call vimade#DeferredCheckWindows()
calling vimade#DeferredCheckWindows()

line 1:   if g:vimade_features.has_timer_start
line 2:     " only disable the deferred on animation for lua (lua doesn't
line 3:     " only_these_windows)
line 4:     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
line 5:       return
line 6:     endif
line 7:     let g:vimade_deferred_timer = timer_start(1, 'vimade#DeferredTick')
line 8:   else
line 9:     return vimade#CheckWindows()
line 10:   endif
vimade#DeferredCheckWindows returning #0

continuing in vimade#Init

line 17:   else
line 18:     call vimade#Redraw()
line 19:   endif
line 20:   call vimade#StartTimer()
calling vimade#StartTimer()

line 1:   "timer is disabled when usecursorhold=1
line 2:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#StartTimer

line 3:   if !usecursorhold && !exists('g:vimade_timer') && g:vimade_running
line 4:     let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#StartTimer

line 5:     let g:vimade_timer = timer_start(checkinterval, 'vimade#Tick', {'repeat': -1})
line 6:   endif
vimade#StartTimer returning #0

continuing in vimade#Init

line 21: 
line 22:   "run the timer once during startup
line 23:   "we use try here to possibly support vim 7
line 24:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#Init

line 25:   if usecursorhold
line 26:     let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
line 27:     try
line 28:       call timer_start(checkinterval, 'vimade#Tick')
line 29:     catch
line 30:     endtry
line 31:   endif
vimade#Init returning #0

continuing in /Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim

finished sourcing /Users/joe/.local/share/nvim/lazy/vimade/autoload/vimade.vim
continuing in VimEnter Autocommands for "*"
calling vimade#Load()

line 1:   " empty hook to initiate loading
vimade#Load returning #0

continuing in VimEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand <Lua 426: ~/.local/share/nvim/lazy/mason-tool-installer.nvim/lua/mason-tool-installer/init.lua:267>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 74: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:327>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 207: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 516: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/osc52.lua:8>

Executing: 
Executing UIEnter Autocommands for "*"
autocommand <Lua 82: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:189>

Executing: 
Executing SafeState Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

sourcing "nvim_exec2()"
line 1: autocmd User CocDiagnosticChange lua require('bufferline.diagnostics').refresh_coc_diagnostics()
finished sourcing nvim_exec2()
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 68: vim/_defaults.lua:0>

Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 560: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 558: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/termcap.lua:36>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 560: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
Executing ColorSchemePre Autocommands for "*"
autocommand <Lua 77: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/loader.lua:31>

Executing: 
Searching for "colors/catppuccin.*" in runtime path
Searching for "/Users/joe/.config/nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/colors/catppuccin.*"
Searching for "/Users/joe/git/joe-p/fetch.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/colors/catppuccin.*"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.*"
sourcing "/Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim"
line 1: lua require("catppuccin").load()
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "background"
autocommand <Lua 560: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:448>

Executing: 
finished sourcing /Users/joe/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim
Executing ColorScheme Autocommands for "*"
autocommand <Lua 285: ~/.local/share/nvim/lazy/mini.icons/lua/mini/icons.lua:1998>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 78: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:947>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 270: ~/.local/share/nvim/lazy/mini.nvim/lua/mini/surround.lua:1229>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/mini.nvim/lua/mini/statusline.lua:538>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 316: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:587>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 356: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:111>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 398: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/highlight.lua:275>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand lua vim.defer_fn(require("todo-comments.config").colors, 10)

Executing: lua vim.defer_fn(require("todo-comments.config").colors, 10)
Executing ColorScheme Autocommands for "*"
autocommand call vimade#Redraw()

Executing: call vimade#Redraw()
calling vimade#Redraw()

line 1:   "prevent if inside popup window
line 2:   if winnr() == 0
line 3:     return
line 4:   endif
line 5:   if g:vimade_running && g:vimade_paused == 0
line 6:     call g:vimade_active_renderer.redraw()
calling vimade#Empty()

vimade#Empty returning #0

continuing in vimade#Redraw

line 7:   endif
vimade#Redraw returning #0

continuing in ColorScheme Autocommands for "*"

Executing ColorScheme Autocommands for "*"
autocommand <Lua 370: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/util/init.lua:19>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 561: ~/.local/share/nvim/lazy/nvim-web-devicons/lua/nvim-web-devicons.lua:152>

Executing: 
Executing BufReadPre Autocommands for "*"
autocommand <Lua 167: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at BufReadPre Autocommands for "*":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at BufReadPre Autocommands for "*":0
continuing in BufReadPre Autocommands for "*"
line 0: sourcing "nvim_exec2() called at BufReadPre Autocommands for "*":0"
line 1: augroup END
finished sourcing nvim_exec2() called at BufReadPre Autocommands for "*":0
continuing in BufReadPre Autocommands for "*"
Executing: 
Executing BufReadPre Autocommands for "*"
autocommand <Lua 205: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing Syntax Autocommands for "*"
autocommand call s:SynSet()

Executing: call s:SynSet()
calling <SNR>85_SynSet()

line 1:   " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
line 2:   syn clear
line 3:   if exists("b:current_syntax")
line 4:     unlet b:current_syntax
line 5:   endif
line 6: 
line 7:   0verbose let s = expand("<amatch>")
line 8:   if s == "ON"
line 9:     " :set syntax=ON
line 10:     if &filetype == ""
line 11:       echohl ErrorMsg
line 12:       echo "filetype unknown"
line 13:       echohl None
line 14:     endif
line 15:     let s = &filetype
line 16:   elseif s == "OFF"
line 17:     let s = ""
line 18:   endif
line 19: 
line 20:   if s != ""
line 21:     " Load the syntax file(s).  When there are several, separated by dots,
line 22:     " load each in sequence.  Skip empty entries.
line 23:     for name in split(s, '\.')
line 24:       if !empty(name)
line 25:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 26:         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
line 26: runtime! syntax/oil[.]{vim,lua} syntax/oil/*.{vim,lua}
Searching for "syntax/oil[.]{vim,lua} syntax/oil/*.{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.config/nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/syntax/oil[.]{vim,lua}"
line 26: sourcing "/Users/joe/.local/share/nvim/lazy/oil.nvim/syntax/oil.vim"
line 1: if exists("b:current_syntax")
line 2:   finish
line 3: endif
line 4: 
line 5: syn match oilId /^\/\d* / conceal
line 6: 
line 7: let b:current_syntax = "oil"
finished sourcing /Users/joe/.local/share/nvim/lazy/oil.nvim/syntax/oil.vim
continuing in <SNR>85_SynSet
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/syntax/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/syntax/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/syntax/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/syntax/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/syntax/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/syntax/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/syntax/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/syntax/oil/*.{vim,lua}"
line 27:       endif
line 28:     endfor
line 23:     for name in split(s, '\.')
line 24:       if !empty(name)
line 25:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 26:         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
line 27:       endif
line 28:     endfor
line 29:   endif
<SNR>85_SynSet returning #0

continuing in Syntax Autocommands for "*"

Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}
Searching for "ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.config/nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.config/nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil/*.{vim,lua}"
not found in runtime path: "ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/oil[.]{vim,lua}
Searching for "indent/oil[.]{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/indent/oil[.]{vim,lua}"
not found in runtime path: "indent/oil[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand <Lua 325: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/install.lua:558>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 326: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 327: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 330: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif

Executing: if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif
Executing:  exe s:Init(0, 0, 0, 1) | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing BufDelete Autocommands for "*"
autocommand <Lua 294: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:226>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 192: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/filetype.lua:10>

Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}
Searching for "ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.config/nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.config/nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/oil/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/ftplugin/oil/*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil_*.{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/ftplugin/oil/*.{vim,lua}"
not found in runtime path: "ftplugin/oil[.]{vim,lua} ftplugin/oil_*.{vim,lua} ftplugin/oil/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/oil[.]{vim,lua}
Searching for "indent/oil[.]{vim,lua}" in runtime path
Searching for "/Users/joe/.config/nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/git/joe-p/fetch.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/pack/dist/opt/matchit/indent/oil[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/lib/nvim/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/state/nvim/lazy/readme/indent/oil[.]{vim,lua}"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/after/indent/oil[.]{vim,lua}"
not found in runtime path: "indent/oil[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand <Lua 325: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/install.lua:558>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 326: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 327: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 330: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif

Executing: if exists('b:sleuth') | exe s:Init(0, 0, 0, 1) | endif
Executing:  exe s:Init(0, 0, 0, 1) | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing: 
autocommand if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif

Executing: if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif
Executing:  runtime! scripts.vim | endif
Executing:  endif
Executing BufReadPost Autocommands for "*"
autocommand <Lua 206: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:222>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 358: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:136>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 400: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns.lua:143>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif

Executing: if get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
Executing:  exe s:AutoInit() | endif
calling <SNR>65_AutoInit()

line 1:   return s:Init(1, 1, 1, 1)
calling <SNR>65_Init(1, 1, 1, 1)

line 1:   if !a:redetect && exists('b:sleuth.defaults')
line 2:     let detected = b:sleuth
line 3:   endif
line 4:   unlet! b:sleuth
line 5:   if &l:buftype !~# '^\%(nowrite\|nofile\|acwrite\)\=$'
line 6:     return s:Warn(':Sleuth disabled for buftype=' . &l:buftype, a:silent)
line 7:   endif
line 8:   if &l:filetype ==# 'netrw'
line 9:     return s:Warn(':Sleuth disabled for filetype=' . &l:filetype, a:silent)
line 10:   endif
line 11:   if &l:binary
line 12:     return s:Warn(':Sleuth disabled for binary files', a:silent)
line 13:   endif
line 14:   if !exists('detected')
line 15:     let detected = s:DetectDeclared()
calling <SNR>65_DetectDeclared()

line 1:   let detected = {'bufname': s:Slash(@%), 'declared': {}}
calling <SNR>65_Slash('oil:///Users/joe/git/joe-p/fetch.nvim/')

line 1:     return a:path
<SNR>65_Slash returning 'oil:///Users/joe/git/joe-p/fetch.nvim/'

continuing in <SNR>65_DetectDeclared

line 2:   let absolute_or_empty = detected.bufname =~# '^$\|^\a\+:\|^/'
line 3:   if &l:buftype =~# '^\%(nowrite\)\=$' && !absolute_or_empty
line 4:     let detected.bufname = substitute(s:Slash(getcwd()), '/\=$', '/', '') . detected.bufname
line 5:     let absolute_or_empty = 1
line 6:   endif
line 7:   let detected.path = absolute_or_empty ? detected.bufname : ''
line 8:   let pre = substitute(matchstr(detected.path, '^\a\a\+\ze:'), '^\a', '\u&', 'g')
line 9:   if len(pre) && exists('*' . pre . 'Real')
line 10:     let detected.path = s:Slash(call(pre . 'Real', [detected.path]))
line 11:   endif
line 12: 
line 13:   try
line 14:     if len(detected.path) && exists('*ExcludeBufferFromDiscovery') && !empty(ExcludeBufferFromDiscovery(detected.path, 'sleuth'))
line 15:       let detected.path = ''
line 16:     endif
line 17:   catch
line 18:   endtry
line 19:   let [detected.editorconfig, detected.root] = s:DetectEditorConfig(detected.path)
calling <SNR>65_DetectEditorConfig('oil:///Users/joe/git/joe-p/fetch.nvim/')

line 1:   if empty(a:absolute_path)
line 2:     return [{}, '']
line 3:   endif
line 4:   let root = ''
line 5:   let tail = a:0 ? a:1 : '.editorconfig'
line 6:   let dir = fnamemodify(a:absolute_path, ':h')
line 7:   let previous_dir = ''
line 8:   let sections = []
line 9:   let overrides = get(g:, 'sleuth_editorconfig_overrides', {})
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 34: 
line 35:   let config = {}
line 36:   for [pattern, pairs] in sections
line 37:     if a:absolute_path =~# pattern
line 38:       call extend(config, pairs)
line 39:     endif
line 40:   endfor
line 41: 
line 42:   return [config, root]
<SNR>65_DetectEditorConfig returning [{}, '']

continuing in <SNR>65_DetectDeclared

line 20:   call extend(detected.declared, s:EditorConfigToOptions(detected.editorconfig))
calling <SNR>65_EditorConfigToOptions({})

line 1:   let options = {}
line 2:   let pairs = map(copy(a:pairs), 'v:val[0]')
line 3:   let sources = map(copy(a:pairs), 'v:val[1:-1]')
line 4:   call filter(pairs, 'v:val !=? "unset"')
line 5: 
line 6:   if get(pairs, 'indent_style', '') ==? 'tab'
line 7:     let options.expandtab = [0] + sources.indent_style
line 8:   elseif get(pairs, 'indent_style', '') ==? 'space'
line 9:     let options.expandtab = [1] + sources.indent_style
line 10:   endif
line 11: 
line 12:   if get(pairs, 'indent_size', '') =~? '^[1-9]\d*$\|^tab$'
line 13:     let options.shiftwidth = [str2nr(pairs.indent_size)] + sources.indent_size
line 14:     if &g:shiftwidth == 0 && !has_key(pairs, 'tab_width') && pairs.indent_size !=? 'tab'
line 15:       let options.tabstop = options.shiftwidth
line 16:       let options.shiftwidth = [0] + sources.indent_size
line 17:     endif
line 18:   endif
line 19: 
line 20:   if get(pairs, 'tab_width', '') =~? '^[1-9]\d*$'
line 21:     let options.tabstop = [str2nr(pairs.tab_width)] + sources.tab_width
line 22:     if !has_key(pairs, 'indent_size') && get(pairs, 'indent_style', '') ==? 'tab'
line 23:       let options.shiftwidth = [0] + options.tabstop[1:-1]
line 24:     endif
line 25:   endif
line 26: 
line 27:   if get(pairs, 'max_line_length', '') =~? '^[1-9]\d*$\|^off$'
line 28:     let options.textwidth = [str2nr(pairs.max_line_length)] + sources.max_line_length
line 29:   endif
line 30: 
line 31:   if get(pairs, 'insert_final_newline', '') =~? '^true$\|^false$'
line 32:     let options.endofline = [pairs.insert_final_newline ==? 'true'] + sources.insert_final_newline
line 33:     let options.fixendofline = copy(options.endofline)
line 34:   endif
line 35: 
line 36:   let eol = tolower(get(pairs, 'end_of_line', ''))
line 37:   if has_key(s:editorconfig_fileformat, eol)
line 38:     let options.fileformat = [s:editorconfig_fileformat[eol]] + sources.end_of_line
line 39:   endif
line 40: 
line 41:   let charset = tolower(get(pairs, 'charset', ''))
line 42:   if has_key(s:editorconfig_bomb, charset)
line 43:     let options.bomb = [s:editorconfig_bomb[charset]] + sources.charset
line 44:     let options.fileencoding = [substitute(charset, '\C-bom$', '', '')] + sources.charset
line 45:   endif
line 46: 
line 47:   let filetype = tolower(get(pairs, 'vim_filetype', 'unset'))
line 48:   if filetype !=# 'unset' && filetype =~# '^[.a-z0-9_-]*$'
line 49:     let options.filetype = [substitute(filetype, '^\.\+\|\.\+$', '', 'g')] + sources.vim_filetype
line 50:   endif
line 51: 
line 52:   return options
<SNR>65_EditorConfigToOptions returning {}

continuing in <SNR>65_DetectDeclared

line 21:   call extend(detected.declared, s:ModelineOptions())
calling <SNR>65_ModelineOptions()

line 1:   let options = {}
line 2:   if !&l:modeline && (&g:modeline || s:Capture('setlocal') =~# '\\\@<![[:space:]]nomodeline\>' && s:Capture('verbose setglobal modeline?') !=# s:Capture('verbose setlocal modeline?'))
line 4:     return options
line 5:   endif
line 6:   let modelines = get(b:, 'sleuth_modelines', get(g:, 'sleuth_modelines', 5))
line 7:   if line('$') > 2 * modelines
line 8:     let lnums = range(1, modelines) + range(line('$') - modelines + 1, line('$'))
line 9:   else
line 10:     let lnums = range(1, line('$'))
line 11:   endif
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
calling <SNR>65_ParseOptions([], {}, 'modeline', 1)

line 1:   for option in a:declarations
line 2:     if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
line 3:       let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
line 4:     elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
line 5:       let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
line 6:     elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
line 7:       let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
line 8:     endif
line 9:     if option ==# 'nomodeline' || option ==# 'noml'
line 10:       return 1
line 11:     endif
line 12:   endfor
line 13:   return 0
<SNR>65_ParseOptions returning #0

continuing in <SNR>65_ModelineOptions

line 16:       break
line 17:     endif
line 18:   endfor
line 12:   for lnum in lnums
line 13:     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
line 16:       break
line 17:     endif
line 18:   endfor
line 19:   return options
<SNR>65_ModelineOptions returning {}

continuing in <SNR>65_DetectDeclared

line 22:   return detected
<SNR>65_DetectDeclared returning {'root': '', 'path': 'oil:///Users/joe.../', 'declared': {}, 'editorconfig': {}}

continuing in <SNR>65_Init

line 16:   endif
line 17:   let setfiletype = ''
line 18:   if a:do_filetype && has_key(detected.declared, 'filetype')
line 19:     let filetype = detected.declared.filetype[0]
line 20:     if filetype !=# &l:filetype || empty(filetype)
line 21:       let setfiletype = 'setlocal filetype=' . filetype
line 22:     else
line 23:       let setfiletype = 'setfiletype ' . filetype
line 24:     endif
line 25:   endif
line 26:   exe setfiletype
line 26: 
line 27:   call s:DetectHeuristics(detected)
calling <SNR>65_DetectHeuristics({'root': '', 'path': 'oil:///Users/joe.../', 'declared': {}, 'editorconfig': {}})

line 1:   let detected = a:into
line 2:   let filetype = split(&l:filetype, '\.', 1)[0]
line 3:   if get(detected, 'filetype', '*') ==# filetype
line 4:     return detected
line 5:   endif
line 6:   let detected.filetype = filetype
line 7:   let options = copy(detected.declared)
line 8:   let detected.options = options
line 9:   let detected.heuristics = {}
line 10:   if has_key(detected, 'patterns')
line 11:     call remove(detected, 'patterns')
line 12:   endif
line 13:   let detected.defaults = s:UserOptions(filetype, 'defaults')
calling <SNR>65_UserOptions('oil', 'defaults')

line 1:   if exists('b:sleuth_' . a:name)
line 2:     let source = 'b:sleuth_' . a:name
line 3:   elseif exists('g:sleuth_' . a:ft . '_' . a:name)
line 4:     let source = 'g:sleuth_' . a:ft . '_' . a:name
line 5:   endif
line 6:   if !exists('l:source') || type(eval(source)) == type(function('tr'))
line 7:     return {}
<SNR>65_UserOptions returning {}

continuing in <SNR>65_DetectHeuristics

line 14:   if empty(filetype) || !get(b:, 'sleuth_automatic', 1) || empty(get(b:, 'sleuth_heuristics', get(g:, 'sleuth_' . filetype . '_heuristics', get(g:, 'sleuth_heuristics', 1))))
line 15:     return detected
line 16:   endif
line 17:   if s:Ready(detected)
calling <SNR>65_Ready({'root': '', 'options': {}, 'defaults'... 'editorconfig': {}, 'filetype': 'oil'})

line 1:   return has_key(a:detected.options, 'expandtab') && has_key(a:detected.options, 'shiftwidth')
<SNR>65_Ready returning #0

continuing in <SNR>65_DetectHeuristics

line 18:     return detected
line 19:   endif
line 20: 
line 21:   let lines = getline(1, 1024)
line 22:   call s:Guess(detected.bufname, detected, lines)
calling <SNR>65_Guess('oil:///Users/joe/git/joe-p/fetch.nvim/', {'root': '', 'options': {}, 'defaults'... 'editorconfig': {}, 'filetype': 'oil'}, [''])

line 1:   let has_heredocs = a:detected.filetype =~# '^\%(perl\|php\|ruby\|[cz]\=sh\|bash\)$'
line 2:   let options = {}
line 3:   let heuristics = {'spaces': 0, 'hard': 0, 'soft': 0, 'checked': 0, 'indents': {}}
line 4:   let tabstop = get(a:detected.options, 'tabstop', get(a:detected.defaults, 'tabstop', [8]))[0]
line 5:   let softtab = repeat(' ', tabstop)
line 6:   let waiting_on = ''
line 7:   let prev_indent = -1
line 8:   let prev_line = ''
line 9: 
line 10:   for line in a:lines
line 11:     if len(waiting_on)
line 12:       if line =~# waiting_on
line 13:         let waiting_on = ''
line 14:         let prev_indent = -1
line 15:         let prev_line = ''
line 16:       endif
line 17:       continue
line 18:     elseif line =~# '^\s*$'
line 19:       continue
line 10:   for line in a:lines
line 11:     if len(waiting_on)
line 12:       if line =~# waiting_on
line 13:         let waiting_on = ''
line 14:         let prev_indent = -1
line 15:         let prev_line = ''
line 16:       endif
line 17:       continue
line 18:     elseif line =~# '^\s*$'
line 19:       continue
line 20:     elseif a:detected.filetype ==# 'python' && prev_line[-1:-1] =~# '[[\({]'
line 21:       let prev_indent = -1
line 22:       let prev_line = ''
line 23:       continue
line 24:     elseif line =~# '^=\w' && line !~# '^=\%(end\|cut\)\>'
line 25:       let waiting_on = '^=\%(end\|cut\)\>'
line 26:     elseif line =~# '^@@\+ -\d\+,\d\+ '
line 27:       let waiting_on = '^$'
line 28:     elseif line !~# '[/<"`]'
line 29:       " No need to do other checks
line 30:     elseif line =~# '^\s*/\*' && line !~# '\*/'
line 31:       let waiting_on = '\*/'
line 32:     elseif line =~# '^\s*<\!--' && line !~# '-->'
line 33:       let waiting_on = '-->'
line 34:     elseif line =~# '^[^"]*"""'
line 35:       let waiting_on = '^[^"]*"""'
line 36:     elseif a:detected.filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
line 37:       let waiting_on = '^[^`]*`[^`]*$'
line 38:     elseif has_heredocs
line 39:       let waiting_on = matchstr(line, '<<\s*\([''"]\=\)\zs\w\+\ze\1[^''"`<>]*$')
line 40:       if len(waiting_on)
line 41:         let waiting_on = '^' . waiting_on . '$'
line 42:       endif
line 43:     endif
line 44: 
line 45:     let indent = len(matchstr(substitute(line, '\t', softtab, 'g'), '^ *'))
line 46:     if line =~# '^\t'
line 47:       let heuristics.hard += 1
line 48:     elseif line =~# '^' . softtab
line 49:       let heuristics.soft += 1
line 50:     endif
line 51:     if line =~# '^  '
line 52:       let heuristics.spaces += 1
line 53:     endif
line 54:     let increment = prev_indent < 0 ? 0 : indent - prev_indent
line 55:     let prev_indent = indent
line 56:     let prev_line = line
line 57:     if increment > 1 && (increment < 4 || increment % 4 == 0)
line 58:       if has_key(heuristics.indents, increment)
line 59:         let heuristics.indents[increment] += 1
line 60:       else
line 61:         let heuristics.indents[increment] = 1
line 62:       endif
line 63:       let heuristics.checked += 1
line 64:     endif
line 65:     if heuristics.checked >= 32 && (heuristics.hard > 3 || heuristics.soft > 3) && get(heuristics.indents, increment) * 2 > heuristics.checked
line 66:       if heuristics.spaces
line 67:         break
line 68:       elseif !exists('no_space_indent')
line 69:         let no_space_indent = stridx("\n" . join(a:lines, "\n"), "\n  ") < 0
line 70:         if no_space_indent
line 71:           break
line 72:         endif
line 73:       endif
line 74:       break
line 75:     endif
line 76:   endfor
line 77: 
line 78:   let a:detected.heuristics[a:source] = heuristics
line 79: 
line 80:   let max_frequency = 0
line 81:   for [shiftwidth, frequency] in items(heuristics.indents)
line 82:     if frequency > max_frequency || frequency == max_frequency && +shiftwidth < get(options, 'shiftwidth')
line 83:       let options.shiftwidth = +shiftwidth
line 84:       let max_frequency = frequency
line 85:     endif
line 86:   endfor
line 87: 
line 88:   if heuristics.hard && !heuristics.spaces && !has_key(a:detected.options, 'tabstop')
line 90:     let options = {'expandtab': 0, 'shiftwidth': 0}
line 91:   elseif heuristics.hard > heuristics.soft
line 92:     let options.expandtab = 0
line 93:     let options.tabstop = tabstop
line 94:   else
line 95:     if heuristics.soft
line 96:       let options.expandtab = 1
line 97:     endif
line 98:     if heuristics.hard || has_key(a:detected.options, 'tabstop') || stridx(join(a:lines, "\n"), "\t") >= 0
line 100:       let options.tabstop = tabstop
line 101:     elseif !&g:shiftwidth && has_key(options, 'shiftwidth') && !has_key(a:detected.options, 'shiftwidth')
line 103:       let options.tabstop = options.shiftwidth
line 104:       let options.shiftwidth = 0
line 105:     endif
line 106:   endif
line 107: 
line 108:   call map(options, '[v:val, a:source]')
line 109:   call extend(a:detected.options, options, 'keep')
<SNR>65_Guess returning #0

continuing in <SNR>65_DetectHeuristics

line 23:   if s:Ready(detected)
calling <SNR>65_Ready({'root': '', 'options': {}, 'defaults'... 'editorconfig': {}, 'filetype': 'oil'})

line 1:   return has_key(a:detected.options, 'expandtab') && has_key(a:detected.options, 'shiftwidth')
<SNR>65_Ready returning #0

continuing in <SNR>65_DetectHeuristics

line 24:     return detected
line 25:   elseif get(options, 'shiftwidth', [4])[0] < 4 && stridx(join(lines, "\n"), "\t") == -1
line 26:     let options.expandtab = [1, detected.bufname]
line 27:     return detected
line 28:   endif
line 29:   let dir = len(detected.path) ? fnamemodify(detected.path, ':h') : ''
line 30:   let root = len(detected.root) ? fnamemodify(detected.root, ':h') : dir ==# s:Slash(expand('~')) ? dir : fnamemodify(dir, ':h')
calling <SNR>65_Slash('/Users/joe')

line 1:     return a:path
<SNR>65_Slash returning '/Users/joe'

continuing in <SNR>65_DetectHeuristics

line 31:   if detected.bufname =~# '^\a\a\+:' || root ==# '.' || !isdirectory(root)
line 32:     let dir = ''
line 33:   endif
line 34:   let c = get(b:, 'sleuth_neighbor_limit', get(g:, 'sleuth_neighbor_limit', 8))
line 35:   if c <= 0 || empty(dir)
line 36:     let detected.patterns = []
line 37:   elseif type(get(b:, 'sleuth_globs')) == type([])
line 38:     let detected.patterns = b:sleuth_globs
line 39:   elseif type(get(g:, 'sleuth_' . detected.filetype . '_globs')) == type([])
line 40:     let detected.patterns = get(g:, 'sleuth_' . detected.filetype . '_globs')
line 41:   else
line 42:     let detected.patterns = ['*' . matchstr(detected.bufname, '/\@<!\.[^][{}*?$~\`./]\+$')]
line 43:     if detected.patterns ==# ['*']
line 44:       let detected.patterns = [matchstr(detected.bufname, '/\zs[^][{}*?$~\`/]\+\ze/\=$')]
line 45:       let dir = fnamemodify(dir, ':h')
line 46:       if empty(detected.patterns[0])
line 47:         let detected.patterns = []
line 48:       endif
line 49:     endif
line 50:   endif
line 51:   while c > 0 && dir !~# '^$\|^//[^/]*$' && dir !=# fnamemodify(dir, ':h')
line 52:     for pattern in detected.patterns
line 53:       for neighbor in split(glob(dir.'/'.pattern), "\n")[0:7]
line 54:         if neighbor !=# detected.path && filereadable(neighbor)
line 55:           call s:Guess(neighbor, detected, readfile(neighbor, '', 256))
line 56:           let c -= 1
line 57:         endif
line 58:         if s:Ready(detected)
line 59:           return detected
line 60:         endif
line 61:         if c <= 0
line 62:           break
line 63:         endif
line 64:       endfor
line 65:       if c <= 0
line 66:         break
line 67:       endif
line 68:     endfor
line 69:     if len(dir) <= len(root)
line 70:       break
line 71:     endif
line 72:     let dir = fnamemodify(dir, ':h')
line 73:   endwhile
line 74:   if !has_key(options, 'shiftwidth')
line 75:     let detected.options = copy(detected.declared)
line 76:   endif
line 77:   return detected
<SNR>65_DetectHeuristics returning {'root': '', 'options': {}, 'defaults'... {}, 'filetype': 'oil', 'patterns': []}

continuing in <SNR>65_Init

line 28:   let cmd = s:Apply(detected, (a:do_filetype ? ['filetype'] : []) + (a:unsafe ? s:all_options : s:safe_options), a:silent)
calling <SNR>65_Apply({'root': '', 'options': {}, 'defaults'... {}, 'filetype': 'oil', 'patterns': []}, ['filetype', 'expandtab', 'shiftwidth'..., 'fileformat', 'fileencoding', 'bomb'], 1)

line 1:   let options = extend(copy(a:detected.defaults), a:detected.options)
line 2:   if get(a:detected.defaults, 'shiftwidth', [1])[0] == 0 && get(options, 'shiftwidth', [0])[0] != 0 && !has_key(a:detected.declared, 'tabstop')
line 3:     let options.tabstop = options.shiftwidth
line 4:     let options.shiftwidth = a:detected.defaults.shiftwidth
line 5:   endif
line 6:   if has_key(options, 'shiftwidth') && !has_key(options, 'expandtab')
line 7:     let options.expandtab = [stridx(join(getline(1, 256), "\n"), "\t") == -1, a:detected.bufname]
line 8:   endif
line 9:   if !exists('*shiftwidth') && !get(options, 'shiftwidth', [1])[0]
line 10:     let options.shiftwidth = [get(options, 'tabstop', [&tabstop])[0]] + options.shiftwidth[1:-1]
line 11:   endif
line 12:   let msg = ''
line 13:   let cmd = 'setlocal'
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 18:     endif
line 19:     let value = options[option]
line 20:     if has_key(s:booleans, option)
line 21:       let setting = (value[0] ? '' : 'no') . option
line 22:     else
line 23:       let setting = option . '=' . value[0]
line 24:     endif
line 25:     if getbufvar('', '&' . option) !=# value[0] || index(s:safe_options, option) >= 0
line 26:       let cmd .= ' ' . setting
line 27:     endif
line 28:     if !&verbose || a:silent
line 29:       if has_key(s:booleans, option)
line 30:         let msg .= ' ' . (value[0] ? '' : 'no') . get(s:short_options, option, option)
line 31:       else
line 32:         let msg .= ' ' . get(s:short_options, option, option) . '=' . value[0]
line 33:       endif
line 34:       continue
line 35:     endif
line 36:     if len(value) > 1
line 37:       if value[1] ==# a:detected.bufname
line 38:         let file = '%'
line 39:       else
line 40:         let file = value[1] =~# '/' ? fnamemodify(value[1], ':~:.') : value[1]
line 41:         if file !=# value[1] && file[0:0] !=# '~'
line 42:           let file = './' . file
line 43:         endif
line 44:       endif
line 45:       if len(value) > 2
line 46:         let file .= ' line ' . value[2]
line 47:       endif
line 48:       echo printf(':setlocal %-21s " from %s', setting, file)
line 49:     else
line 50:       echo ':setlocal ' . setting
line 51:     endif
line 52:   endfor
line 53:   if !&verbose && !empty(msg) && !a:silent
line 54:     echo ':setlocal' . msg
line 55:   endif
line 56:   if has_key(options, 'shiftwidth')
line 57:     let cmd .= ' softtabstop=' . (exists('*shiftwidth') ? -1 : options.shiftwidth[0])
line 58:   else
line 59:     call s:Warn(':Sleuth failed to detect indent settings', a:silent)
calling <SNR>65_Warn(':Sleuth failed to detect indent settings', 1)

line 1:   if !get(a:000, 0, 0)
line 2:     echohl WarningMsg
line 3:     echo a:msg
line 4:     echohl NONE
line 5:   endif
line 6:   return ''
<SNR>65_Warn returning ''

continuing in <SNR>65_Apply

line 60:   endif
line 61:   return cmd ==# 'setlocal' ? '' : cmd
<SNR>65_Apply returning ''

continuing in <SNR>65_Init

line 29:   let b:sleuth = detected
line 30:   if exists('s:polyglot') && !a:silent
line 31:     call s:Warn('Charlatan :Sleuth implementation in vim-polyglot has been found and disabled.')
line 32:     call s:Warn('To get rid of this message, uninstall vim-polyglot, or disable the')
line 33:     call s:Warn('corresponding feature in your vimrc:')
line 34:     call s:Warn('        let g:polyglot_disabled = ["autoindent"]')
line 35:   endif
line 36:   return cmd
<SNR>65_Init returning ''

continuing in <SNR>65_AutoInit

<SNR>65_AutoInit returning ''

continuing in BufReadPost Autocommands for "*"

Executing: 
Executing:  endif
Executing BufReadPost Autocommands for "*"
autocommand <Lua 511: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua:4>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 75: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:338>

Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 169: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at User Autocommands for "VeryLazy":0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at User Autocommands for "VeryLazy":0
continuing in User Autocommands for "VeryLazy"
line 0: sourcing "nvim_exec2() called at User Autocommands for "VeryLazy":0"
line 1: augroup END
finished sourcing nvim_exec2() called at User Autocommands for "VeryLazy":0
continuing in User Autocommands for "VeryLazy"
Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 79: ~/.config/nvim/lua/joe-p/plugins/snacks.lua:307>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 68: vim/_defaults.lua:0>

Executing: 
Executing TermResponse Autocommands for "*"
autocommand <Lua 558: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/termcap.lua:36>

Executing: 
calling vimade#DeferredTick(3)

line 1:   unlet g:vimade_deferred_timer
line 2:   call vimade#Tick(0)
calling vimade#Tick(0)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning ''

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning ''

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
calling vimade#UnhighlightAll()

line 1:   if winnr() == 0
line 2:     return
line 3:   endif
line 4:   call g:vimade_active_renderer.unhighlightAll()
calling vimade#Empty()

vimade#Empty returning #0

continuing in vimade#UnhighlightAll

vimade#UnhighlightAll returning #0

continuing in vimade#SetupRenderer

line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>92_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>92_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

continuing in vimade#DeferredTick

vimade#DeferredTick returning #0



--- Terminal info --- {{{
&term: xterm-256color
Description: xterm with 256 colors
Aliases: xterm-256color
Boolean capabilities:
  auto_left_margin          bw         = false
  auto_right_margin         am         = true
  no_esc_ctlc               xsb        = false
  ceol_standout_glitch      xhp        = false
  eat_newline_glitch        xenl       = true
  erase_overstrike          eo         = false
  generic_type              gn         = false
  hard_copy                 hc         = false
  has_meta_key              km         = true
  has_status_line           hs         = false
  insert_null_glitch        in         = false
  memory_above              da         = false
  memory_below              db         = false
  move_insert_mode          mir        = true
  move_standout_mode        msgr       = true
  over_strike               os         = false
  status_line_esc_ok        eslok      = false
  dest_tabs_magic_smso      xt         = false
  tilde_glitch              hz         = false
  transparent_underline     ul         = false
  xon_xoff                  xon        = false
  needs_xon_xoff            nxon       = false
  prtr_silent               mc5i       = true
  hard_cursor               chts       = false
  non_rev_rmcup             nrrmc      = false
  no_pad_char               npc        = true
  non_dest_scroll_region    ndscr      = false
  can_change                ccc        = true
  back_color_erase          bce        = true
  hue_lightness_saturation  hls        = false
  col_addr_glitch           xhpa       = false
  cr_cancels_micro_mode     crxm       = false
  has_print_wheel           daisy      = false
  row_addr_glitch           xvpa       = false
  semi_auto_right_margin    sam        = false
  cpi_changes_res           cpix       = false
  lpi_changes_res           lpix       = false
  backspaces_with_bs        OTbs       = true
  crt_no_scrolling          OTns       = false
  no_correctly_working_cr   OTnc       = false
  gnu_has_meta_key          OTMT       = false
  linefeed_is_newline       OTNL       = false
  has_hardware_tabs         OTpt       = false
  return_does_clr_eol       OTxr       = false
Numeric capabilities:
  columns                   cols       = 80
  init_tabs                 it         = 8
  lines                     lines      = 24
  lines_of_memory           lm         = -1
  magic_cookie_glitch       xmc        = -1
  padding_baud_rate         pb         = -1
  virtual_terminal          vt         = -1
  width_status_line         wsl        = -1
  num_labels                nlab       = -1
  label_height              lh         = -1
  label_width               lw         = -1
  max_attributes            ma         = -1
  maximum_windows           wnum       = -1
  max_colors                colors     = 256
  max_pairs                 pairs      = 65536
  no_color_video            ncv        = -1
  buffer_capacity           bufsz      = -1
  dot_vert_spacing          spinv      = -1
  dot_horz_spacing          spinh      = -1
  max_micro_address         maddr      = -1
  max_micro_jump            mjump      = -1
  micro_col_size            mcs        = -1
  micro_line_size           mls        = -1
  number_of_pins            npins      = -1
  output_res_char           orc        = -1
  output_res_line           orl        = -1
  output_res_horz_inch      orhi       = -1
  output_res_vert_inch      orvi       = -1
  print_rate                cps        = -1
  wide_char_size            widcs      = -1
  buttons                   btns       = -1
  bit_image_entwining       bitwin     = -1
  bit_image_type            bitype     = -1
  magic_cookie_glitch_ul    OTug       = -1
  carriage_return_delay     OTdC       = -1
  new_line_delay            OTdN       = -1
  backspace_delay           OTdB       = -1
  horizontal_tab_delay      OTdT       = -1
  number_of_function_keys   OTkn       = -1
String capabilities:
  back_tab                  cbt        = ^[[Z
  bell                      bel        = ^G
  carriage_return           cr         = ^M
  change_scroll_region      csr        = ^[[%i%p1%d;%p2%dr
  clear_all_tabs            tbc        = ^[[3g
  clear_screen              clear      = ^[[H^[[2J
  clr_eol                   el         = ^[[K
  clr_eos                   ed         = ^[[J
  column_address            hpa        = ^[[%i%p1%dG
  cursor_address            cup        = ^[[%i%p1%d;%p2%dH
  cursor_down               cud1       = ^@
  cursor_home               home       = ^[[H
  cursor_invisible          civis      = ^[[?25l
  cursor_left               cub1       = ^H
  cursor_normal             cnorm      = ^[[?25h
  cursor_right              cuf1       = ^[[C
  cursor_up                 cuu1       = ^[[A
  cursor_visible            cvvis      = ^[[?12;25h
  delete_character          dch1       = ^[[P
  delete_line               dl1        = ^[[M
  enter_alt_charset_mode    smacs      = ^[(0
  enter_blink_mode          blink      = ^[[5m
  enter_bold_mode           bold       = ^[[1m
  enter_ca_mode             smcup      = ^[[?1049h^[[22;0;0t
  enter_dim_mode            dim        = ^[[2m
  enter_insert_mode         smir       = ^[[4h
  enter_secure_mode         invis      = ^[[8m
  enter_reverse_mode        rev        = ^[[7m
  enter_standout_mode       smso       = ^[[7m
  enter_underline_mode      smul       = ^[[4m
  erase_chars               ech        = ^[[%p1%dX
  exit_alt_charset_mode     rmacs      = ^[(B
  exit_attribute_mode       sgr0       = ^[(B^[[m
  exit_ca_mode              rmcup      = ^[[?1049l^[[23;0;0t
  exit_insert_mode          rmir       = ^[[4l
  exit_standout_mode        rmso       = ^[[27m
  exit_underline_mode       rmul       = ^[[24m
  flash_screen              flash      = ^[[?5h$<100/>^[[?5l
  from_status_line          fsl        = ^G
  init_2string              is2        = ^[[!p^[[?3;4l^[[4l^[>
  insert_line               il1        = ^[[L
  key_backspace             kbs        = ^H
  key_dc                    kdch1      = ^[[3~
  key_down                  kcud1      = ^[OB
  key_f1                    kf1        = ^[OP
  key_f10                   kf10       = ^[[21~
  key_f2                    kf2        = ^[OQ
  key_f3                    kf3        = ^[OR
  key_f4                    kf4        = ^[OS
  key_f5                    kf5        = ^[[15~
  key_f6                    kf6        = ^[[17~
  key_f7                    kf7        = ^[[18~
  key_f8                    kf8        = ^[[19~
  key_f9                    kf9        = ^[[20~
  key_home                  khome      = ^[OH
  key_ic                    kich1      = ^[[2~
  key_left                  kcub1      = ^[OD
  key_npage                 knp        = ^[[6~
  key_ppage                 kpp        = ^[[5~
  key_right                 kcuf1      = ^[OC
  key_sf                    kind       = ^[[1;2B
  key_sr                    kri        = ^[[1;2A
  key_up                    kcuu1      = ^[OA
  keypad_local              rmkx       = ^[[?1l^[>
  keypad_xmit               smkx       = ^[[?1h^[=
  meta_off                  rmm        = ^[[?1034l
  meta_on                   smm        = ^[[?1034h
  newline                   nel        = ^[E
  parm_dch                  dch        = ^[[%p1%dP
  parm_delete_line          dl         = ^[[%p1%dM
  parm_down_cursor          cud        = ^[[%p1%dB
  parm_ich                  ich        = ^[[%p1%d@
  parm_index                indn       = ^[[%p1%dS
  parm_insert_line          il         = ^[[%p1%dL
  parm_left_cursor          cub        = ^[[%p1%dD
  parm_right_cursor         cuf        = ^[[%p1%dC
  parm_rindex               rin        = ^[[%p1%dT
  parm_up_cursor            cuu        = ^[[%p1%dA
  print_screen              mc0        = ^[[i
  prtr_off                  mc4        = ^[[4i
  prtr_on                   mc5        = ^[[5i
  repeat_char               rep        = %p1%c^[[%p2%{1}%-%db
  reset_1string             rs1        = ^[c^[]104^G
  reset_2string             rs2        = ^[[!p^[[?3;4l^[[4l^[>
  restore_cursor            rc         = ^[8
  row_address               vpa        = ^[[%i%p1%dd
  save_cursor               sc         = ^[7
  scroll_forward            ind        = ^@
  scroll_reverse            ri         = ^[M
  set_attributes            sgr        = %?%p9%t^[(0%e^[(B%;^[[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m
  set_tab                   hts        = ^[H
  tab                       ht         = 	
  to_status_line            tsl        = ^[]0;
  key_a1                    ka1        = ^[Ow
  key_a3                    ka3        = ^[Oy
  key_b2                    kb2        = ^[Ou
  key_c1                    kc1        = ^[Oq
  key_c3                    kc3        = ^[Os
  acs_chars                 acsc       = ``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~
  key_btab                  kcbt       = ^[[Z
  enter_am_mode             smam       = ^[[?7h
  exit_am_mode              rmam       = ^[[?7l
  key_beg                   kbeg       = ^[OE
  key_end                   kend       = ^[OF
  key_enter                 kent       = ^[OM
  key_sdc                   kDC        = ^[[3;2~
  key_send                  kEND       = ^[[1;2F
  key_shome                 kHOM       = ^[[1;2H
  key_sic                   kIC        = ^[[2;2~
  key_sleft                 kLFT       = ^[[1;2D
  key_snext                 kNXT       = ^[[6;2~
  key_sprevious             kPRV       = ^[[5;2~
  key_sright                kRIT       = ^[[1;2C
  key_f11                   kf11       = ^[[23~
  key_f12                   kf12       = ^[[24~
  key_f13                   kf13       = ^[[1;2P
  key_f14                   kf14       = ^[[1;2Q
  key_f15                   kf15       = ^[[1;2R
  key_f16                   kf16       = ^[[1;2S
  key_f17                   kf17       = ^[[15;2~
  key_f18                   kf18       = ^[[17;2~
  key_f19                   kf19       = ^[[18;2~
  key_f20                   kf20       = ^[[19;2~
  key_f21                   kf21       = ^[[20;2~
  key_f22                   kf22       = ^[[21;2~
  key_f23                   kf23       = ^[[23;2~
  key_f24                   kf24       = ^[[24;2~
  key_f25                   kf25       = ^[[1;5P
  key_f26                   kf26       = ^[[1;5Q
  key_f27                   kf27       = ^[[1;5R
  key_f28                   kf28       = ^[[1;5S
  key_f29                   kf29       = ^[[15;5~
  key_f30                   kf30       = ^[[17;5~
  key_f31                   kf31       = ^[[18;5~
  key_f32                   kf32       = ^[[19;5~
  key_f33                   kf33       = ^[[20;5~
  key_f34                   kf34       = ^[[21;5~
  key_f35                   kf35       = ^[[23;5~
  key_f36                   kf36       = ^[[24;5~
  key_f37                   kf37       = ^[[1;6P
  key_f38                   kf38       = ^[[1;6Q
  key_f39                   kf39       = ^[[1;6R
  key_f40                   kf40       = ^[[1;6S
  key_f41                   kf41       = ^[[15;6~
  key_f42                   kf42       = ^[[17;6~
  key_f43                   kf43       = ^[[18;6~
  key_f44                   kf44       = ^[[19;6~
  key_f45                   kf45       = ^[[20;6~
  key_f46                   kf46       = ^[[21;6~
  key_f47                   kf47       = ^[[23;6~
  key_f48                   kf48       = ^[[24;6~
  key_f49                   kf49       = ^[[1;3P
  key_f50                   kf50       = ^[[1;3Q
  key_f51                   kf51       = ^[[1;3R
  key_f52                   kf52       = ^[[1;3S
  key_f53                   kf53       = ^[[15;3~
  key_f54                   kf54       = ^[[17;3~
  key_f55                   kf55       = ^[[18;3~
  key_f56                   kf56       = ^[[19;3~
  key_f57                   kf57       = ^[[20;3~
  key_f58                   kf58       = ^[[21;3~
  key_f59                   kf59       = ^[[23;3~
  key_f60                   kf60       = ^[[24;3~
  key_f61                   kf61       = ^[[1;4P
  key_f62                   kf62       = ^[[1;4Q
  key_f63                   kf63       = ^[[1;4R
  clr_bol                   el1        = ^[[1K
  clear_margins             mgc        = ^[[?69l
  user6                     u6         = ^[[%i%d;%dR
  user7                     u7         = ^[[6n
  user8                     u8         = ^[[?%[;0123456789]c
  user9                     u9         = ^[[c
  orig_pair                 op         = ^[[39;49m
  orig_colors               oc         = ^[]104^G
  initialize_color          initc      = ^[]4;%p1%d;rgb:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X^[\
  enter_italics_mode        sitm       = ^[[3m
  exit_italics_mode         ritm       = ^[[23m
  key_mouse                 kmous      = ^[[<
  set_a_foreground          setaf      = ^[[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m
  set_a_background          setab      = ^[[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m
  set_tb_margin             smgtb      = ^[[%i%p1%d;%p2%dr
  memory_lock               meml       = ^[l
  memory_unlock             memu       = ^[m
Extended boolean capabilities:
  AX                        = true
  XF                        = true
  XT                        = true
Extended string capabilities:
  BD                        = ^[[?2004l
  BE                        = ^[[?2004h
  Cr                        = ^[]112^G
  Cs                        = ^[]12;%p1%s^G
  E3                        = ^[[3J
  Ms                        = ^[]52;%p1%s;%p2%s^G
  PE                        = ^[[201~
  PS                        = ^[[200~
  RV                        = ^[[>c
  Se                        = ^[[2 q
  Ss                        = ^[[%p1%d q
  XM                        = ^[[?1006;1000%?%p1%{1}%=%th%el%;
  XR                        = ^[[>0q
  fd                        = ^[[?1004l
  fe                        = ^[[?1004h
  kDC3                      = ^[[3;3~
  kDC4                      = ^[[3;4~
  kDC5                      = ^[[3;5~
  kDC6                      = ^[[3;6~
  kDC7                      = ^[[3;7~
  kDN                       = ^[[1;2B
  kDN3                      = ^[[1;3B
  kDN4                      = ^[[1;4B
  kDN5                      = ^[[1;5B
  kDN6                      = ^[[1;6B
  kDN7                      = ^[[1;7B
  kEND3                     = ^[[1;3F
  kEND4                     = ^[[1;4F
  kEND5                     = ^[[1;5F
  kEND6                     = ^[[1;6F
  kEND7                     = ^[[1;7F
  kHOM3                     = ^[[1;3H
  kHOM4                     = ^[[1;4H
  kHOM5                     = ^[[1;5H
  kHOM6                     = ^[[1;6H
  kHOM7                     = ^[[1;7H
  kIC3                      = ^[[2;3~
  kIC4                      = ^[[2;4~
  kIC5                      = ^[[2;5~
  kIC6                      = ^[[2;6~
  kIC7                      = ^[[2;7~
  kLFT3                     = ^[[1;3D
  kLFT4                     = ^[[1;4D
  kLFT5                     = ^[[1;5D
  kLFT6                     = ^[[1;6D
  kLFT7                     = ^[[1;7D
  kNXT3                     = ^[[6;3~
  kNXT4                     = ^[[6;4~
  kNXT5                     = ^[[6;5~
  kNXT6                     = ^[[6;6~
  kNXT7                     = ^[[6;7~
  kPRV3                     = ^[[5;3~
  kPRV4                     = ^[[5;4~
  kPRV5                     = ^[[5;5~
  kPRV6                     = ^[[5;6~
  kPRV7                     = ^[[5;7~
  kRIT3                     = ^[[1;3C
  kRIT4                     = ^[[1;4C
  kRIT5                     = ^[[1;5C
  kRIT6                     = ^[[1;6C
  kRIT7                     = ^[[1;7C
  kUP                       = ^[[1;2A
  kUP3                      = ^[[1;3A
  kUP4                      = ^[[1;4A
  kUP5                      = ^[[1;5A
  kUP6                      = ^[[1;6A
  kUP7                      = ^[[1;7A
  ka2                       = ^[Ox
  kb1                       = ^[Ot
  kb3                       = ^[Ov
  kc2                       = ^[Or
  kp5                       = ^[OE
  kpADD                     = ^[Ok
  kpCMA                     = ^[Ol
  kpDIV                     = ^[Oo
  kpDOT                     = ^[On
  kpMUL                     = ^[Oj
  kpSUB                     = ^[Om
  kpZRO                     = ^[Op
  kxIN                      = ^[[I
  kxOUT                     = ^[[O
  rmxx                      = ^[[29m
  rv                        = ^[\[41;[1-6][0-9][0-9];0c
  smxx                      = ^[[9m
  xm                        = ^[[<%i%p3%d;%p1%d;%p2%d;%?%p4%tM%em%;
  xr                        = ^[P>\|XTerm\([1-9][0-9]+\)^[\\
  ext.resize_screen         = ^[[8;%p1%d;%p2%dt
  ext.reset_scroll_region   = ^[[r
  ext.enter_altfont_mode    = ^[[11m
  setrgbf                   = ^[[38;2;%p1%d;%p2%d;%p3%dm
  setrgbb                   = ^[[48;2;%p1%d;%p2%d;%p3%dm
  ext.save_title            = ^[[22;0t
  ext.restore_title         = ^[[23;0t
  ext.set_title             = ^[]0;%p2%s^G
  ext.enable_lr_margin      = ^[[?69h
  ext.disable_lr_margin     = ^[[?69l
  ext.enable_bpaste         = ^[[?2004h
  ext.disable_bpaste        = ^[[?2004l
  ext.enable_focus          = ^[[?1004h
  ext.disable_focus         = ^[[?1004l
  ext.enable_mouse          = ^[[?1002h^[[?1006h
  ext.disable_mouse         = ^[[?1002l^[[?1006l
  ext.enable_mouse_move     = ^[[?1003h
  ext.disable_mouse_move    = ^[[?1003l
  ext.set_underline_style   = ^[[4:%p1%dm
  ext.set_underline_color   = ^[[58:2::%p1%d:%p2%d:%p3%dm
  Sync                      = ^[[?2026%?%p1%{1}%-%tl%eh%;
}}}

sourcing "nvim_exec2()"
line 1: hi def TodoBgTEST guibg=#f0c6c6 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgTEST guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignTEST guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgTODO guibg=#91d7e3 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgTODO guibg=NONE guifg=#91d7e3 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignTODO guibg=NONE guifg=#91d7e3 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgWARN guibg=#eed49f guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgWARN guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignWARN guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgHACK guibg=#eed49f guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgHACK guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignHACK guibg=NONE guifg=#eed49f gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgPERF guibg=#f0c6c6 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgPERF guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignPERF guibg=NONE guifg=#f0c6c6 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgNOTE guibg=#8bd5ca guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgNOTE guibg=NONE guifg=#8bd5ca gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignNOTE guibg=NONE guifg=#8bd5ca gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoBgFIX guibg=#ed8796 guifg=#24273a gui=BOLD
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoFgFIX guibg=NONE guifg=#ed8796 gui=NONE
finished sourcing nvim_exec2()
sourcing "nvim_exec2()"
line 1: hi def TodoSignFIX guibg=NONE guifg=#ed8796 gui=NONE
finished sourcing nvim_exec2()
Executing BufNew Autocommands for "*"
autocommand <Lua 573: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:135>

Executing: 
Executing BufFilePre Autocommands for "*"
autocommand <Lua 403: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns.lua:158>

Executing: 
Executing BufFilePost Autocommands for "*"
autocommand <Lua 399: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns.lua:143>

Executing: 
Executing BufFilePost Autocommands for "*"
autocommand if (@% !~# '^!' || exists('b:sleuth')) && get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif

Executing: if (@% !~# '^!' || exists('b:sleuth')) && get(g:, 'sleuth_automatic', 1) | exe s:AutoInit() | endif
Executing:  exe s:AutoInit() | endif
calling <SNR>65_AutoInit()

line 1:   return s:Init(1, 1, 1, 1)
calling <SNR>65_Init(1, 1, 1, 1)

line 1:   if !a:redetect && exists('b:sleuth.defaults')
line 2:     let detected = b:sleuth
line 3:   endif
line 4:   unlet! b:sleuth
line 5:   if &l:buftype !~# '^\%(nowrite\|nofile\|acwrite\)\=$'
line 6:     return s:Warn(':Sleuth disabled for buftype=' . &l:buftype, a:silent)
line 7:   endif
line 8:   if &l:filetype ==# 'netrw'
line 9:     return s:Warn(':Sleuth disabled for filetype=' . &l:filetype, a:silent)
line 10:   endif
line 11:   if &l:binary
line 12:     return s:Warn(':Sleuth disabled for binary files', a:silent)
line 13:   endif
line 14:   if !exists('detected')
line 15:     let detected = s:DetectDeclared()
calling <SNR>65_DetectDeclared()

line 1:   let detected = {'bufname': s:Slash(@%), 'declared': {}}
calling <SNR>65_Slash('miniicons://3/filetype-match-scratch')

line 1:     return a:path
<SNR>65_Slash returning 'miniicons://3/filetype-match-scratch'

continuing in <SNR>65_DetectDeclared

line 2:   let absolute_or_empty = detected.bufname =~# '^$\|^\a\+:\|^/'
line 3:   if &l:buftype =~# '^\%(nowrite\)\=$' && !absolute_or_empty
line 4:     let detected.bufname = substitute(s:Slash(getcwd()), '/\=$', '/', '') . detected.bufname
line 5:     let absolute_or_empty = 1
line 6:   endif
line 7:   let detected.path = absolute_or_empty ? detected.bufname : ''
line 8:   let pre = substitute(matchstr(detected.path, '^\a\a\+\ze:'), '^\a', '\u&', 'g')
line 9:   if len(pre) && exists('*' . pre . 'Real')
line 10:     let detected.path = s:Slash(call(pre . 'Real', [detected.path]))
line 11:   endif
line 12: 
line 13:   try
line 14:     if len(detected.path) && exists('*ExcludeBufferFromDiscovery') && !empty(ExcludeBufferFromDiscovery(detected.path, 'sleuth'))
line 15:       let detected.path = ''
line 16:     endif
line 17:   catch
line 18:   endtry
line 19:   let [detected.editorconfig, detected.root] = s:DetectEditorConfig(detected.path)
calling <SNR>65_DetectEditorConfig('miniicons://3/filetype-match-scratch')

line 1:   if empty(a:absolute_path)
line 2:     return [{}, '']
line 3:   endif
line 4:   let root = ''
line 5:   let tail = a:0 ? a:1 : '.editorconfig'
line 6:   let dir = fnamemodify(a:absolute_path, ':h')
line 7:   let previous_dir = ''
line 8:   let sections = []
line 9:   let overrides = get(g:, 'sleuth_editorconfig_overrides', {})
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 10:   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
line 11:     let head = substitute(dir, '/\=$', '/', '')
line 12:     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
line 13:     if read_from is# ''
line 14:       break
line 15:     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
line 16:       let read_from = simplify(head . read_from)
line 17:     endif
line 18:     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
line 19:     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
line 20:     if ftime != cachetime
line 21:       let econfig = s:ReadEditorConfig(read_from)
line 22:       let s:editorconfig_cache[read_from] = [ftime] + econfig
line 23:       lockvar! s:editorconfig_cache[read_from]
line 24:       unlockvar s:editorconfig_cache[read_from]
line 25:     endif
line 26:     call extend(sections, econfig[1], 'keep')
line 27:     if get(econfig[0], 'root', [''])[0] ==? 'true'
line 28:       let root = head
line 29:       break
line 30:     endif
line 31:     let previous_dir = dir
line 32:     let dir = fnamemodify(dir, ':h')
line 33:   endwhile
line 34: 
line 35:   let config = {}
line 36:   for [pattern, pairs] in sections
line 37:     if a:absolute_path =~# pattern
line 38:       call extend(config, pairs)
line 39:     endif
line 40:   endfor
line 41: 
line 42:   return [config, root]
<SNR>65_DetectEditorConfig returning [{}, '']

continuing in <SNR>65_DetectDeclared

line 20:   call extend(detected.declared, s:EditorConfigToOptions(detected.editorconfig))
calling <SNR>65_EditorConfigToOptions({})

line 1:   let options = {}
line 2:   let pairs = map(copy(a:pairs), 'v:val[0]')
line 3:   let sources = map(copy(a:pairs), 'v:val[1:-1]')
line 4:   call filter(pairs, 'v:val !=? "unset"')
line 5: 
line 6:   if get(pairs, 'indent_style', '') ==? 'tab'
line 7:     let options.expandtab = [0] + sources.indent_style
line 8:   elseif get(pairs, 'indent_style', '') ==? 'space'
line 9:     let options.expandtab = [1] + sources.indent_style
line 10:   endif
line 11: 
line 12:   if get(pairs, 'indent_size', '') =~? '^[1-9]\d*$\|^tab$'
line 13:     let options.shiftwidth = [str2nr(pairs.indent_size)] + sources.indent_size
line 14:     if &g:shiftwidth == 0 && !has_key(pairs, 'tab_width') && pairs.indent_size !=? 'tab'
line 15:       let options.tabstop = options.shiftwidth
line 16:       let options.shiftwidth = [0] + sources.indent_size
line 17:     endif
line 18:   endif
line 19: 
line 20:   if get(pairs, 'tab_width', '') =~? '^[1-9]\d*$'
line 21:     let options.tabstop = [str2nr(pairs.tab_width)] + sources.tab_width
line 22:     if !has_key(pairs, 'indent_size') && get(pairs, 'indent_style', '') ==? 'tab'
line 23:       let options.shiftwidth = [0] + options.tabstop[1:-1]
line 24:     endif
line 25:   endif
line 26: 
line 27:   if get(pairs, 'max_line_length', '') =~? '^[1-9]\d*$\|^off$'
line 28:     let options.textwidth = [str2nr(pairs.max_line_length)] + sources.max_line_length
line 29:   endif
line 30: 
line 31:   if get(pairs, 'insert_final_newline', '') =~? '^true$\|^false$'
line 32:     let options.endofline = [pairs.insert_final_newline ==? 'true'] + sources.insert_final_newline
line 33:     let options.fixendofline = copy(options.endofline)
line 34:   endif
line 35: 
line 36:   let eol = tolower(get(pairs, 'end_of_line', ''))
line 37:   if has_key(s:editorconfig_fileformat, eol)
line 38:     let options.fileformat = [s:editorconfig_fileformat[eol]] + sources.end_of_line
line 39:   endif
line 40: 
line 41:   let charset = tolower(get(pairs, 'charset', ''))
line 42:   if has_key(s:editorconfig_bomb, charset)
line 43:     let options.bomb = [s:editorconfig_bomb[charset]] + sources.charset
line 44:     let options.fileencoding = [substitute(charset, '\C-bom$', '', '')] + sources.charset
line 45:   endif
line 46: 
line 47:   let filetype = tolower(get(pairs, 'vim_filetype', 'unset'))
line 48:   if filetype !=# 'unset' && filetype =~# '^[.a-z0-9_-]*$'
line 49:     let options.filetype = [substitute(filetype, '^\.\+\|\.\+$', '', 'g')] + sources.vim_filetype
line 50:   endif
line 51: 
line 52:   return options
<SNR>65_EditorConfigToOptions returning {}

continuing in <SNR>65_DetectDeclared

line 21:   call extend(detected.declared, s:ModelineOptions())
calling <SNR>65_ModelineOptions()

line 1:   let options = {}
line 2:   if !&l:modeline && (&g:modeline || s:Capture('setlocal') =~# '\\\@<![[:space:]]nomodeline\>' && s:Capture('verbose setglobal modeline?') !=# s:Capture('verbose setlocal modeline?'))
line 4:     return options
<SNR>65_ModelineOptions returning {}

continuing in <SNR>65_DetectDeclared

line 22:   return detected
<SNR>65_DetectDeclared returning {'root': '', 'path': 'miniicons://3/fi...h', 'declared': {}, 'editorconfig': {}}

continuing in <SNR>65_Init

line 16:   endif
line 17:   let setfiletype = ''
line 18:   if a:do_filetype && has_key(detected.declared, 'filetype')
line 19:     let filetype = detected.declared.filetype[0]
line 20:     if filetype !=# &l:filetype || empty(filetype)
line 21:       let setfiletype = 'setlocal filetype=' . filetype
line 22:     else
line 23:       let setfiletype = 'setfiletype ' . filetype
line 24:     endif
line 25:   endif
line 26:   exe setfiletype
line 26: 
line 27:   call s:DetectHeuristics(detected)
calling <SNR>65_DetectHeuristics({'root': '', 'path': 'miniicons://3/fi...h', 'declared': {}, 'editorconfig': {}})

line 1:   let detected = a:into
line 2:   let filetype = split(&l:filetype, '\.', 1)[0]
line 3:   if get(detected, 'filetype', '*') ==# filetype
line 4:     return detected
line 5:   endif
line 6:   let detected.filetype = filetype
line 7:   let options = copy(detected.declared)
line 8:   let detected.options = options
line 9:   let detected.heuristics = {}
line 10:   if has_key(detected, 'patterns')
line 11:     call remove(detected, 'patterns')
line 12:   endif
line 13:   let detected.defaults = s:UserOptions(filetype, 'defaults')
calling <SNR>65_UserOptions('', 'defaults')

line 1:   if exists('b:sleuth_' . a:name)
line 2:     let source = 'b:sleuth_' . a:name
line 3:   elseif exists('g:sleuth_' . a:ft . '_' . a:name)
line 4:     let source = 'g:sleuth_' . a:ft . '_' . a:name
line 5:   endif
line 6:   if !exists('l:source') || type(eval(source)) == type(function('tr'))
line 7:     return {}
<SNR>65_UserOptions returning {}

continuing in <SNR>65_DetectHeuristics

line 14:   if empty(filetype) || !get(b:, 'sleuth_automatic', 1) || empty(get(b:, 'sleuth_heuristics', get(g:, 'sleuth_' . filetype . '_heuristics', get(g:, 'sleuth_heuristics', 1))))
line 15:     return detected
<SNR>65_DetectHeuristics returning {'root': '', 'options': {}, 'defaults'...{}, 'editorconfig': {}, 'filetype': ''}

continuing in <SNR>65_Init

line 28:   let cmd = s:Apply(detected, (a:do_filetype ? ['filetype'] : []) + (a:unsafe ? s:all_options : s:safe_options), a:silent)
calling <SNR>65_Apply({'root': '', 'options': {}, 'defaults'...{}, 'editorconfig': {}, 'filetype': ''}, ['filetype', 'expandtab', 'shiftwidth'..., 'fileformat', 'fileencoding', 'bomb'], 1)

line 1:   let options = extend(copy(a:detected.defaults), a:detected.options)
line 2:   if get(a:detected.defaults, 'shiftwidth', [1])[0] == 0 && get(options, 'shiftwidth', [0])[0] != 0 && !has_key(a:detected.declared, 'tabstop')
line 3:     let options.tabstop = options.shiftwidth
line 4:     let options.shiftwidth = a:detected.defaults.shiftwidth
line 5:   endif
line 6:   if has_key(options, 'shiftwidth') && !has_key(options, 'expandtab')
line 7:     let options.expandtab = [stridx(join(getline(1, 256), "\n"), "\t") == -1, a:detected.bufname]
line 8:   endif
line 9:   if !exists('*shiftwidth') && !get(options, 'shiftwidth', [1])[0]
line 10:     let options.shiftwidth = [get(options, 'tabstop', [&tabstop])[0]] + options.shiftwidth[1:-1]
line 11:   endif
line 12:   let msg = ''
line 13:   let cmd = 'setlocal'
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 14:   for option in a:permitted_options
line 15:     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
line 17:       continue
line 18:     endif
line 19:     let value = options[option]
line 20:     if has_key(s:booleans, option)
line 21:       let setting = (value[0] ? '' : 'no') . option
line 22:     else
line 23:       let setting = option . '=' . value[0]
line 24:     endif
line 25:     if getbufvar('', '&' . option) !=# value[0] || index(s:safe_options, option) >= 0
line 26:       let cmd .= ' ' . setting
line 27:     endif
line 28:     if !&verbose || a:silent
line 29:       if has_key(s:booleans, option)
line 30:         let msg .= ' ' . (value[0] ? '' : 'no') . get(s:short_options, option, option)
line 31:       else
line 32:         let msg .= ' ' . get(s:short_options, option, option) . '=' . value[0]
line 33:       endif
line 34:       continue
line 35:     endif
line 36:     if len(value) > 1
line 37:       if value[1] ==# a:detected.bufname
line 38:         let file = '%'
line 39:       else
line 40:         let file = value[1] =~# '/' ? fnamemodify(value[1], ':~:.') : value[1]
line 41:         if file !=# value[1] && file[0:0] !=# '~'
line 42:           let file = './' . file
line 43:         endif
line 44:       endif
line 45:       if len(value) > 2
line 46:         let file .= ' line ' . value[2]
line 47:       endif
line 48:       echo printf(':setlocal %-21s " from %s', setting, file)
line 49:     else
line 50:       echo ':setlocal ' . setting
line 51:     endif
line 52:   endfor
line 53:   if !&verbose && !empty(msg) && !a:silent
line 54:     echo ':setlocal' . msg
line 55:   endif
line 56:   if has_key(options, 'shiftwidth')
line 57:     let cmd .= ' softtabstop=' . (exists('*shiftwidth') ? -1 : options.shiftwidth[0])
line 58:   else
line 59:     call s:Warn(':Sleuth failed to detect indent settings', a:silent)
calling <SNR>65_Warn(':Sleuth failed to detect indent settings', 1)

line 1:   if !get(a:000, 0, 0)
line 2:     echohl WarningMsg
line 3:     echo a:msg
line 4:     echohl NONE
line 5:   endif
line 6:   return ''
<SNR>65_Warn returning ''

continuing in <SNR>65_Apply

line 60:   endif
line 61:   return cmd ==# 'setlocal' ? '' : cmd
<SNR>65_Apply returning ''

continuing in <SNR>65_Init

line 29:   let b:sleuth = detected
line 30:   if exists('s:polyglot') && !a:silent
line 31:     call s:Warn('Charlatan :Sleuth implementation in vim-polyglot has been found and disabled.')
line 32:     call s:Warn('To get rid of this message, uninstall vim-polyglot, or disable the')
line 33:     call s:Warn('corresponding feature in your vimrc:')
line 34:     call s:Warn('        let g:polyglot_disabled = ["autoindent"]')
line 35:   endif
line 36:   return cmd
<SNR>65_Init returning ''

continuing in <SNR>65_AutoInit

<SNR>65_AutoInit returning ''

continuing in BufFilePost Autocommands for "*"

Executing: 
Executing:  endif
Executing BufFilePost Autocommands for "*"
autocommand <Lua 512: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/plugin/editorconfig.lua:4>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 288: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 312: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:on_move()

Executing: call s:on_move()
calling <SNR>51_on_move()

line 1:     let s:t_last_move = reltime()
line 2: 
line 3:     call llama#fim_cancel()
calling llama#fim_cancel()

line 1:     let s:hint_shown = v:false
line 2: 
line 3:     " clear the virtual text
line 4:     let l:bufnr = bufnr('%')
line 5: 
line 6:     if s:ghost_text_nvim
line 7:         let l:id_vt_fim = nvim_create_namespace('vt_fim')
line 8:         call nvim_buf_clear_namespace(l:bufnr, l:id_vt_fim,  0, -1)
line 9:     elseif s:ghost_text_vim
line 10:         call prop_remove({'type': s:hlgroup_hint, 'all': v:true})
line 11:         call prop_remove({'type': s:hlgroup_info, 'all': v:true})
line 12:     endif
line 13: 
line 14:     " remove the mappings
line 15:     silent! iunmap <buffer> <Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   15:
E31: No such mapping
line 16:     silent! iunmap <buffer> <S-Tab>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   16:
E31: No such mapping
line 17:     silent! iunmap <buffer> <Esc>
Error detected while processing CursorMoved Autocommands for "*"..function <SNR>51_on_move[3]..llama#fim_cancel:
line   17:
E31: No such mapping
llama#fim_cancel returning #0

continuing in <SNR>51_on_move

<SNR>51_on_move returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 519: ~/.config/nvim/lua/joe-p/diagnostic.lua:99>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 554: vim/_editor.lua:0>

Executing: 
Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 392: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/view.lua:420>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 440: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:672>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 368: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/current_line_blame.lua:243>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 609: ~/.local/share/nvim/lazy/flash.nvim/lua/flash/plugins/char.lua:142>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand <Lua 621: ~/.local/share/nvim/lazy/blink.cmp/lua/blink/cmp/lib/buffer_events.lua:60>

Executing: 
Executing TextChanged Autocommands for "*"
autocommand <Lua 313: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:375>

Executing: 
Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>71_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>71_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>71_Remove_Matches returning #0

continuing in <SNR>71_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>71_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"

Executing TextChanged Autocommands for "*"
autocommand <Lua 552: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scroll.lua:152>

Executing: 
calling <lambda>2(2)

calling <SNR>51_pick_chunk(['/004 󱧺  bin/', '/008 󰉋  lua/', '/014... '/001 󰌠  build.py', '/012 󰈔  out.log'], v:true, v:true)

line 1:     " do not pick chunks from buffers with pending changes or buffers that are not files
line 2:     if a:no_mod && (getbufvar(bufnr('%'), '&modified') || !buflisted(bufnr('%')) || !filereadable(expand('%')))
line 3:         return
<SNR>51_pick_chunk returning #0

continuing in <lambda>2

<lambda>2 returning #0

calling <lambda>1(1)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in <lambda>1

<lambda>1 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>92_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>92_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

calling <lambda>3(5)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in <lambda>3

<lambda>3 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>92_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>92_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

calling <lambda>4(6)

calling <SNR>51_ring_update()

line 1:     call timer_start(g:llama_config.ring_update_ms, {-> s:ring_update()})
line 2: 
line 3:     " update only if in normal mode or if the cursor hasn't moved for a while
line 4:     if mode() !=# 'n' && reltimefloat(reltime(s:t_last_move)) < 3.0
line 5:         return
line 6:     endif
line 7: 
line 8:     if len(s:ring_queued) == 0
line 9:         return
<SNR>51_ring_update returning #0

continuing in <lambda>4

<lambda>4 returning #0

calling vimade#Tick(4)

line 1:   try
line 2:     call vimade#CheckWindows()
calling vimade#CheckWindows()

line 1:   call vimade#UpdateState()
calling vimade#UpdateState()

line 1:   if !exists('g:vimade')
line 2:     let g:vimade = {}
line 3:   endif
line 4:   if !has_key(g:vimade, '$extended')
line 5:     call vimade#ExtendState()
line 6:   endif
line 7:   let normalid = vimade#GetMaybeFromOverlay('normalid')
calling vimade#GetMaybeFromOverlay('normalid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #77

continuing in vimade#UpdateState

line 8:   if normalid == "" || normalid == 0 || normalid == v:null
line 9:     let g:vimade.normalid = hlID('Normal')
line 10:   endif
line 11:   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
calling vimade#GetMaybeFromOverlay('normalncid')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #58

continuing in vimade#UpdateState

line 12:   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
line 13:     let g:vimade.normalncid = hlID('NormalNC')
line 14:   endif
line 15:   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
calling vimade#GetMaybeFromOverlay('usecursorhold')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #0

continuing in vimade#UpdateState

line 16:   if usecursorhold != g:vimade_last.usecursorhold
line 17:     let g:vimade_last.usecursorhold = usecursorhold
line 18:     if usecursorhold
line 19:       call vimade#StopTimer()
line 20:     else
line 21:       call vimade#StartTimer()
line 22:     endif
line 23:     call vimade#UpdateEvents()
line 24:   endif
line 25:   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
calling vimade#GetMaybeFromOverlay('checkinterval')

line 1:   if exists('g:vimade_overlay.' .. a:field)
line 2:     return get(g:vimade_overlay, a:field)
line 3:   else
line 4:     return get(g:vimade, a:field)
vimade#GetMaybeFromOverlay returning #1000

continuing in vimade#UpdateState

line 26:   if checkinterval != g:vimade_last.checkinterval
line 27:     let g:vimade_last.checkinterval = checkinterval
line 28:     call vimade#StopTimer()
line 29:     call vimade#StartTimer()
line 30:   endif
line 31:   let g:vimade.__background = &background
line 32:   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
line 33:   let g:vimade.__termguicolors = &termguicolors
line 34:   call vimade#SetupRenderer()
calling vimade#SetupRenderer()

line 1:   let l:next_renderer = g:vimade_active_renderer.name
line 2:   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
line 3:     let l:next_renderer = 'lua'
line 4:   else
line 5:     if g:vimade_python_setup == 0
line 6:       call vimade#SetupPython()
line 7:     endif
line 8:     if g:vimade.renderer == 'auto'
line 9:       let l:next_renderer = 'python'
line 10:     elseif g:vimade.renderer == 'python'
line 11:       let l:next_renderer = g:vimade.renderer
line 12:     endif
line 13:   endif
line 14:   if l:next_renderer != g:vimade_active_renderer.name
line 15:     try
line 16:       call vimade#UnhighlightAll()
line 17:     catch
line 18:     endtry
line 19:     if l:next_renderer == 'lua'
line 20:       let g:vimade_active_renderer = s:lua_renderer
line 21:     elseif l:next_renderer == 'python'
line 22:       let g:vimade_active_renderer = s:python_renderer
line 23:     else
line 24:       let g:vimade_active_renderer = s:empty_renderer
line 25:     endif
line 26:   endif
vimade#SetupRenderer returning #0

continuing in vimade#UpdateState

vimade#UpdateState returning #0

continuing in vimade#CheckWindows

line 2:   "prevent if inside popup window
line 3:   " TODO: confirm if this is needed in newer renderers, which perform
line 4:   " significantly better
line 5:   if winnr() == 0 || pumvisible() 
line 6:     return
line 7:   endif
line 8:   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
line 9:     call g:vimade_active_renderer.update()
calling <SNR>92_Update_Lua()

line 1:   lua require('vimade').update()
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
<SNR>92_Update_Lua returning #0

continuing in vimade#CheckWindows

line 10:   endif
vimade#CheckWindows returning #0

continuing in vimade#Tick

line 3:   catch
line 4:     let g:vimade_error_count += 1
line 5:     if g:vimade_error_count >= 3
line 6:       let g:vimade_error_count = 0
line 7:       try
line 8:         VimadeDisable
line 9:       catch
line 10:         let g:vimade_running = 0
line 11:       endtry
line 12:     endif
line 13:     throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
line 14:   endtry
vimade#Tick returning #0

Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 226: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:432>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 297: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 502: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 508: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 505: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 364: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 226: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:432>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 297: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:76>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 502: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 508: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 505: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/scope.lua:680>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 364: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/indent.lua:518>

Executing: 
Searching for "autoload/provider/clipboard.vim" in runtime path
Searching for "/Users/joe/.config/nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/lazy.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/flash.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lint/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/todo-comments.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vim-sleuth/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/fidget.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-tool-installer.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason-lspconfig.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mason.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-lspconfig/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/gitsigns.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/blink.cmp/autoload/provider/clipboard.vim"
Searching for "/Users/joe/git/joe-p/fetch.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/llama.vim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/vimade/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/stickybuf.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-dark-mode.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/which-key.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/bufferline.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/kanso.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-textobjects/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/markview.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-treesitter-context/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/mini.icons/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/oil.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nui.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/nvim-web-devicons/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/plenary.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/neo-tree.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/auto-session/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/snacks.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/joe/.local/share/nvim/lazy/catppuccin/autoload/provider/clipboard.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim"
line 1: " The clipboard provider uses shell commands to communicate with the clipboard.
line 2: " The provider function will only be registered if a supported command is
line 3: " available.
line 4: 
line 5: if exists('g:loaded_clipboard_provider')
line 6:   finish
line 7: endif
line 8: " Default to 0.  provider#clipboard#Executable() may set 2.
line 9: " To force a reload:
line 10: "   :unlet g:loaded_clipboard_provider
line 11: "   :runtime autoload/provider/clipboard.vim
line 12: let g:loaded_clipboard_provider = 0
line 13: 
line 14: let s:copy = {}
line 15: let s:paste = {}
line 16: let s:clipboard = {}
line 17: 
line 18: " When caching is enabled, store the jobid of the xclip/xsel process keeping
line 19: " ownership of the selection, so we know how long the cache is valid.
line 20: let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
line 21: 
line 22: function! s:selection.on_exit(jobid, data, event) abort
line 35: 
line 36: let s:selections = { '*': s:selection, '+': copy(s:selection) }
line 37: 
line 38: function! s:try_cmd(cmd, ...) abort
line 51: 
line 52: " Returns TRUE if `cmd` exits with success, else FALSE.
line 53: function! s:cmd_ok(cmd) abort
line 57: 
line 58: function! s:split_cmd(cmd) abort
line 61: 
line 62: function! s:set_osc52() abort
line 69: 
line 70: function! s:set_pbcopy() abort
line 78: 
line 79: function! s:set_wayland() abort
line 86: 
line 87: function! s:set_wayclip() abort
line 94: 
line 95: function! s:set_xsel() abort
line 102: 
line 103: function! s:set_xclip() abort
line 110: 
line 111: function! s:set_lemonade() abort
line 118: 
line 119: function! s:set_doitclient() abort
line 126: 
line 127: function! s:set_win32yank() abort
line 139: 
line 140: function! s:set_putclip() abort
line 147: 
line 148: function! s:set_clip() abort
line 155: 
line 156: function! s:set_termux() abort
line 163: 
line 164: function! s:set_tmux() abort
line 176: 
line 177: let s:cache_enabled = 1
line 178: let s:err = ''
line 179: 
line 180: function! provider#clipboard#Error() abort
line 183: 
line 184: function! provider#clipboard#Executable() abort
line 269: 
line 270: function! s:clipboard.get(reg) abort
line 287: 
line 288: function! s:clipboard.set(lines, regtype, reg) abort
line 346: 
line 347: function! provider#clipboard#Call(method, args) abort
line 358: 
line 359: " eval_has_provider() decides based on this variable.
line 360: let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 0 : 2
calling provider#clipboard#Executable()

line 1:   " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
line 2:   if exists('g:clipboard') && g:clipboard isnot# v:false
line 3:     if v:t_string ==# type(g:clipboard)
line 4:       " Handle string form of g:clipboard for all builtin providers
line 5:       if 'osc52' == g:clipboard
line 6:         " User opted-in to OSC 52 by manually setting g:clipboard.
line 7:         return s:set_osc52()
line 8:       elseif 'pbcopy' == g:clipboard
line 9:         return s:set_pbcopy()
line 10:       elseif 'wl-copy' == g:clipboard
line 11:         return s:set_wayland()
line 12:       elseif 'wayclip' == g:clipboard
line 13:         return s:set_wayclip()
line 14:       elseif 'xsel' == g:clipboard
line 15:         return s:set_xsel()
line 16:       elseif 'xclip' == g:clipboard
line 17:         return s:set_xclip()
line 18:       elseif 'lemonade' == g:clipboard
line 19:         return s:set_lemonade()
line 20:       elseif 'doitclient' == g:clipboard
line 21:         return s:set_doitclient()
line 22:       elseif 'win32yank' == g:clipboard
line 23:         return s:set_win32yank()
line 24:       elseif 'putclip' == g:clipboard
line 25:         return s:set_putclip()
line 26:       elseif 'clip' == g:clipboard
line 27:         return s:set_clip()
line 28:       elseif 'termux' == g:clipboard
line 29:         return s:set_termux()
line 30:       elseif 'tmux' == g:clipboard
line 31:         return s:set_tmux()
line 32:       endif
line 33:     endif
line 34: 
line 35:     if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
line 38:       let s:err = 'clipboard: invalid g:clipboard'
line 39:       return ''
line 40:     endif
line 41: 
line 42:     let s:copy = {}
line 43:     let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
line 44:     let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
line 45: 
line 46:     let s:paste = {}
line 47:     let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
line 48:     let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
line 49: 
line 50:     let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
line 51:     return get(g:clipboard, 'name', 'g:clipboard')
line 52:   elseif has('mac')
line 53:     return s:set_pbcopy()
calling <SNR>124_set_pbcopy()

line 1:   let s:copy['+'] = ['pbcopy']
line 2:   let s:paste['+'] = ['pbpaste']
line 3:   let s:copy['*'] = s:copy['+']
line 4:   let s:paste['*'] = s:paste['+']
line 5:   let s:cache_enabled = 0
line 6:   return 'pbcopy'
<SNR>124_set_pbcopy returning 'pbcopy'

continuing in provider#clipboard#Executable

provider#clipboard#Executable returning 'pbcopy'

continuing in /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim

finished sourcing /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/autoload/provider/clipboard.vim
Executing OptionSet Autocommands for "*"
autocommand <Lua 290: ~/.local/share/nvim/lazy/nvim-treesitter-context/lua/treesitter-context.lua:148>

Executing: 
Executing OptionSet Autocommands for "runtimepath"
autocommand <Lua 232: /opt/homebrew/Cellar/neovim/0.11.1/share/nvim/runtime/lua/vim/treesitter/query.lua:338>

Executing: 
Executing OptionSet Autocommands for "*"
autocommand <Lua 307: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:172>

Executing: 
autocommand <Lua 309: ~/.local/share/nvim/lazy/markview.nvim/plugin/markview.lua:241>

Executing: 